/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("amp",{

/***/ "./node_modules/@swc/helpers/lib/_async_to_generator.js":
/*!**************************************************************!*\
  !*** ./node_modules/@swc/helpers/lib/_async_to_generator.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n    value: true\r\n}));\r\nexports[\"default\"] = _asyncToGenerator;\r\nfunction _asyncToGenerator(fn) {\r\n    return function() {\r\n        var self = this, args = arguments;\r\n        return new Promise(function(resolve, reject) {\r\n            var gen = fn.apply(self, args);\r\n            function _next(value) {\r\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\r\n            }\r\n            function _throw(err) {\r\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\r\n            }\r\n            _next(undefined);\r\n        });\r\n    };\r\n}\r\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\r\n    try {\r\n        var info = gen[key](arg);\r\n        var value = info.value;\r\n    } catch (error) {\r\n        reject(error);\r\n        return;\r\n    }\r\n    if (info.done) {\r\n        resolve(value);\r\n    } else {\r\n        Promise.resolve(value).then(_next, _throw);\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2xpYi9fYXN5bmNfdG9fZ2VuZXJhdG9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvbGliL19hc3luY190b19nZW5lcmF0b3IuanM/MGUzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gX2FzeW5jVG9HZW5lcmF0b3I7XHJcbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcclxuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGluZm8uZG9uZSkge1xyXG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/lib/_async_to_generator.js\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/lib/_extends.js":
/*!***************************************************!*\
  !*** ./node_modules/@swc/helpers/lib/_extends.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n    value: true\r\n}));\r\nexports[\"default\"] = _extends;\r\nfunction _extends() {\r\n    return extends_.apply(this, arguments);\r\n}\r\nfunction extends_() {\r\n    extends_ = Object.assign || function(target) {\r\n        for(var i = 1; i < arguments.length; i++){\r\n            var source = arguments[i];\r\n            for(var key in source){\r\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n                    target[key] = source[key];\r\n                }\r\n            }\r\n        }\r\n        return target;\r\n    };\r\n    return extends_.apply(this, arguments);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qcz8zOThhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICAgIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBfZXh0ZW5kcztcclxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XHJcbiAgICByZXR1cm4gZXh0ZW5kc18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5mdW5jdGlvbiBleHRlbmRzXygpIHtcclxuICAgIGV4dGVuZHNfID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcclxuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gc291cmNlKXtcclxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBleHRlbmRzXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/lib/_extends.js\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/lib/_interop_require_default.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@swc/helpers/lib/_interop_require_default.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n    value: true\r\n}));\r\nexports[\"default\"] = _interopRequireDefault;\r\nfunction _interopRequireDefault(obj) {\r\n    return obj && obj.__esModule ? obj : {\r\n        default: obj\r\n    };\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzPzliN2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gICAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xyXG4gICAgICAgIGRlZmF1bHQ6IG9ialxyXG4gICAgfTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/lib/_interop_require_default.js\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/lib/_interop_require_wildcard.js":
/*!********************************************************************!*\
  !*** ./node_modules/@swc/helpers/lib/_interop_require_wildcard.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n    value: true\r\n}));\r\nexports[\"default\"] = _interopRequireWildcard;\r\nfunction _interopRequireWildcard(obj, nodeInterop) {\r\n    if (!nodeInterop && obj && obj.__esModule) {\r\n        return obj;\r\n    }\r\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\r\n        return {\r\n            default: obj\r\n        };\r\n    }\r\n    var cache = _getRequireWildcardCache(nodeInterop);\r\n    if (cache && cache.has(obj)) {\r\n        return cache.get(obj);\r\n    }\r\n    var newObj = {};\r\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\r\n    for(var key in obj){\r\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\r\n            if (desc && (desc.get || desc.set)) {\r\n                Object.defineProperty(newObj, key, desc);\r\n            } else {\r\n                newObj[key] = obj[key];\r\n            }\r\n        }\r\n    }\r\n    newObj.default = obj;\r\n    if (cache) {\r\n        cache.set(obj, newObj);\r\n    }\r\n    return newObj;\r\n}\r\nfunction _getRequireWildcardCache(nodeInterop1) {\r\n    if (typeof WeakMap !== \"function\") return null;\r\n    var cacheBabelInterop = new WeakMap();\r\n    var cacheNodeInterop = new WeakMap();\r\n    return (_getRequireWildcardCache = function(nodeInterop) {\r\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\r\n    })(nodeInterop1);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanM/MDUxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ7XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHtcclxuICAgIGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkZWZhdWx0OiBvYmpcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTtcclxuICAgIGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZS5nZXQob2JqKTtcclxuICAgIH1cclxuICAgIHZhciBuZXdPYmogPSB7fTtcclxuICAgIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcclxuICAgIGZvcih2YXIga2V5IGluIG9iail7XHJcbiAgICAgICAgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDtcclxuICAgICAgICAgICAgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBuZXdPYmouZGVmYXVsdCA9IG9iajtcclxuICAgIGlmIChjYWNoZSkge1xyXG4gICAgICAgIGNhY2hlLnNldChvYmosIG5ld09iaik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3T2JqO1xyXG59XHJcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcDEpIHtcclxuICAgIGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDtcclxuICAgIHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uKG5vZGVJbnRlcm9wKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wO1xyXG4gICAgfSkobm9kZUludGVyb3AxKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\n"));

/***/ }),

/***/ "./node_modules/@swc/helpers/lib/_object_without_properties_loose.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@swc/helpers/lib/_object_without_properties_loose.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n    value: true\r\n}));\r\nexports[\"default\"] = _objectWithoutPropertiesLoose;\r\nfunction _objectWithoutPropertiesLoose(source, excluded) {\r\n    if (source == null) return {};\r\n    var target = {};\r\n    var sourceKeys = Object.keys(source);\r\n    var key, i;\r\n    for(i = 0; i < sourceKeys.length; i++){\r\n        key = sourceKeys[i];\r\n        if (excluded.indexOf(key) >= 0) continue;\r\n        target[key] = source[key];\r\n    }\r\n    return target;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2xpYi9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2xpYi9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZS5qcz80Y2I5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICAgIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZTtcclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xyXG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XHJcbiAgICB2YXIgdGFyZ2V0ID0ge307XHJcbiAgICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XHJcbiAgICB2YXIga2V5LCBpO1xyXG4gICAgZm9yKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcclxuICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xyXG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/lib/_object_without_properties_loose.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/add-base-path.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/client/add-base-path.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addBasePath = addBasePath;\nvar _addPathPrefix = __webpack_require__(/*! ../shared/lib/router/utils/add-path-prefix */ \"./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js\");\nvar _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath =  false || \"\";\nfunction addBasePath(path, required) {\n    if (false) {}\n    return (0, _normalizeTrailingSlash).normalizePathTrailingSlash((0, _addPathPrefix).addPathPrefix(path, basePath));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-base-path.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hZGQtYmFzZS1wYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELG1CQUFtQixHQUFHRTtBQUN0QixJQUFJQyxpQkFBaUJDLG1CQUFPQSxDQUFDLHVIQUE0QztBQUN6RSxJQUFJQywwQkFBMEJELG1CQUFPQSxDQUFDLCtGQUE0QjtBQUNsRSxNQUFNRSxXQUFXQyxNQUFrQyxJQUFJO0FBQ3ZELFNBQVNMLFlBQVlRLElBQUksRUFBRUMsUUFBUSxFQUFFO0lBQ2pDLElBQUlKLEtBQTBDLEVBQUUsRUFJL0M7SUFDRCxPQUFPLENBQUMsR0FBR0YsdUJBQXVCLEVBQUVRLDBCQUEwQixDQUFDLENBQUMsR0FBR1YsY0FBYyxFQUFFVyxhQUFhLENBQUNKLE1BQU1KO0FBQzNHO0FBRUEsSUFBSSxDQUFDLE9BQU9OLFFBQVFlLE9BQU8sS0FBSyxjQUFlLE9BQU9mLFFBQVFlLE9BQU8sS0FBSyxZQUFZZixRQUFRZSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9mLFFBQVFlLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktsQixPQUFPQyxjQUFjLENBQUNDLFFBQVFlLE9BQU8sRUFBRSxjQUFjO1FBQUVkLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPbUIsTUFBTSxDQUFDakIsUUFBUWUsT0FBTyxFQUFFZjtJQUMvQmtCLE9BQU9sQixPQUFPLEdBQUdBLFFBQVFlLE9BQU87QUFDbEMsQ0FBQyxDQUVELHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hZGQtYmFzZS1wYXRoLmpzPzYxMzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gICAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuYWRkQmFzZVBhdGggPSBhZGRCYXNlUGF0aDtcclxudmFyIF9hZGRQYXRoUHJlZml4ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FkZC1wYXRoLXByZWZpeFwiKTtcclxudmFyIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoID0gcmVxdWlyZShcIi4vbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoXCIpO1xyXG5jb25zdCBiYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgJyc7XHJcbmZ1bmN0aW9uIGFkZEJhc2VQYXRoKHBhdGgsIHJlcXVpcmVkKSB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX01BTlVBTF9DTElFTlRfQkFTRV9QQVRIKSB7XHJcbiAgICAgICAgaWYgKCFyZXF1aXJlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5ub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCgoMCwgX2FkZFBhdGhQcmVmaXgpLmFkZFBhdGhQcmVmaXgocGF0aCwgYmFzZVBhdGgpKTtcclxufVxyXG5cclxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcclxuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcclxufVxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLWJhc2UtcGF0aC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhZGRCYXNlUGF0aCIsIl9hZGRQYXRoUHJlZml4IiwicmVxdWlyZSIsIl9ub3JtYWxpemVUcmFpbGluZ1NsYXNoIiwiYmFzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInBhdGgiLCJyZXF1aXJlZCIsIl9fTkVYVF9NQU5VQUxfQ0xJRU5UX0JBU0VfUEFUSCIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwiYWRkUGF0aFByZWZpeCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/add-base-path.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/add-locale.js":
/*!*****************************************************!*\
  !*** ./node_modules/next/dist/client/add-locale.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addLocale = void 0;\nvar _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst addLocale = function(path) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (false) {}\n    return path;\n};\nexports.addLocale = addLocale;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hZGQtbG9jYWxlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGlCQUFpQixHQUFHLEtBQUs7QUFDekIsSUFBSUcsMEJBQTBCQyxtQkFBT0EsQ0FBQywrRkFBNEI7QUFDbEUsTUFBTUYsWUFBWSxTQUFDRyxNQUFnQjtxQ0FBUEM7UUFBQUE7O0lBQ3hCLElBQUlDLEtBQStCLEVBQUUsRUFFcEM7SUFDRCxPQUFPRjtBQUNYO0FBQ0FMLGlCQUFpQixHQUFHRTtBQUVwQixJQUFJLENBQUMsT0FBT0YsUUFBUVcsT0FBTyxLQUFLLGNBQWUsT0FBT1gsUUFBUVcsT0FBTyxLQUFLLFlBQVlYLFFBQVFXLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1gsUUFBUVcsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2QsT0FBT0MsY0FBYyxDQUFDQyxRQUFRVyxPQUFPLEVBQUUsY0FBYztRQUFFVixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2UsTUFBTSxDQUFDYixRQUFRVyxPQUFPLEVBQUVYO0lBQy9CYyxPQUFPZCxPQUFPLEdBQUdBLFFBQVFXLE9BQU87QUFDbEMsQ0FBQyxDQUVELHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hZGQtbG9jYWxlLmpzP2UyZDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gICAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuYWRkTG9jYWxlID0gdm9pZCAwO1xyXG52YXIgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2ggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2hcIik7XHJcbmNvbnN0IGFkZExvY2FsZSA9IChwYXRoLCAuLi5hcmdzKT0+e1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcclxuICAgICAgICByZXR1cm4gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5ub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaChyZXF1aXJlKCcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtbG9jYWxlJykuYWRkTG9jYWxlKHBhdGgsIC4uLmFyZ3MpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoO1xyXG59O1xyXG5leHBvcnRzLmFkZExvY2FsZSA9IGFkZExvY2FsZTtcclxuXHJcbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XHJcbn1cclxuXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZC1sb2NhbGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYWRkTG9jYWxlIiwiX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2giLCJyZXF1aXJlIiwicGF0aCIsImFyZ3MiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/add-locale.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/dev/amp-dev.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/dev/amp-dev.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _fouc = __webpack_require__(/*! ./fouc */ \"./node_modules/next/dist/client/dev/fouc.js\");\nvar _onDemandEntriesClient = _interop_require_default(__webpack_require__(/*! ./on-demand-entries-client */ \"./node_modules/next/dist/client/dev/on-demand-entries-client.js\"));\nvar _websocket = __webpack_require__(/*! ./error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nconst data = JSON.parse(document.getElementById(\"__NEXT_DATA__\").textContent);\nwindow.__NEXT_DATA__ = data;\nlet { assetPrefix , page  } = data;\nassetPrefix = assetPrefix || \"\";\nlet mostRecentHash = null;\n/* eslint-disable-next-line */ let curHash = __webpack_require__.h();\nconst hotUpdatePath = assetPrefix + (assetPrefix.endsWith(\"/\") ? \"\" : \"/\") + \"_next/static/webpack/\";\n// Is there a newer version of this code available?\nfunction isUpdateAvailable() {\n    // __webpack_hash__ is the hash of the current compilation.\n    // It's a global variable injected by Webpack.\n    /* eslint-disable-next-line */ return mostRecentHash !== __webpack_require__.h();\n}\n// Webpack disallows updates in other states.\nfunction canApplyUpdates() {\n    return module.hot.status() === \"idle\";\n}\nfunction tryApplyUpdates() {\n    return _tryApplyUpdates.apply(this, arguments);\n}\nfunction _tryApplyUpdates() {\n    _tryApplyUpdates = // reloads the page when it has changed.\n    _async_to_generator(function*() {\n        if (!isUpdateAvailable() || !canApplyUpdates()) {\n            return;\n        }\n        try {\n            const res = yield fetch(typeof __webpack_require__.j !== \"undefined\" ? \"\".concat(hotUpdatePath).concat(curHash, \".\").concat(__webpack_require__.j, \".hot-update.json\") : \"\".concat(hotUpdatePath).concat(curHash, \".hot-update.json\"));\n            const jsonData = yield res.json();\n            const curPage = page === \"/\" ? \"index\" : page;\n            // webpack 5 uses an array instead\n            const pageUpdated = (Array.isArray(jsonData.c) ? jsonData.c : Object.keys(jsonData.c)).some((mod)=>{\n                return mod.indexOf(\"pages\".concat(curPage.startsWith(\"/\") ? curPage : \"/\".concat(curPage))) !== -1 || mod.indexOf(\"pages\".concat(curPage.startsWith(\"/\") ? curPage : \"/\".concat(curPage)).replace(/\\//g, \"\\\\\")) !== -1;\n            });\n            if (pageUpdated) {\n                document.location.reload(true);\n            } else {\n                curHash = mostRecentHash;\n            }\n        } catch (err) {\n            console.error(\"Error occurred checking for update\", err);\n            document.location.reload(true);\n        }\n    });\n    return _tryApplyUpdates.apply(this, arguments);\n}\n(0, _websocket).addMessageListener((event)=>{\n    if (event.data === \"\\uD83D\\uDC93\") {\n        return;\n    }\n    try {\n        const message = JSON.parse(event.data);\n        if (message.action === \"sync\" || message.action === \"built\") {\n            if (!message.hash) {\n                return;\n            }\n            mostRecentHash = message.hash;\n            tryApplyUpdates();\n        } else if (message.action === \"reloadPage\") {\n            document.location.reload(true);\n        }\n    } catch (ex) {\n        console.warn(\"Invalid HMR message: \" + event.data + \"\\n\" + ex);\n    }\n});\n(0, _websocket).connectHMR({\n    assetPrefix,\n    path: \"/_next/webpack-hmr\"\n});\n(0, _fouc).displayContent();\n(0, _onDemandEntriesClient).default(data.page);\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=amp-dev.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvYW1wLWRldi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLHNCQUFzQkMseUlBQTBEO0FBQ3BGLElBQUlFLDJCQUEyQkYsbUpBQStEO0FBQzlGLElBQUlHLFFBQVFILG1CQUFPQSxDQUFDLDJEQUFRO0FBQzVCLElBQUlJLHlCQUF5QkYseUJBQXlCRixtQkFBT0EsQ0FBQyxtR0FBNEI7QUFDMUYsSUFBSUssYUFBYUwsbUJBQU9BLENBQUMsaUdBQTJCO0FBQ3BELE1BQU1NLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0MsU0FBU0MsY0FBYyxDQUFDLGlCQUFpQkMsV0FBVztBQUM1RUMsT0FBT0MsYUFBYSxHQUFHUDtBQUN2QixJQUFJLEVBQUVRLFlBQVcsRUFBR0MsS0FBSSxFQUFHLEdBQUdUO0FBQzlCUSxjQUFjQSxlQUFlO0FBQzdCLElBQUlFLGlCQUFpQixJQUFJO0FBQ3pCLDRCQUE0QixHQUFHLElBQUlDLFVBQVVDLHVCQUFnQkE7QUFDN0QsTUFBTUMsZ0JBQWdCTCxjQUFlQSxDQUFBQSxZQUFZTSxRQUFRLENBQUMsT0FBTyxLQUFLLEdBQUcsSUFBSTtBQUM3RSxtREFBbUQ7QUFDbkQsU0FBU0Msb0JBQW9CO0lBQ3pCLDJEQUEyRDtJQUMzRCw4Q0FBOEM7SUFDOUMsNEJBQTRCLEdBQUcsT0FBT0wsbUJBQW1CRSx1QkFBZ0JBO0FBQzdFO0FBQ0EsNkNBQTZDO0FBQzdDLFNBQVNJLGtCQUFrQjtJQUN2QixPQUFPQyxVQUFVLENBQUNFLE1BQU0sT0FBTztBQUNuQztBQUNBLFNBQVNDLGtCQUFrQjtJQUN2QixPQUFPQyxpQkFBaUJDLEtBQUssQ0FBQyxJQUFJLEVBQUVDO0FBQ3hDO0FBQ0EsU0FBU0YsbUJBQW1CO0lBQ3hCQSxtQkFDQSx3Q0FBd0M7SUFDeEM1QixvQkFBb0IsWUFBWTtRQUM1QixJQUFJLENBQUNzQix1QkFBdUIsQ0FBQ0MsbUJBQW1CO1lBQzVDO1FBQ0osQ0FBQztRQUNELElB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ZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvYW1wLWRldi5qcz81Y2NmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX2FzeW5jX3RvX2dlbmVyYXRvciA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19hc3luY190b19nZW5lcmF0b3IuanNcIikuZGVmYXVsdDtcclxudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xyXG52YXIgX2ZvdWMgPSByZXF1aXJlKFwiLi9mb3VjXCIpO1xyXG52YXIgX29uRGVtYW5kRW50cmllc0NsaWVudCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi9vbi1kZW1hbmQtZW50cmllcy1jbGllbnRcIikpO1xyXG52YXIgX3dlYnNvY2tldCA9IHJlcXVpcmUoXCIuL2Vycm9yLW92ZXJsYXkvd2Vic29ja2V0XCIpO1xyXG5jb25zdCBkYXRhID0gSlNPTi5wYXJzZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19ORVhUX0RBVEFfXycpLnRleHRDb250ZW50KTtcclxud2luZG93Ll9fTkVYVF9EQVRBX18gPSBkYXRhO1xyXG5sZXQgeyBhc3NldFByZWZpeCAsIHBhZ2UgIH0gPSBkYXRhO1xyXG5hc3NldFByZWZpeCA9IGFzc2V0UHJlZml4IHx8ICcnO1xyXG5sZXQgbW9zdFJlY2VudEhhc2ggPSBudWxsO1xyXG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgKi8gbGV0IGN1ckhhc2ggPSBfX3dlYnBhY2tfaGFzaF9fO1xyXG5jb25zdCBob3RVcGRhdGVQYXRoID0gYXNzZXRQcmVmaXggKyAoYXNzZXRQcmVmaXguZW5kc1dpdGgoJy8nKSA/ICcnIDogJy8nKSArICdfbmV4dC9zdGF0aWMvd2VicGFjay8nO1xyXG4vLyBJcyB0aGVyZSBhIG5ld2VyIHZlcnNpb24gb2YgdGhpcyBjb2RlIGF2YWlsYWJsZT9cclxuZnVuY3Rpb24gaXNVcGRhdGVBdmFpbGFibGUoKSB7XHJcbiAgICAvLyBfX3dlYnBhY2tfaGFzaF9fIGlzIHRoZSBoYXNoIG9mIHRoZSBjdXJyZW50IGNvbXBpbGF0aW9uLlxyXG4gICAgLy8gSXQncyBhIGdsb2JhbCB2YXJpYWJsZSBpbmplY3RlZCBieSBXZWJwYWNrLlxyXG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICovIHJldHVybiBtb3N0UmVjZW50SGFzaCAhPT0gX193ZWJwYWNrX2hhc2hfXztcclxufVxyXG4vLyBXZWJwYWNrIGRpc2FsbG93cyB1cGRhdGVzIGluIG90aGVyIHN0YXRlcy5cclxuZnVuY3Rpb24gY2FuQXBwbHlVcGRhdGVzKCkge1xyXG4gICAgcmV0dXJuIG1vZHVsZS5ob3Quc3RhdHVzKCkgPT09ICdpZGxlJztcclxufVxyXG5mdW5jdGlvbiB0cnlBcHBseVVwZGF0ZXMoKSB7XHJcbiAgICByZXR1cm4gX3RyeUFwcGx5VXBkYXRlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcbmZ1bmN0aW9uIF90cnlBcHBseVVwZGF0ZXMoKSB7XHJcbiAgICBfdHJ5QXBwbHlVcGRhdGVzID0gLy8gVGhpcyBmdW5jdGlvbiByZWFkcyBjb2RlIHVwZGF0ZXMgb24gdGhlIGZseSBhbmQgaGFyZFxyXG4gICAgLy8gcmVsb2FkcyB0aGUgcGFnZSB3aGVuIGl0IGhhcyBjaGFuZ2VkLlxyXG4gICAgX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbiooKSB7XHJcbiAgICAgICAgaWYgKCFpc1VwZGF0ZUF2YWlsYWJsZSgpIHx8ICFjYW5BcHBseVVwZGF0ZXMoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIGZldGNoKHR5cGVvZiBfX3dlYnBhY2tfcnVudGltZV9pZF9fICE9PSAndW5kZWZpbmVkJyA/IGAke2hvdFVwZGF0ZVBhdGh9JHtjdXJIYXNofS4ke19fd2VicGFja19ydW50aW1lX2lkX199LmhvdC11cGRhdGUuanNvbmAgOiBgJHtob3RVcGRhdGVQYXRofSR7Y3VySGFzaH0uaG90LXVwZGF0ZS5qc29uYCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGpzb25EYXRhID0geWllbGQgcmVzLmpzb24oKTtcclxuICAgICAgICAgICAgY29uc3QgY3VyUGFnZSA9IHBhZ2UgPT09ICcvJyA/ICdpbmRleCcgOiBwYWdlO1xyXG4gICAgICAgICAgICAvLyB3ZWJwYWNrIDUgdXNlcyBhbiBhcnJheSBpbnN0ZWFkXHJcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VVcGRhdGVkID0gKEFycmF5LmlzQXJyYXkoanNvbkRhdGEuYykgPyBqc29uRGF0YS5jIDogT2JqZWN0LmtleXMoanNvbkRhdGEuYykpLnNvbWUoKG1vZCk9PntcclxuICAgICAgICAgICAgICAgIHJldHVybiBtb2QuaW5kZXhPZihgcGFnZXMke2N1clBhZ2Uuc3RhcnRzV2l0aCgnLycpID8gY3VyUGFnZSA6IGAvJHtjdXJQYWdlfWB9YCkgIT09IC0xIHx8IG1vZC5pbmRleE9mKGBwYWdlcyR7Y3VyUGFnZS5zdGFydHNXaXRoKCcvJykgPyBjdXJQYWdlIDogYC8ke2N1clBhZ2V9YH1gLnJlcGxhY2UoL1xcLy9nLCAnXFxcXCcpKSAhPT0gLTE7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAocGFnZVVwZGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1ckhhc2ggPSBtb3N0UmVjZW50SGFzaDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBvY2N1cnJlZCBjaGVja2luZyBmb3IgdXBkYXRlJywgZXJyKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQubG9jYXRpb24ucmVsb2FkKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF90cnlBcHBseVVwZGF0ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG4oMCwgX3dlYnNvY2tldCkuYWRkTWVzc2FnZUxpc3RlbmVyKChldmVudCk9PntcclxuICAgIGlmIChldmVudC5kYXRhID09PSAnXFx1RDgzRFxcdURDOTMnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcclxuICAgICAgICBpZiAobWVzc2FnZS5hY3Rpb24gPT09ICdzeW5jJyB8fCBtZXNzYWdlLmFjdGlvbiA9PT0gJ2J1aWx0Jykge1xyXG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UuaGFzaCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1vc3RSZWNlbnRIYXNoID0gbWVzc2FnZS5oYXNoO1xyXG4gICAgICAgICAgICB0cnlBcHBseVVwZGF0ZXMoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UuYWN0aW9uID09PSAncmVsb2FkUGFnZScpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQubG9jYXRpb24ucmVsb2FkKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIEhNUiBtZXNzYWdlOiAnICsgZXZlbnQuZGF0YSArICdcXG4nICsgZXgpO1xyXG4gICAgfVxyXG59KTtcclxuKDAsIF93ZWJzb2NrZXQpLmNvbm5lY3RITVIoe1xyXG4gICAgYXNzZXRQcmVmaXgsXHJcbiAgICBwYXRoOiAnL19uZXh0L3dlYnBhY2staG1yJ1xyXG59KTtcclxuKDAsIF9mb3VjKS5kaXNwbGF5Q29udGVudCgpO1xyXG4oMCwgX29uRGVtYW5kRW50cmllc0NsaWVudCkuZGVmYXVsdChkYXRhLnBhZ2UpO1xyXG5cclxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcclxuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcclxufVxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW1wLWRldi5qcy5tYXAiXSwibmFtZXMiOlsiX2FzeW5jX3RvX2dlbmVyYXRvciIsInJlcXVpcmUiLCJkZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX2ZvdWMiLCJfb25EZW1hbmRFbnRyaWVzQ2xpZW50IiwiX3dlYnNvY2tldCIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwidGV4dENvbnRlbnQiLCJ3aW5kb3ciLCJfX05FWFRfREFUQV9fIiwiYXNzZXRQcmVmaXgiLCJwYWdlIiwibW9zdFJlY2VudEhhc2giLCJjdXJIYXNoIiwiX193ZWJwYWNrX2hhc2hfXyIsImhvdFVwZGF0ZVBhdGgiLCJlbmRzV2l0aCIsImlzVXBkYXRlQXZhaWxhYmxlIiwiY2FuQXBwbHlVcGRhdGVzIiwibW9kdWxlIiwiaG90Iiwic3RhdHVzIiwidHJ5QXBwbHlVcGRhdGVzIiwiX3RyeUFwcGx5VXBkYXRlcyIsImFwcGx5IiwiYXJndW1lbnRzIiwicmVzIiwiZmV0Y2giLCJfX3dlYnBhY2tfcnVudGltZV9pZF9fIiwianNvbkRhdGEiLCJqc29uIiwiY3VyUGFnZSIsInBhZ2VVcGRhdGVkIiwiQXJyYXkiLCJpc0FycmF5IiwiYyIsIk9iamVjdCIsImtleXMiLCJzb21lIiwibW9kIiwiaW5kZXhPZiIsInN0YXJ0c1dpdGgiLCJyZXBsYWNlIiwibG9jYXRpb24iLCJyZWxvYWQiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJhZGRNZXNzYWdlTGlzdGVuZXIiLCJldmVudCIsIm1lc3NhZ2UiLCJhY3Rpb24iLCJoYXNoIiwiZXgiLCJ3YXJuIiwiY29ubmVjdEhNUiIsInBhdGgiLCJkaXNwbGF5Q29udGVudCIsImV4cG9ydHMiLCJfX2VzTW9kdWxlIiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImFzc2lnbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/amp-dev.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/websocket.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/websocket.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addMessageListener = addMessageListener;\nexports.sendMessage = sendMessage;\nexports.connectHMR = connectHMR;\nlet source;\nconst eventCallbacks = [];\nlet lastActivity = Date.now();\nfunction getSocketProtocol(assetPrefix) {\n    let protocol = location.protocol;\n    try {\n        // assetPrefix is a url\n        protocol = new URL(assetPrefix).protocol;\n    } catch (_) {}\n    return protocol === \"http:\" ? \"ws\" : \"wss\";\n}\nfunction addMessageListener(cb) {\n    eventCallbacks.push(cb);\n}\nfunction sendMessage(data) {\n    if (!source || source.readyState !== source.OPEN) return;\n    return source.send(data);\n}\nfunction connectHMR(options) {\n    if (!options.timeout) {\n        options.timeout = 5 * 1000;\n    }\n    function init() {\n        if (source) source.close();\n        function handleOnline() {\n            if (options.log) console.log(\"[HMR] connected\");\n            lastActivity = Date.now();\n        }\n        function handleMessage(event) {\n            lastActivity = Date.now();\n            eventCallbacks.forEach((cb)=>{\n                cb(event);\n            });\n        }\n        let timer;\n        function handleDisconnect() {\n            clearInterval(timer);\n            source.close();\n            setTimeout(init, options.timeout);\n        }\n        timer = setInterval(function() {\n            if (Date.now() - lastActivity > options.timeout) {\n                handleDisconnect();\n            }\n        }, options.timeout / 2);\n        const { hostname , port  } = location;\n        const protocol = getSocketProtocol(options.assetPrefix || \"\");\n        const assetPrefix = options.assetPrefix.replace(/^\\/+/, \"\");\n        let url = \"\".concat(protocol, \"://\").concat(hostname, \":\").concat(port).concat(assetPrefix ? \"/\".concat(assetPrefix) : \"\");\n        if (assetPrefix.startsWith(\"http\")) {\n            url = \"\".concat(protocol, \"://\").concat(assetPrefix.split(\"://\")[1]);\n        }\n        source = new window.WebSocket(\"\".concat(url).concat(options.path));\n        source.onopen = handleOnline;\n        source.onerror = handleDisconnect;\n        source.onmessage = handleMessage;\n    }\n    init();\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=websocket.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZXJyb3Itb3ZlcmxheS93ZWJzb2NrZXQuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsMEJBQTBCLEdBQUdFO0FBQzdCRixtQkFBbUIsR0FBR0c7QUFDdEJILGtCQUFrQixHQUFHSTtBQUNyQixJQUFJQztBQUNKLE1BQU1DLGlCQUFpQixFQUFFO0FBQ3pCLElBQUlDLGVBQWVDLEtBQUtDLEdBQUc7QUFDM0IsU0FBU0Msa0JBQWtCQyxXQUFXLEVBQUU7SUFDcEMsSUFBSUMsV0FBV0MsU0FBU0QsUUFBUTtJQUNoQyxJQUFJO1FBQ0EsdUJBQXVCO1FBQ3ZCQSxXQUFXLElBQUlFLElBQUlILGFBQWFDLFFBQVE7SUFDNUMsRUFBRSxPQUFPRyxHQUFHLENBQUM7SUFDYixPQUFPSCxhQUFhLFVBQVUsT0FBTyxLQUFLO0FBQzlDO0FBQ0EsU0FBU1YsbUJBQW1CYyxFQUFFLEVBQUU7SUFDNUJWLGVBQWVXLElBQUksQ0FBQ0Q7QUFDeEI7QUFDQSxTQUFTYixZQUFZZSxJQUFJLEVBQUU7SUFDdkIsSUFBSSxDQUFDYixVQUFVQSxPQUFPYyxVQUFVLEtBQUtkLE9BQU9lLElBQUksRUFBRTtJQUNsRCxPQUFPZixPQUFPZ0IsSUFBSSxDQUFDSDtBQUN2QjtBQUNBLFNBQVNkLFdBQVdrQixPQUFPLEVBQUU7SUFDekIsSUFBSSxDQUFDQSxRQUFRQyxPQUFPLEVBQUU7UUFDbEJELFFBQVFDLE9BQU8sR0FBRyxJQUFJO0lBQzFCLENBQUM7SUFDRCxTQUFTQyxPQUFPO1FBQ1osSUFBSW5CLFFBQVFBLE9BQU9vQixLQUFLO1FBQ3hCLFNBQVNDLGVBQWU7WUFDcEIsSUFBSUosUUFBUUssR0FBRyxFQUFFQyxRQUFRRCxHQUFHLENBQUM7WUFDN0JwQixlQUFlQyxLQUFLQyxHQUFHO1FBQzNCO1FBQ0EsU0FBU29CLGNBQWNDLEtBQUssRUFBRTtZQUMxQnZCLGVBQWVDLEtBQUtDLEdBQUc7WUFDdkJILGVBQWV5QixPQUFPLENBQUMsQ0FBQ2YsS0FBSztnQkFDekJBLEdBQUdjO1lBQ1A7UUFDSjtRQUNBLElBQUlFO1FBQ0osU0FBU0MsbUJBQW1CO1lBQ3hCQyxjQUFjRjtZQUNkM0IsT0FBT29CLEtBQUs7WUFDWlUsV0FBV1gsTUFBTUYsUUFBUUMsT0FBTztRQUNwQztRQUNBUyxRQUFRSSxZQUFZLFdBQVc7WUFDM0IsSUFBSTVCLEtBQUtDLEdBQUcsS0FBS0YsZUFBZWUsUUFBUUMsT0FBTyxFQUFFO2dCQUM3Q1U7WUFDSixDQUFDO1FBQ0wsR0FBR1gsUUFBUUMsT0FBTyxHQUFHO1FBQ3JCLE1BQU0sRUFBRWMsU0FBUSxFQUFHQyxLQUFJLEVBQUcsR0FBR3pCO1FBQzdCLE1BQU1ELFdBQVdGLGtCQUFrQlksUUFBUVgsV0FBVyxJQUFJO1FBQzFELE1BQU1BLGNBQWNXLFFBQVFYLFdBQVcsQ0FBQzRCLE9BQU8sQ0FBQyxRQUFRO1FBQ3hELElBQUlDLE1BQU0sR0FBaUJILE9BQWR6QixVQUFTLE9BQWlCMEIsT0FBWkQsVUFBUyxLQUFVMUIsT0FBUDJCLE1BQTRDLE9BQXJDM0IsY0FBYyxJQUFnQixPQUFaQSxlQUFnQixFQUFFO1FBQ2xGLElBQUlBLFlBQVk4QixVQUFVLENBQUMsU0FBUztZQUNoQ0QsTUFBTSxHQUFpQjdCLE9BQWRDLFVBQVMsT0FBaUMsT0FBNUJELFlBQVkrQixLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDdEQsQ0FBQztRQUNEckMsU0FBUyxJQUFJc0MsT0FBT0MsU0FBUyxDQUFDLEdBQVN0QixPQUFOa0IsS0FBbUIsT0FBYmxCLFFBQVF1QixJQUFJO1FBQ25EeEMsT0FBT3lDLE1BQU0sR0FBR3BCO1FBQ2hCckIsT0FBTzBDLE9BQU8sR0FBR2Q7UUFDakI1QixPQUFPMkMsU0FBUyxHQUFHbkI7SUFDdkI7SUFDQUw7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPeEIsUUFBUWlELE9BQU8sS0FBSyxjQUFlLE9BQU9qRCxRQUFRaUQsT0FBTyxLQUFLLFlBQVlqRCxRQUFRaUQsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPakQsUUFBUWlELE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktwRCxPQUFPQyxjQUFjLENBQUNDLFFBQVFpRCxPQUFPLEVBQUUsY0FBYztRQUFFaEQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9xRCxNQUFNLENBQUNuRCxRQUFRaUQsT0FBTyxFQUFFakQ7SUFDL0JvRCxPQUFPcEQsT0FBTyxHQUFHQSxRQUFRaUQsT0FBTztBQUNsQyxDQUFDLENBRUQscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2Rldi9lcnJvci1vdmVybGF5L3dlYnNvY2tldC5qcz9hOWJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICAgIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmFkZE1lc3NhZ2VMaXN0ZW5lciA9IGFkZE1lc3NhZ2VMaXN0ZW5lcjtcclxuZXhwb3J0cy5zZW5kTWVzc2FnZSA9IHNlbmRNZXNzYWdlO1xyXG5leHBvcnRzLmNvbm5lY3RITVIgPSBjb25uZWN0SE1SO1xyXG5sZXQgc291cmNlO1xyXG5jb25zdCBldmVudENhbGxiYWNrcyA9IFtdO1xyXG5sZXQgbGFzdEFjdGl2aXR5ID0gRGF0ZS5ub3coKTtcclxuZnVuY3Rpb24gZ2V0U29ja2V0UHJvdG9jb2woYXNzZXRQcmVmaXgpIHtcclxuICAgIGxldCBwcm90b2NvbCA9IGxvY2F0aW9uLnByb3RvY29sO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBhc3NldFByZWZpeCBpcyBhIHVybFxyXG4gICAgICAgIHByb3RvY29sID0gbmV3IFVSTChhc3NldFByZWZpeCkucHJvdG9jb2w7XHJcbiAgICB9IGNhdGNoIChfKSB7fVxyXG4gICAgcmV0dXJuIHByb3RvY29sID09PSAnaHR0cDonID8gJ3dzJyA6ICd3c3MnO1xyXG59XHJcbmZ1bmN0aW9uIGFkZE1lc3NhZ2VMaXN0ZW5lcihjYikge1xyXG4gICAgZXZlbnRDYWxsYmFja3MucHVzaChjYik7XHJcbn1cclxuZnVuY3Rpb24gc2VuZE1lc3NhZ2UoZGF0YSkge1xyXG4gICAgaWYgKCFzb3VyY2UgfHwgc291cmNlLnJlYWR5U3RhdGUgIT09IHNvdXJjZS5PUEVOKSByZXR1cm47XHJcbiAgICByZXR1cm4gc291cmNlLnNlbmQoZGF0YSk7XHJcbn1cclxuZnVuY3Rpb24gY29ubmVjdEhNUihvcHRpb25zKSB7XHJcbiAgICBpZiAoIW9wdGlvbnMudGltZW91dCkge1xyXG4gICAgICAgIG9wdGlvbnMudGltZW91dCA9IDUgKiAxMDAwO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcclxuICAgICAgICBpZiAoc291cmNlKSBzb3VyY2UuY2xvc2UoKTtcclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVPbmxpbmUoKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxvZykgY29uc29sZS5sb2coJ1tITVJdIGNvbm5lY3RlZCcpO1xyXG4gICAgICAgICAgICBsYXN0QWN0aXZpdHkgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGxhc3RBY3Rpdml0eSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGV2ZW50Q2FsbGJhY2tzLmZvckVhY2goKGNiKT0+e1xyXG4gICAgICAgICAgICAgICAgY2IoZXZlbnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRpbWVyO1xyXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZURpc2Nvbm5lY3QoKSB7XHJcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xyXG4gICAgICAgICAgICBzb3VyY2UuY2xvc2UoKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dChpbml0LCBvcHRpb25zLnRpbWVvdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIGxhc3RBY3Rpdml0eSA+IG9wdGlvbnMudGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0IC8gMik7XHJcbiAgICAgICAgY29uc3QgeyBob3N0bmFtZSAsIHBvcnQgIH0gPSBsb2NhdGlvbjtcclxuICAgICAgICBjb25zdCBwcm90b2NvbCA9IGdldFNvY2tldFByb3RvY29sKG9wdGlvbnMuYXNzZXRQcmVmaXggfHwgJycpO1xyXG4gICAgICAgIGNvbnN0IGFzc2V0UHJlZml4ID0gb3B0aW9ucy5hc3NldFByZWZpeC5yZXBsYWNlKC9eXFwvKy8sICcnKTtcclxuICAgICAgICBsZXQgdXJsID0gYCR7cHJvdG9jb2x9Oi8vJHtob3N0bmFtZX06JHtwb3J0fSR7YXNzZXRQcmVmaXggPyBgLyR7YXNzZXRQcmVmaXh9YCA6ICcnfWA7XHJcbiAgICAgICAgaWYgKGFzc2V0UHJlZml4LnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xyXG4gICAgICAgICAgICB1cmwgPSBgJHtwcm90b2NvbH06Ly8ke2Fzc2V0UHJlZml4LnNwbGl0KCc6Ly8nKVsxXX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzb3VyY2UgPSBuZXcgd2luZG93LldlYlNvY2tldChgJHt1cmx9JHtvcHRpb25zLnBhdGh9YCk7XHJcbiAgICAgICAgc291cmNlLm9ub3BlbiA9IGhhbmRsZU9ubGluZTtcclxuICAgICAgICBzb3VyY2Uub25lcnJvciA9IGhhbmRsZURpc2Nvbm5lY3Q7XHJcbiAgICAgICAgc291cmNlLm9ubWVzc2FnZSA9IGhhbmRsZU1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICBpbml0KCk7XHJcbn1cclxuXHJcbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XHJcbn1cclxuXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYnNvY2tldC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhZGRNZXNzYWdlTGlzdGVuZXIiLCJzZW5kTWVzc2FnZSIsImNvbm5lY3RITVIiLCJzb3VyY2UiLCJldmVudENhbGxiYWNrcyIsImxhc3RBY3Rpdml0eSIsIkRhdGUiLCJub3ciLCJnZXRTb2NrZXRQcm90b2NvbCIsImFzc2V0UHJlZml4IiwicHJvdG9jb2wiLCJsb2NhdGlvbiIsIlVSTCIsIl8iLCJjYiIsInB1c2giLCJkYXRhIiwicmVhZHlTdGF0ZSIsIk9QRU4iLCJzZW5kIiwib3B0aW9ucyIsInRpbWVvdXQiLCJpbml0IiwiY2xvc2UiLCJoYW5kbGVPbmxpbmUiLCJsb2ciLCJjb25zb2xlIiwiaGFuZGxlTWVzc2FnZSIsImV2ZW50IiwiZm9yRWFjaCIsInRpbWVyIiwiaGFuZGxlRGlzY29ubmVjdCIsImNsZWFySW50ZXJ2YWwiLCJzZXRUaW1lb3V0Iiwic2V0SW50ZXJ2YWwiLCJob3N0bmFtZSIsInBvcnQiLCJyZXBsYWNlIiwidXJsIiwic3RhcnRzV2l0aCIsInNwbGl0Iiwid2luZG93IiwiV2ViU29ja2V0IiwicGF0aCIsIm9ub3BlbiIsIm9uZXJyb3IiLCJvbm1lc3NhZ2UiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/error-overlay/websocket.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/dev/fouc.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/dev/fouc.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.displayContent = displayContent;\n// This wrapper function is used to safely select the best available function\n// to schedule removal of the no-FOUC styles workaround. requestAnimationFrame\n// is the ideal choice, but when used in iframes, there are no guarantees that\n// the callback will actually be called, which could stall the promise returned\n// from displayContent.\n//\n// See: https://www.vector-logic.com/blog/posts/on-request-animation-frame-and-embedded-iframes\nconst safeCallbackQueue = (callback)=>{\n    if (window.requestAnimationFrame && window.self === window.top) {\n        window.requestAnimationFrame(callback);\n    } else {\n        window.setTimeout(callback);\n    }\n};\nfunction displayContent() {\n    return new Promise((resolve)=>{\n        safeCallbackQueue(function() {\n            for(var x = document.querySelectorAll(\"[data-next-hide-fouc]\"), i = x.length; i--;){\n                x[i].parentNode.removeChild(x[i]);\n            }\n            resolve();\n        });\n    });\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fouc.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZm91Yy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxzQkFBc0IsR0FBR0U7QUFDekIsNkVBQTZFO0FBQzdFLDhFQUE4RTtBQUM5RSw4RUFBOEU7QUFDOUUsK0VBQStFO0FBQy9FLHVCQUF1QjtBQUN2QixFQUFFO0FBQ0YsK0ZBQStGO0FBQy9GLE1BQU1DLG9CQUFvQixDQUFDQyxXQUFXO0lBQ2xDLElBQUlDLE9BQU9DLHFCQUFxQixJQUFJRCxPQUFPRSxJQUFJLEtBQUtGLE9BQU9HLEdBQUcsRUFBRTtRQUM1REgsT0FBT0MscUJBQXFCLENBQUNGO0lBQ2pDLE9BQU87UUFDSEMsT0FBT0ksVUFBVSxDQUFDTDtJQUN0QixDQUFDO0FBQ0w7QUFDQSxTQUFTRixpQkFBaUI7SUFDdEIsT0FBTyxJQUFJUSxRQUFRLENBQUNDLFVBQVU7UUFDMUJSLGtCQUFrQixXQUFXO1lBQ3pCLElBQUksSUFBSVMsSUFBSUMsU0FBU0MsZ0JBQWdCLENBQUMsMEJBQTBCQyxJQUFJSCxFQUFFSSxNQUFNLEVBQUVELEtBQUs7Z0JBQy9FSCxDQUFDLENBQUNHLEVBQUUsQ0FBQ0UsVUFBVSxDQUFDQyxXQUFXLENBQUNOLENBQUMsQ0FBQ0csRUFBRTtZQUNwQztZQUNBSjtRQUNKO0lBQ0o7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPWCxRQUFRbUIsT0FBTyxLQUFLLGNBQWUsT0FBT25CLFFBQVFtQixPQUFPLEtBQUssWUFBWW5CLFFBQVFtQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9uQixRQUFRbUIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3RCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUW1CLE9BQU8sRUFBRSxjQUFjO1FBQUVsQixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT3VCLE1BQU0sQ0FBQ3JCLFFBQVFtQixPQUFPLEVBQUVuQjtJQUMvQnNCLE9BQU90QixPQUFPLEdBQUdBLFFBQVFtQixPQUFPO0FBQ2xDLENBQUMsQ0FFRCxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L2ZvdWMuanM/MDA4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kaXNwbGF5Q29udGVudCA9IGRpc3BsYXlDb250ZW50O1xyXG4vLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gaXMgdXNlZCB0byBzYWZlbHkgc2VsZWN0IHRoZSBiZXN0IGF2YWlsYWJsZSBmdW5jdGlvblxyXG4vLyB0byBzY2hlZHVsZSByZW1vdmFsIG9mIHRoZSBuby1GT1VDIHN0eWxlcyB3b3JrYXJvdW5kLiByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuLy8gaXMgdGhlIGlkZWFsIGNob2ljZSwgYnV0IHdoZW4gdXNlZCBpbiBpZnJhbWVzLCB0aGVyZSBhcmUgbm8gZ3VhcmFudGVlcyB0aGF0XHJcbi8vIHRoZSBjYWxsYmFjayB3aWxsIGFjdHVhbGx5IGJlIGNhbGxlZCwgd2hpY2ggY291bGQgc3RhbGwgdGhlIHByb21pc2UgcmV0dXJuZWRcclxuLy8gZnJvbSBkaXNwbGF5Q29udGVudC5cclxuLy9cclxuLy8gU2VlOiBodHRwczovL3d3dy52ZWN0b3ItbG9naWMuY29tL2Jsb2cvcG9zdHMvb24tcmVxdWVzdC1hbmltYXRpb24tZnJhbWUtYW5kLWVtYmVkZGVkLWlmcmFtZXNcclxuY29uc3Qgc2FmZUNhbGxiYWNrUXVldWUgPSAoY2FsbGJhY2spPT57XHJcbiAgICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiB3aW5kb3cuc2VsZiA9PT0gd2luZG93LnRvcCkge1xyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjayk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGRpc3BsYXlDb250ZW50KCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKT0+e1xyXG4gICAgICAgIHNhZmVDYWxsYmFja1F1ZXVlKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBmb3IodmFyIHggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1uZXh0LWhpZGUtZm91Y10nKSwgaSA9IHgubGVuZ3RoOyBpLS07KXtcclxuICAgICAgICAgICAgICAgIHhbaV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh4W2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcclxuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcclxufVxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm91Yy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkaXNwbGF5Q29udGVudCIsInNhZmVDYWxsYmFja1F1ZXVlIiwiY2FsbGJhY2siLCJ3aW5kb3ciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzZWxmIiwidG9wIiwic2V0VGltZW91dCIsIlByb21pc2UiLCJyZXNvbHZlIiwieCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImkiLCJsZW5ndGgiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/fouc.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/dev/on-demand-entries-client.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/on-demand-entries-client.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _router = _interop_require_default(__webpack_require__(/*! next/router */ \"./node_modules/next/router.js\"));\nvar _websocket = __webpack_require__(/*! ./error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nvar _default = _async_to_generator(function*(page) {\n    if (page) {\n        // in AMP the router isn't initialized on the client and\n        // client-transitions don't occur so ping initial page\n        setInterval(()=>{\n            (0, _websocket).sendMessage(JSON.stringify({\n                event: \"ping\",\n                page\n            }));\n        }, 2500);\n    } else {\n        _router.default.ready(()=>{\n            setInterval(()=>{\n                // when notFound: true is returned we should use the notFoundPage\n                // as the Router.pathname will point to the 404 page but we want\n                // to ping the source page that returned notFound: true instead\n                const notFoundSrcPage = self.__NEXT_DATA__.notFoundSrcPage;\n                const pathname = (_router.default.pathname === \"/404\" || _router.default.pathname === \"/_error\") && notFoundSrcPage ? notFoundSrcPage : _router.default.pathname;\n                (0, _websocket).sendMessage(JSON.stringify({\n                    event: \"ping\",\n                    page: pathname\n                }));\n            }, 2500);\n        });\n    }\n    (0, _websocket).addMessageListener((event)=>{\n        if (event.data.indexOf(\"{\") === -1) return;\n        try {\n            const payload = JSON.parse(event.data);\n            // don't attempt fetching the page if we're already showing\n            // the dev overlay as this can cause the error to be triggered\n            // repeatedly\n            if (payload.event === \"pong\" && payload.invalid && !self.__NEXT_DATA__.err) {\n                // Payload can be invalid even if the page does exist.\n                // So, we check if it can be created.\n                fetch(location.href, {\n                    credentials: \"same-origin\"\n                }).then((pageRes)=>{\n                    if (pageRes.status === 200) {\n                        // Page exists now, reload\n                        location.reload();\n                    } else {\n                        // Page doesn't exist\n                        if (self.__NEXT_DATA__.page === _router.default.pathname && _router.default.pathname !== \"/_error\") {\n                            // We are still on the page,\n                            // reload to show 404 error page\n                            location.reload();\n                        }\n                    }\n                });\n            }\n        } catch (err) {\n            console.error(\"on-demand-entries failed to parse response\", err);\n        }\n    });\n});\nexports[\"default\"] = _default;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=on-demand-entries-client.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvb24tZGVtYW5kLWVudHJpZXMtY2xpZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUcsS0FBSztBQUN2QixJQUFJRyxzQkFBc0JDLHlJQUEwRDtBQUNwRixJQUFJQywyQkFBMkJELG1KQUErRDtBQUM5RixJQUFJRSxVQUFVRCx5QkFBeUJELG1CQUFPQSxDQUFDLGtEQUFhO0FBQzVELElBQUlHLGFBQWFILG1CQUFPQSxDQUFDLGlHQUEyQjtBQUNwRCxJQUFJSSxXQUFXTCxvQkFBb0IsVUFBVU0sSUFBSSxFQUFFO0lBQy9DLElBQUlBLE1BQU07UUFDTix3REFBd0Q7UUFDeEQsc0RBQXNEO1FBQ3REQyxZQUFZLElBQUk7WUFDWCxJQUFHSCxVQUFVLEVBQUVJLFdBQVcsQ0FBQ0MsS0FBS0MsU0FBUyxDQUFDO2dCQUN2Q0MsT0FBTztnQkFDUEw7WUFDSjtRQUNKLEdBQUc7SUFDUCxPQUFPO1FBQ0hILFFBQVFKLE9BQU8sQ0FBQ2EsS0FBSyxDQUFDLElBQUk7WUFDdEJMLFlBQVksSUFBSTtnQkFDWixpRUFBaUU7Z0JBQ2pFLGdFQUFnRTtnQkFDaEUsK0RBQStEO2dCQUMvRCxNQUFNTSxrQkFBa0JDLEtBQUtDLGFBQWEsQ0FBQ0YsZUFBZTtnQkFDMUQsTUFBTUcsV0FBVyxDQUFDYixRQUFRSixPQUFPLENBQUNpQixRQUFRLEtBQUssVUFBVWIsUUFBUUosT0FBTyxDQUFDaUIsUUFBUSxLQUFLLFNBQVEsS0FBTUgsa0JBQWtCQSxrQkFBa0JWLFFBQVFKLE9BQU8sQ0FBQ2lCLFFBQVE7Z0JBQy9KLElBQUdaLFVBQVUsRUFBRUksV0FBVyxDQUFDQyxLQUFLQyxTQUFTLENBQUM7b0JBQ3ZDQyxPQUFPO29CQUNQTCxNQUFNVTtnQkFDVjtZQUNKLEdBQUc7UUFDUDtJQUNKLENBQUM7SUFDQSxJQUFHWixVQUFVLEVBQUVhLGtCQUFrQixDQUFDLENBQUNOLFFBQVE7UUFDeEMsSUFBSUEsTUFBTU8sSUFBSSxDQUFDQyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUc7UUFDcEMsSUFBSTtZQUNBLE1BQU1DLFVBQVVYLEtBQUtZLEtBQUssQ0FBQ1YsTUFBTU8sSUFBSTtZQUNyQywyREFBMkQ7WUFDM0QsOERBQThEO1lBQzlELGFBQWE7WUFDYixJQUFJRSxRQUFRVCxLQUFLLEtBQUssVUFBVVMsUUFBUUUsT0FBTyxJQUFJLENBQUNSLEtBQUtDLGFBQWEsQ0FBQ1EsR0FBRyxFQUFFO2dCQUN4RSxzREFBc0Q7Z0JBQ3RELHFDQUFxQztnQkFDckNDLE1BQU1DLFNBQVNDLElBQUksRUFBRTtvQkFDakJDLGFBQWE7Z0JBQ2pCLEdBQUdDLElBQUksQ0FBQyxDQUFDQyxVQUFVO29CQUNmLElBQUlBLFFBQVFDLE1BQU0sS0FBSyxLQUFLO3dCQUN4QiwwQkFBMEI7d0JBQzFCTCxTQUFTTSxNQUFNO29CQUNuQixPQUFPO3dCQUNILHFCQUFxQjt3QkFDckIsSUFBSWpCLEtBQUtDLGFBQWEsQ0FBQ1QsSUFBSSxLQUFLSCxRQUFRSixPQUFPLENBQUNpQixRQUFRLElBQUliLFFBQVFKLE9BQU8sQ0FBQ2lCLFFBQVEsS0FBSyxXQUFXOzRCQUNoRyw0QkFBNEI7NEJBQzVCLGdDQUFnQzs0QkFDaENTLFNBQVNNLE1BQU07d0JBQ25CLENBQUM7b0JBQ0wsQ0FBQztnQkFDTDtZQUNKLENBQUM7UUFDTCxFQUFFLE9BQU9SLEtBQUs7WUFDVlMsUUFBUUMsS0FBSyxDQUFDLDhDQUE4Q1Y7UUFDaEU7SUFDSjtBQUNKO0FBQ0ExQixrQkFBZSxHQUFHUTtBQUVsQixJQUFJLENBQUMsT0FBT1IsUUFBUUUsT0FBTyxLQUFLLGNBQWUsT0FBT0YsUUFBUUUsT0FBTyxLQUFLLFlBQVlGLFFBQVFFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0YsUUFBUUUsT0FBTyxDQUFDbUMsVUFBVSxLQUFLLGFBQWE7SUFDckt2QyxPQUFPQyxjQUFjLENBQUNDLFFBQVFFLE9BQU8sRUFBRSxjQUFjO1FBQUVELE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPd0MsTUFBTSxDQUFDdEMsUUFBUUUsT0FBTyxFQUFFRjtJQUMvQnVDLE9BQU92QyxPQUFPLEdBQUdBLFFBQVFFLE9BQU87QUFDbEMsQ0FBQyxDQUVELG9EQUFvRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvb24tZGVtYW5kLWVudHJpZXMtY2xpZW50LmpzPzg0NWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gICAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcclxudmFyIF9hc3luY190b19nZW5lcmF0b3IgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fYXN5bmNfdG9fZ2VuZXJhdG9yLmpzXCIpLmRlZmF1bHQ7XHJcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcclxudmFyIF9yb3V0ZXIgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIm5leHQvcm91dGVyXCIpKTtcclxudmFyIF93ZWJzb2NrZXQgPSByZXF1aXJlKFwiLi9lcnJvci1vdmVybGF5L3dlYnNvY2tldFwiKTtcclxudmFyIF9kZWZhdWx0ID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbioocGFnZSkge1xyXG4gICAgaWYgKHBhZ2UpIHtcclxuICAgICAgICAvLyBpbiBBTVAgdGhlIHJvdXRlciBpc24ndCBpbml0aWFsaXplZCBvbiB0aGUgY2xpZW50IGFuZFxyXG4gICAgICAgIC8vIGNsaWVudC10cmFuc2l0aW9ucyBkb24ndCBvY2N1ciBzbyBwaW5nIGluaXRpYWwgcGFnZVxyXG4gICAgICAgIHNldEludGVydmFsKCgpPT57XHJcbiAgICAgICAgICAgICgwLCBfd2Vic29ja2V0KS5zZW5kTWVzc2FnZShKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgICAgICBldmVudDogJ3BpbmcnLFxyXG4gICAgICAgICAgICAgICAgcGFnZVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSwgMjUwMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIF9yb3V0ZXIuZGVmYXVsdC5yZWFkeSgoKT0+e1xyXG4gICAgICAgICAgICBzZXRJbnRlcnZhbCgoKT0+e1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBub3RGb3VuZDogdHJ1ZSBpcyByZXR1cm5lZCB3ZSBzaG91bGQgdXNlIHRoZSBub3RGb3VuZFBhZ2VcclxuICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBSb3V0ZXIucGF0aG5hbWUgd2lsbCBwb2ludCB0byB0aGUgNDA0IHBhZ2UgYnV0IHdlIHdhbnRcclxuICAgICAgICAgICAgICAgIC8vIHRvIHBpbmcgdGhlIHNvdXJjZSBwYWdlIHRoYXQgcmV0dXJuZWQgbm90Rm91bmQ6IHRydWUgaW5zdGVhZFxyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm90Rm91bmRTcmNQYWdlID0gc2VsZi5fX05FWFRfREFUQV9fLm5vdEZvdW5kU3JjUGFnZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKF9yb3V0ZXIuZGVmYXVsdC5wYXRobmFtZSA9PT0gJy80MDQnIHx8IF9yb3V0ZXIuZGVmYXVsdC5wYXRobmFtZSA9PT0gJy9fZXJyb3InKSAmJiBub3RGb3VuZFNyY1BhZ2UgPyBub3RGb3VuZFNyY1BhZ2UgOiBfcm91dGVyLmRlZmF1bHQucGF0aG5hbWU7XHJcbiAgICAgICAgICAgICAgICAoMCwgX3dlYnNvY2tldCkuc2VuZE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiAncGluZycsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZTogcGF0aG5hbWVcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfSwgMjUwMCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAoMCwgX3dlYnNvY2tldCkuYWRkTWVzc2FnZUxpc3RlbmVyKChldmVudCk9PntcclxuICAgICAgICBpZiAoZXZlbnQuZGF0YS5pbmRleE9mKCd7JykgPT09IC0xKSByZXR1cm47XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgICAgIC8vIGRvbid0IGF0dGVtcHQgZmV0Y2hpbmcgdGhlIHBhZ2UgaWYgd2UncmUgYWxyZWFkeSBzaG93aW5nXHJcbiAgICAgICAgICAgIC8vIHRoZSBkZXYgb3ZlcmxheSBhcyB0aGlzIGNhbiBjYXVzZSB0aGUgZXJyb3IgdG8gYmUgdHJpZ2dlcmVkXHJcbiAgICAgICAgICAgIC8vIHJlcGVhdGVkbHlcclxuICAgICAgICAgICAgaWYgKHBheWxvYWQuZXZlbnQgPT09ICdwb25nJyAmJiBwYXlsb2FkLmludmFsaWQgJiYgIXNlbGYuX19ORVhUX0RBVEFfXy5lcnIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFBheWxvYWQgY2FuIGJlIGludmFsaWQgZXZlbiBpZiB0aGUgcGFnZSBkb2VzIGV4aXN0LlxyXG4gICAgICAgICAgICAgICAgLy8gU28sIHdlIGNoZWNrIGlmIGl0IGNhbiBiZSBjcmVhdGVkLlxyXG4gICAgICAgICAgICAgICAgZmV0Y2gobG9jYXRpb24uaHJlZiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nXHJcbiAgICAgICAgICAgICAgICB9KS50aGVuKChwYWdlUmVzKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWdlUmVzLnN0YXR1cyA9PT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhZ2UgZXhpc3RzIG5vdywgcmVsb2FkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhZ2UgZG9lc24ndCBleGlzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fX05FWFRfREFUQV9fLnBhZ2UgPT09IF9yb3V0ZXIuZGVmYXVsdC5wYXRobmFtZSAmJiBfcm91dGVyLmRlZmF1bHQucGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIHN0aWxsIG9uIHRoZSBwYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVsb2FkIHRvIHNob3cgNDA0IGVycm9yIHBhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignb24tZGVtYW5kLWVudHJpZXMgZmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlJywgZXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xyXG5cclxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcclxuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcclxufVxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b24tZGVtYW5kLWVudHJpZXMtY2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJfYXN5bmNfdG9fZ2VuZXJhdG9yIiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsIl9yb3V0ZXIiLCJfd2Vic29ja2V0IiwiX2RlZmF1bHQiLCJwYWdlIiwic2V0SW50ZXJ2YWwiLCJzZW5kTWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJldmVudCIsInJlYWR5Iiwibm90Rm91bmRTcmNQYWdlIiwic2VsZiIsIl9fTkVYVF9EQVRBX18iLCJwYXRobmFtZSIsImFkZE1lc3NhZ2VMaXN0ZW5lciIsImRhdGEiLCJpbmRleE9mIiwicGF5bG9hZCIsInBhcnNlIiwiaW52YWxpZCIsImVyciIsImZldGNoIiwibG9jYXRpb24iLCJocmVmIiwiY3JlZGVudGlhbHMiLCJ0aGVuIiwicGFnZVJlcyIsInN0YXR1cyIsInJlbG9hZCIsImNvbnNvbGUiLCJlcnJvciIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/on-demand-entries-client.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/has-base-path.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/client/has-base-path.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hasBasePath = hasBasePath;\nvar _pathHasPrefix = __webpack_require__(/*! ../shared/lib/router/utils/path-has-prefix */ \"./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\");\nconst basePath =  false || \"\";\nfunction hasBasePath(path) {\n    return (0, _pathHasPrefix).pathHasPrefix(path, basePath);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=has-base-path.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9oYXMtYmFzZS1wYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELG1CQUFtQixHQUFHRTtBQUN0QixJQUFJQyxpQkFBaUJDLG1CQUFPQSxDQUFDLHVIQUE0QztBQUN6RSxNQUFNQyxXQUFXQyxNQUFrQyxJQUFJO0FBQ3ZELFNBQVNKLFlBQVlPLElBQUksRUFBRTtJQUN2QixPQUFPLENBQUMsR0FBR04sY0FBYyxFQUFFTyxhQUFhLENBQUNELE1BQU1KO0FBQ25EO0FBRUEsSUFBSSxDQUFDLE9BQU9MLFFBQVFXLE9BQU8sS0FBSyxjQUFlLE9BQU9YLFFBQVFXLE9BQU8sS0FBSyxZQUFZWCxRQUFRVyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9YLFFBQVFXLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktkLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUVcsT0FBTyxFQUFFLGNBQWM7UUFBRVYsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9lLE1BQU0sQ0FBQ2IsUUFBUVcsT0FBTyxFQUFFWDtJQUMvQmMsT0FBT2QsT0FBTyxHQUFHQSxRQUFRVyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaGFzLWJhc2UtcGF0aC5qcz81YTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICAgIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmhhc0Jhc2VQYXRoID0gaGFzQmFzZVBhdGg7XHJcbnZhciBfcGF0aEhhc1ByZWZpeCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXRoLWhhcy1wcmVmaXhcIik7XHJcbmNvbnN0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCAnJztcclxuZnVuY3Rpb24gaGFzQmFzZVBhdGgocGF0aCkge1xyXG4gICAgcmV0dXJuICgwLCBfcGF0aEhhc1ByZWZpeCkucGF0aEhhc1ByZWZpeChwYXRoLCBiYXNlUGF0aCk7XHJcbn1cclxuXHJcbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XHJcbn1cclxuXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1iYXNlLXBhdGguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaGFzQmFzZVBhdGgiLCJfcGF0aEhhc1ByZWZpeCIsInJlcXVpcmUiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsInBhdGhIYXNQcmVmaXgiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/has-base-path.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/head-manager.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/head-manager.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = initHeadManager;\nexports.isEqualNode = isEqualNode;\nexports.DOMAttributeNames = void 0;\nfunction initHeadManager() {\n    return {\n        mountedInstances: new Set(),\n        updateHead: (head)=>{\n            const tags = {};\n            head.forEach((h)=>{\n                if (// it won't be inlined. In this case revert to the original behavior\n                h.type === \"link\" && h.props[\"data-optimized-fonts\"]) {\n                    if (document.querySelector('style[data-href=\"'.concat(h.props[\"data-href\"], '\"]'))) {\n                        return;\n                    } else {\n                        h.props.href = h.props[\"data-href\"];\n                        h.props[\"data-href\"] = undefined;\n                    }\n                }\n                const components = tags[h.type] || [];\n                components.push(h);\n                tags[h.type] = components;\n            });\n            const titleComponent = tags.title ? tags.title[0] : null;\n            let title = \"\";\n            if (titleComponent) {\n                const { children  } = titleComponent.props;\n                title = typeof children === \"string\" ? children : Array.isArray(children) ? children.join(\"\") : \"\";\n            }\n            if (title !== document.title) document.title = title;\n            [\n                \"meta\",\n                \"base\",\n                \"link\",\n                \"style\",\n                \"script\"\n            ].forEach((type)=>{\n                updateElements(type, tags[type] || []);\n            });\n        }\n    };\n}\nconst DOMAttributeNames = {\n    acceptCharset: \"accept-charset\",\n    className: \"class\",\n    htmlFor: \"for\",\n    httpEquiv: \"http-equiv\",\n    noModule: \"noModule\"\n};\nexports.DOMAttributeNames = DOMAttributeNames;\nfunction reactElementToDOM(param) {\n    let { type , props  } = param;\n    const el = document.createElement(type);\n    for(const p in props){\n        if (!props.hasOwnProperty(p)) continue;\n        if (p === \"children\" || p === \"dangerouslySetInnerHTML\") continue;\n        // we don't render undefined props to the DOM\n        if (props[p] === undefined) continue;\n        const attr = DOMAttributeNames[p] || p.toLowerCase();\n        if (type === \"script\" && (attr === \"async\" || attr === \"defer\" || attr === \"noModule\")) {\n            el[attr] = !!props[p];\n        } else {\n            el.setAttribute(attr, props[p]);\n        }\n    }\n    const { children , dangerouslySetInnerHTML  } = props;\n    if (dangerouslySetInnerHTML) {\n        el.innerHTML = dangerouslySetInnerHTML.__html || \"\";\n    } else if (children) {\n        el.textContent = typeof children === \"string\" ? children : Array.isArray(children) ? children.join(\"\") : \"\";\n    }\n    return el;\n}\nfunction isEqualNode(oldTag, newTag) {\n    if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {\n        const nonce = newTag.getAttribute(\"nonce\");\n        // Only strip the nonce if `oldTag` has had it stripped. An element's nonce attribute will not\n        // be stripped if there is no content security policy response header that includes a nonce.\n        if (nonce && !oldTag.getAttribute(\"nonce\")) {\n            const cloneTag = newTag.cloneNode(true);\n            cloneTag.setAttribute(\"nonce\", \"\");\n            cloneTag.nonce = nonce;\n            return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag);\n        }\n    }\n    return oldTag.isEqualNode(newTag);\n}\nfunction updateElements(type, components) {\n    const headEl = document.getElementsByTagName(\"head\")[0];\n    const headCountEl = headEl.querySelector(\"meta[name=next-head-count]\");\n    if (true) {\n        if (!headCountEl) {\n            console.error(\"Warning: next-head-count is missing. https://nextjs.org/docs/messages/next-head-count-missing\");\n            return;\n        }\n    }\n    const headCount = Number(headCountEl.content);\n    const oldTags = [];\n    for(let i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = (j == null ? void 0 : j.previousElementSibling) || null){\n        var ref;\n        if ((j == null ? void 0 : (ref = j.tagName) == null ? void 0 : ref.toLowerCase()) === type) {\n            oldTags.push(j);\n        }\n    }\n    const newTags = components.map(reactElementToDOM).filter((newTag)=>{\n        for(let k = 0, len = oldTags.length; k < len; k++){\n            const oldTag = oldTags[k];\n            if (isEqualNode(oldTag, newTag)) {\n                oldTags.splice(k, 1);\n                return false;\n            }\n        }\n        return true;\n    });\n    oldTags.forEach((t)=>{\n        var ref;\n        return (ref = t.parentNode) == null ? void 0 : ref.removeChild(t);\n    });\n    newTags.forEach((t)=>headEl.insertBefore(t, headCountEl));\n    headCountEl.content = (headCount - oldTags.length + newTags.length).toString();\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head-manager.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9oZWFkLW1hbmFnZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEJILG1CQUFtQixHQUFHSTtBQUN0QkoseUJBQXlCLEdBQUcsS0FBSztBQUNqQyxTQUFTRyxrQkFBa0I7SUFDdkIsT0FBTztRQUNIRyxrQkFBa0IsSUFBSUM7UUFDdEJDLFlBQVksQ0FBQ0MsT0FBTztZQUNoQixNQUFNQyxPQUFPLENBQUM7WUFDZEQsS0FBS0UsT0FBTyxDQUFDLENBQUNDLElBQUk7Z0JBQ2QsSUFDQSxvRUFBb0U7Z0JBQ3BFQSxFQUFFQyxJQUFJLEtBQUssVUFBVUQsRUFBRUUsS0FBSyxDQUFDLHVCQUF1QixFQUFFO29CQUNsRCxJQUFJQyxTQUFTQyxhQUFhLENBQUMsb0JBQXlDLE9BQXJCSixFQUFFRSxLQUFLLENBQUMsWUFBWSxFQUFDLFFBQU07d0JBQ3RFO29CQUNKLE9BQU87d0JBQ0hGLEVBQUVFLEtBQUssQ0FBQ0csSUFBSSxHQUFHTCxFQUFFRSxLQUFLLENBQUMsWUFBWTt3QkFDbkNGLEVBQUVFLEtBQUssQ0FBQyxZQUFZLEdBQUdJO29CQUMzQixDQUFDO2dCQUNMLENBQUM7Z0JBQ0QsTUFBTUMsYUFBYVQsSUFBSSxDQUFDRSxFQUFFQyxJQUFJLENBQUMsSUFBSSxFQUFFO2dCQUNyQ00sV0FBV0MsSUFBSSxDQUFDUjtnQkFDaEJGLElBQUksQ0FBQ0UsRUFBRUMsSUFBSSxDQUFDLEdBQUdNO1lBQ25CO1lBQ0EsTUFBTUUsaUJBQWlCWCxLQUFLWSxLQUFLLEdBQUdaLEtBQUtZLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBSTtZQUN4RCxJQUFJQSxRQUFRO1lBQ1osSUFBSUQsZ0JBQWdCO2dCQUNoQixNQUFNLEVBQUVFLFNBQVEsRUFBRyxHQUFHRixlQUFlUCxLQUFLO2dCQUMxQ1EsUUFBUSxPQUFPQyxh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LENBQUMsT0FBTzlFLFFBQVFFLE9BQU8sS0FBSyxjQUFlLE9BQU9GLFFBQVFFLE9BQU8sS0FBSyxZQUFZRixRQUFRRSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9GLFFBQVFFLE9BQU8sQ0FBQzZFLFVBQVUsS0FBSyxhQUFhO0lBQ3JLakYsT0FBT0MsY0FBYyxDQUFDQyxRQUFRRSxPQUFPLEVBQUUsY0FBYztRQUFFRCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2tGLE1BQU0sQ0FBQ2hGLFFBQVFFLE9BQU8sRUFBRUY7SUFDL0JpRixPQUFPakYsT0FBTyxHQUFHQSxRQUFRRSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaGVhZC1tYW5hZ2VyLmpzP2NhNGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gICAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGluaXRIZWFkTWFuYWdlcjtcclxuZXhwb3J0cy5pc0VxdWFsTm9kZSA9IGlzRXF1YWxOb2RlO1xyXG5leHBvcnRzLkRPTUF0dHJpYnV0ZU5hbWVzID0gdm9pZCAwO1xyXG5mdW5jdGlvbiBpbml0SGVhZE1hbmFnZXIoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1vdW50ZWRJbnN0YW5jZXM6IG5ldyBTZXQoKSxcclxuICAgICAgICB1cGRhdGVIZWFkOiAoaGVhZCk9PntcclxuICAgICAgICAgICAgY29uc3QgdGFncyA9IHt9O1xyXG4gICAgICAgICAgICBoZWFkLmZvckVhY2goKGgpPT57XHJcbiAgICAgICAgICAgICAgICBpZiAoLy8gSWYgdGhlIGZvbnQgdGFnIGlzIGxvYWRlZCBvbmx5IG9uIGNsaWVudCBuYXZpZ2F0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyBpdCB3b24ndCBiZSBpbmxpbmVkLiBJbiB0aGlzIGNhc2UgcmV2ZXJ0IHRvIHRoZSBvcmlnaW5hbCBiZWhhdmlvclxyXG4gICAgICAgICAgICAgICAgaC50eXBlID09PSAnbGluaycgJiYgaC5wcm9wc1snZGF0YS1vcHRpbWl6ZWQtZm9udHMnXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzdHlsZVtkYXRhLWhyZWY9XCIke2gucHJvcHNbJ2RhdGEtaHJlZiddfVwiXWApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoLnByb3BzLmhyZWYgPSBoLnByb3BzWydkYXRhLWhyZWYnXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaC5wcm9wc1snZGF0YS1ocmVmJ10gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IHRhZ3NbaC50eXBlXSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChoKTtcclxuICAgICAgICAgICAgICAgIHRhZ3NbaC50eXBlXSA9IGNvbXBvbmVudHM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCB0aXRsZUNvbXBvbmVudCA9IHRhZ3MudGl0bGUgPyB0YWdzLnRpdGxlWzBdIDogbnVsbDtcclxuICAgICAgICAgICAgbGV0IHRpdGxlID0gJyc7XHJcbiAgICAgICAgICAgIGlmICh0aXRsZUNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBjaGlsZHJlbiAgfSA9IHRpdGxlQ29tcG9uZW50LnByb3BzO1xyXG4gICAgICAgICAgICAgICAgdGl0bGUgPSB0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnID8gY2hpbGRyZW4gOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLmpvaW4oJycpIDogJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRpdGxlICE9PSBkb2N1bWVudC50aXRsZSkgZG9jdW1lbnQudGl0bGUgPSB0aXRsZTtcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgJ21ldGEnLFxyXG4gICAgICAgICAgICAgICAgJ2Jhc2UnLFxyXG4gICAgICAgICAgICAgICAgJ2xpbmsnLFxyXG4gICAgICAgICAgICAgICAgJ3N0eWxlJyxcclxuICAgICAgICAgICAgICAgICdzY3JpcHQnXHJcbiAgICAgICAgICAgIF0uZm9yRWFjaCgodHlwZSk9PntcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnRzKHR5cGUsIHRhZ3NbdHlwZV0gfHwgW10pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IERPTUF0dHJpYnV0ZU5hbWVzID0ge1xyXG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcclxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcclxuICAgIGh0bWxGb3I6ICdmb3InLFxyXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdicsXHJcbiAgICBub01vZHVsZTogJ25vTW9kdWxlJ1xyXG59O1xyXG5leHBvcnRzLkRPTUF0dHJpYnV0ZU5hbWVzID0gRE9NQXR0cmlidXRlTmFtZXM7XHJcbmZ1bmN0aW9uIHJlYWN0RWxlbWVudFRvRE9NKHsgdHlwZSAsIHByb3BzICB9KSB7XHJcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XHJcbiAgICBmb3IoY29uc3QgcCBpbiBwcm9wcyl7XHJcbiAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XHJcbiAgICAgICAgaWYgKHAgPT09ICdjaGlsZHJlbicgfHwgcCA9PT0gJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJykgY29udGludWU7XHJcbiAgICAgICAgLy8gd2UgZG9uJ3QgcmVuZGVyIHVuZGVmaW5lZCBwcm9wcyB0byB0aGUgRE9NXHJcbiAgICAgICAgaWYgKHByb3BzW3BdID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xyXG4gICAgICAgIGNvbnN0IGF0dHIgPSBET01BdHRyaWJ1dGVOYW1lc1twXSB8fCBwLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzY3JpcHQnICYmIChhdHRyID09PSAnYXN5bmMnIHx8IGF0dHIgPT09ICdkZWZlcicgfHwgYXR0ciA9PT0gJ25vTW9kdWxlJykpIHtcclxuICAgICAgICAgICAgZWxbYXR0cl0gPSAhIXByb3BzW3BdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCBwcm9wc1twXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgeyBjaGlsZHJlbiAsIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICB9ID0gcHJvcHM7XHJcbiAgICBpZiAoZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpIHtcclxuICAgICAgICBlbC5pbm5lckhUTUwgPSBkYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwgfHwgJyc7XHJcbiAgICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnID8gY2hpbGRyZW4gOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLmpvaW4oJycpIDogJyc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWw7XHJcbn1cclxuZnVuY3Rpb24gaXNFcXVhbE5vZGUob2xkVGFnLCBuZXdUYWcpIHtcclxuICAgIGlmIChvbGRUYWcgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBuZXdUYWcgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIGNvbnN0IG5vbmNlID0gbmV3VGFnLmdldEF0dHJpYnV0ZSgnbm9uY2UnKTtcclxuICAgICAgICAvLyBPbmx5IHN0cmlwIHRoZSBub25jZSBpZiBgb2xkVGFnYCBoYXMgaGFkIGl0IHN0cmlwcGVkLiBBbiBlbGVtZW50J3Mgbm9uY2UgYXR0cmlidXRlIHdpbGwgbm90XHJcbiAgICAgICAgLy8gYmUgc3RyaXBwZWQgaWYgdGhlcmUgaXMgbm8gY29udGVudCBzZWN1cml0eSBwb2xpY3kgcmVzcG9uc2UgaGVhZGVyIHRoYXQgaW5jbHVkZXMgYSBub25jZS5cclxuICAgICAgICBpZiAobm9uY2UgJiYgIW9sZFRhZy5nZXRBdHRyaWJ1dGUoJ25vbmNlJykpIHtcclxuICAgICAgICAgICAgY29uc3QgY2xvbmVUYWcgPSBuZXdUYWcuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgICAgICAgICBjbG9uZVRhZy5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgJycpO1xyXG4gICAgICAgICAgICBjbG9uZVRhZy5ub25jZSA9IG5vbmNlO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9uY2UgPT09IG9sZFRhZy5ub25jZSAmJiBvbGRUYWcuaXNFcXVhbE5vZGUoY2xvbmVUYWcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvbGRUYWcuaXNFcXVhbE5vZGUobmV3VGFnKTtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVFbGVtZW50cyh0eXBlLCBjb21wb25lbnRzKSB7XHJcbiAgICBjb25zdCBoZWFkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xyXG4gICAgY29uc3QgaGVhZENvdW50RWwgPSBoZWFkRWwucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPW5leHQtaGVhZC1jb3VudF0nKTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgaWYgKCFoZWFkQ291bnRFbCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdXYXJuaW5nOiBuZXh0LWhlYWQtY291bnQgaXMgbWlzc2luZy4gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1oZWFkLWNvdW50LW1pc3NpbmcnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGhlYWRDb3VudCA9IE51bWJlcihoZWFkQ291bnRFbC5jb250ZW50KTtcclxuICAgIGNvbnN0IG9sZFRhZ3MgPSBbXTtcclxuICAgIGZvcihsZXQgaSA9IDAsIGogPSBoZWFkQ291bnRFbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nOyBpIDwgaGVhZENvdW50OyBpKyssIGogPSAoaiA9PSBudWxsID8gdm9pZCAwIDogai5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB8fCBudWxsKXtcclxuICAgICAgICB2YXIgcmVmO1xyXG4gICAgICAgIGlmICgoaiA9PSBudWxsID8gdm9pZCAwIDogKHJlZiA9IGoudGFnTmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi50b0xvd2VyQ2FzZSgpKSA9PT0gdHlwZSkge1xyXG4gICAgICAgICAgICBvbGRUYWdzLnB1c2goaik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3VGFncyA9IGNvbXBvbmVudHMubWFwKHJlYWN0RWxlbWVudFRvRE9NKS5maWx0ZXIoKG5ld1RhZyk9PntcclxuICAgICAgICBmb3IobGV0IGsgPSAwLCBsZW4gPSBvbGRUYWdzLmxlbmd0aDsgayA8IGxlbjsgaysrKXtcclxuICAgICAgICAgICAgY29uc3Qgb2xkVGFnID0gb2xkVGFnc1trXTtcclxuICAgICAgICAgICAgaWYgKGlzRXF1YWxOb2RlKG9sZFRhZywgbmV3VGFnKSkge1xyXG4gICAgICAgICAgICAgICAgb2xkVGFncy5zcGxpY2UoaywgMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9KTtcclxuICAgIG9sZFRhZ3MuZm9yRWFjaCgodCk9PntcclxuICAgICAgICB2YXIgcmVmO1xyXG4gICAgICAgIHJldHVybiAocmVmID0gdC5wYXJlbnROb2RlKSA9PSBudWxsID8gdm9pZCAwIDogcmVmLnJlbW92ZUNoaWxkKHQpO1xyXG4gICAgfSk7XHJcbiAgICBuZXdUYWdzLmZvckVhY2goKHQpPT5oZWFkRWwuaW5zZXJ0QmVmb3JlKHQsIGhlYWRDb3VudEVsKSk7XHJcbiAgICBoZWFkQ291bnRFbC5jb250ZW50ID0gKGhlYWRDb3VudCAtIG9sZFRhZ3MubGVuZ3RoICsgbmV3VGFncy5sZW5ndGgpLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XHJcbn1cclxuXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlYWQtbWFuYWdlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiaW5pdEhlYWRNYW5hZ2VyIiwiaXNFcXVhbE5vZGUiLCJET01BdHRyaWJ1dGVOYW1lcyIsIm1vdW50ZWRJbnN0YW5jZXMiLCJTZXQiLCJ1cGRhdGVIZWFkIiwiaGVhZCIsInRhZ3MiLCJmb3JFYWNoIiwiaCIsInR5cGUiLCJwcm9wcyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImhyZWYiLCJ1bmRlZmluZWQiLCJjb21wb25lbnRzIiwicHVzaCIsInRpdGxlQ29tcG9uZW50IiwidGl0bGUiLCJjaGlsZHJlbiIsIkFycmF5IiwiaXNBcnJheSIsImpvaW4iLCJ1cGRhdGVFbGVtZW50cyIsImFjY2VwdENoYXJzZXQiLCJjbGFzc05hbWUiLCJodG1sRm9yIiwiaHR0cEVxdWl2Iiwibm9Nb2R1bGUiLCJyZWFjdEVsZW1lbnRUb0RPTSIsImVsIiwiY3JlYXRlRWxlbWVudCIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsImF0dHIiLCJ0b0xvd2VyQ2FzZSIsInNldEF0dHJpYnV0ZSIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiaW5uZXJIVE1MIiwiX19odG1sIiwidGV4dENvbnRlbnQiLCJvbGRUYWciLCJuZXdUYWciLCJIVE1MRWxlbWVudCIsIm5vbmNlIiwiZ2V0QXR0cmlidXRlIiwiY2xvbmVUYWciLCJjbG9uZU5vZGUiLCJoZWFkRWwiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImhlYWRDb3VudEVsIiwicHJvY2VzcyIsImNvbnNvbGUiLCJlcnJvciIsImhlYWRDb3VudCIsIk51bWJlciIsImNvbnRlbnQiLCJvbGRUYWdzIiwiaSIsImoiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwicmVmIiwidGFnTmFtZSIsIm5ld1RhZ3MiLCJtYXAiLCJmaWx0ZXIiLCJrIiwibGVuIiwibGVuZ3RoIiwic3BsaWNlIiwidCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImluc2VydEJlZm9yZSIsInRvU3RyaW5nIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/head-manager.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.normalizePathTrailingSlash = void 0;\nvar _removeTrailingSlash = __webpack_require__(/*! ../shared/lib/router/utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nvar _parsePath = __webpack_require__(/*! ../shared/lib/router/utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nconst normalizePathTrailingSlash = (path)=>{\n    if (!path.startsWith(\"/\")) {\n        return path;\n    }\n    const { pathname , query , hash  } = (0, _parsePath).parsePath(path);\n    if (false) {}\n    return \"\".concat((0, _removeTrailingSlash).removeTrailingSlash(pathname)).concat(query).concat(hash);\n};\nexports.normalizePathTrailingSlash = normalizePathTrailingSlash;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=normalize-trailing-slash.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2guanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0NBQWtDLEdBQUcsS0FBSztBQUMxQyxJQUFJRyx1QkFBdUJDLG1CQUFPQSxDQUFDLG1JQUFrRDtBQUNyRixJQUFJQyxhQUFhRCxtQkFBT0EsQ0FBQyw2R0FBdUM7QUFDaEUsTUFBTUYsNkJBQTZCLENBQUNJLE9BQU87SUFDdkMsSUFBSSxDQUFDQSxLQUFLQyxVQUFVLENBQUMsTUFBTTtRQUN2QixPQUFPRDtJQUNYLENBQUM7SUFDRCxNQUFNLEVBQUVFLFNBQVEsRUFBR0MsTUFBSyxFQUFHQyxLQUFJLEVBQUcsR0FBRyxDQUFDLEdBQUdMLFVBQVUsRUFBRU0sU0FBUyxDQUFDTDtJQUMvRCxJQUFJTSxLQUFpQyxFQUFFLEVBUXRDO0lBQ0QsT0FBTyxHQUE2REgsT0FBMUQsQ0FBQyxHQUFHTixvQkFBb0IsRUFBRWEsbUJBQW1CLENBQUNSLFdBQW9CRSxPQUFSRCxPQUFhLE9BQUxDO0FBQ2hGO0FBQ0FWLGtDQUFrQyxHQUFHRTtBQUVyQyxJQUFJLENBQUMsT0FBT0YsUUFBUWtCLE9BQU8sS0FBSyxjQUFlLE9BQU9sQixRQUFRa0IsT0FBTyxLQUFLLFlBQVlsQixRQUFRa0IsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPbEIsUUFBUWtCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktyQixPQUFPQyxjQUFjLENBQUNDLFFBQVFrQixPQUFPLEVBQUUsY0FBYztRQUFFakIsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9zQixNQUFNLENBQUNwQixRQUFRa0IsT0FBTyxFQUFFbEI7SUFDL0JxQixPQUFPckIsT0FBTyxHQUFHQSxRQUFRa0IsT0FBTztBQUNsQyxDQUFDLENBRUQsb0RBQW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaC5qcz80YzJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICAgIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoID0gdm9pZCAwO1xyXG52YXIgX3JlbW92ZVRyYWlsaW5nU2xhc2ggPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcmVtb3ZlLXRyYWlsaW5nLXNsYXNoXCIpO1xyXG52YXIgX3BhcnNlUGF0aCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXJzZS1wYXRoXCIpO1xyXG5jb25zdCBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCA9IChwYXRoKT0+e1xyXG4gICAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBwYXRobmFtZSAsIHF1ZXJ5ICwgaGFzaCAgfSA9ICgwLCBfcGFyc2VQYXRoKS5wYXJzZVBhdGgocGF0aCk7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIKSB7XHJcbiAgICAgICAgaWYgKC9cXC5bXi9dK1xcLz8kLy50ZXN0KHBhdGhuYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYCR7KDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKX0ke3F1ZXJ5fSR7aGFzaH1gO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocGF0aG5hbWUuZW5kc1dpdGgoJy8nKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYCR7cGF0aG5hbWV9JHtxdWVyeX0ke2hhc2h9YDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYCR7cGF0aG5hbWV9LyR7cXVlcnl9JHtoYXNofWA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGAkeygwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSl9JHtxdWVyeX0ke2hhc2h9YDtcclxufTtcclxuZXhwb3J0cy5ub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCA9IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoO1xyXG5cclxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcclxuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcclxufVxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwiX3JlbW92ZVRyYWlsaW5nU2xhc2giLCJyZXF1aXJlIiwiX3BhcnNlUGF0aCIsInBhdGgiLCJzdGFydHNXaXRoIiwicGF0aG5hbWUiLCJxdWVyeSIsImhhc2giLCJwYXJzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1RSQUlMSU5HX1NMQVNIIiwidGVzdCIsInJlbW92ZVRyYWlsaW5nU2xhc2giLCJlbmRzV2l0aCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/normalize-trailing-slash.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/remove-base-path.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/remove-base-path.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.removeBasePath = removeBasePath;\nvar _hasBasePath = __webpack_require__(/*! ./has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nconst basePath =  false || \"\";\nfunction removeBasePath(path) {\n    if (false) {}\n    path = path.slice(basePath.length);\n    if (!path.startsWith(\"/\")) path = \"/\".concat(path);\n    return path;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=remove-base-path.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZW1vdmUtYmFzZS1wYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHNCQUFzQixHQUFHRTtBQUN6QixJQUFJQyxlQUFlQyxtQkFBT0EsQ0FBQyx5RUFBaUI7QUFDNUMsTUFBTUMsV0FBV0MsTUFBa0MsSUFBSTtBQUN2RCxTQUFTSixlQUFlTyxJQUFJLEVBQUU7SUFDMUIsSUFBSUgsS0FBMEMsRUFBRSxFQUkvQztJQUNERyxPQUFPQSxLQUFLRyxLQUFLLENBQUNQLFNBQVNRLE1BQU07SUFDakMsSUFBSSxDQUFDSixLQUFLSyxVQUFVLENBQUMsTUFBTUwsT0FBTyxJQUFTLE9BQUxBO0lBQ3RDLE9BQU9BO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT1QsUUFBUWUsT0FBTyxLQUFLLGNBQWUsT0FBT2YsUUFBUWUsT0FBTyxLQUFLLFlBQVlmLFFBQVFlLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2YsUUFBUWUsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2xCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWUsT0FBTyxFQUFFLGNBQWM7UUFBRWQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9tQixNQUFNLENBQUNqQixRQUFRZSxPQUFPLEVBQUVmO0lBQy9Ca0IsT0FBT2xCLE9BQU8sR0FBR0EsUUFBUWUsT0FBTztBQUNsQyxDQUFDLENBRUQsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlbW92ZS1iYXNlLXBhdGguanM/YjRmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5yZW1vdmVCYXNlUGF0aCA9IHJlbW92ZUJhc2VQYXRoO1xyXG52YXIgX2hhc0Jhc2VQYXRoID0gcmVxdWlyZShcIi4vaGFzLWJhc2UtcGF0aFwiKTtcclxuY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnO1xyXG5mdW5jdGlvbiByZW1vdmVCYXNlUGF0aChwYXRoKSB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX01BTlVBTF9DTElFTlRfQkFTRV9QQVRIKSB7XHJcbiAgICAgICAgaWYgKCEoMCwgX2hhc0Jhc2VQYXRoKS5oYXNCYXNlUGF0aChwYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwYXRoID0gcGF0aC5zbGljZShiYXNlUGF0aC5sZW5ndGgpO1xyXG4gICAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoJy8nKSkgcGF0aCA9IGAvJHtwYXRofWA7XHJcbiAgICByZXR1cm4gcGF0aDtcclxufVxyXG5cclxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcclxuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcclxufVxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlLWJhc2UtcGF0aC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZW1vdmVCYXNlUGF0aCIsIl9oYXNCYXNlUGF0aCIsInJlcXVpcmUiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsIl9fTkVYVF9NQU5VQUxfQ0xJRU5UX0JBU0VfUEFUSCIsImhhc0Jhc2VQYXRoIiwic2xpY2UiLCJsZW5ndGgiLCJzdGFydHNXaXRoIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/remove-base-path.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.cancelIdleCallback = exports.requestIdleCallback = void 0;\nconst requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nexports.requestIdleCallback = requestIdleCallback;\nconst cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nexports.cancelIdleCallback = cancelIdleCallback;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZXF1ZXN0LWlkbGUtY2FsbGJhY2suanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsMEJBQTBCLEdBQUdBLDJCQUEyQixHQUFHLEtBQUs7QUFDaEUsTUFBTUcsc0JBQXNCLE9BQU9DLFNBQVMsZUFBZUEsS0FBS0QsbUJBQW1CLElBQUlDLEtBQUtELG1CQUFtQixDQUFDRSxJQUFJLENBQUNDLFdBQVcsU0FBU0MsRUFBRSxFQUFFO0lBQ3pJLElBQUlDLFFBQVFDLEtBQUtDLEdBQUc7SUFDcEIsT0FBT0MsV0FBVyxXQUFXO1FBQ3pCSixHQUFHO1lBQ0NLLFlBQVksS0FBSztZQUNqQkMsZUFBZSxXQUFXO2dCQUN0QixPQUFPQyxLQUFLQyxHQUFHLENBQUMsR0FBRyxLQUFNTixDQUFBQSxLQUFLQyxHQUFHLEtBQUtGLEtBQUk7WUFDOUM7UUFDSjtJQUNKLEdBQUc7QUFDUDtBQUNBUiwyQkFBMkIsR0FBR0c7QUFDOUIsTUFBTUQscUJBQXFCLE9BQU9FLFNBQVMsZUFBZUEsS0FBS0Ysa0JBQWtCLElBQUlFLEtBQUtGLGtCQUFrQixDQUFDRyxJQUFJLENBQUNDLFdBQVcsU0FBU1UsRUFBRSxFQUFFO0lBQ3RJLE9BQU9DLGFBQWFEO0FBQ3hCO0FBQ0FoQiwwQkFBMEIsR0FBR0U7QUFFN0IsSUFBSSxDQUFDLE9BQU9GLFFBQVFrQixPQUFPLEtBQUssY0FBZSxPQUFPbEIsUUFBUWtCLE9BQU8sS0FBSyxZQUFZbEIsUUFBUWtCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2xCLFFBQVFrQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLckIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRa0IsT0FBTyxFQUFFLGNBQWM7UUFBRWpCLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPc0IsTUFBTSxDQUFDcEIsUUFBUWtCLE9BQU8sRUFBRWxCO0lBQy9CcUIsT0FBT3JCLE9BQU8sR0FBR0EsUUFBUWtCLE9BQU87QUFDbEMsQ0FBQyxDQUVELGlEQUFpRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZXF1ZXN0LWlkbGUtY2FsbGJhY2suanM/MWUyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5jYW5jZWxJZGxlQ2FsbGJhY2sgPSBleHBvcnRzLnJlcXVlc3RJZGxlQ2FsbGJhY2sgPSB2b2lkIDA7XHJcbmNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrICYmIHNlbGYucmVxdWVzdElkbGVDYWxsYmFjay5iaW5kKHdpbmRvdykgfHwgZnVuY3Rpb24oY2IpIHtcclxuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XHJcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICBjYih7XHJcbiAgICAgICAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxyXG4gICAgICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCA1MCAtIChEYXRlLm5vdygpIC0gc3RhcnQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgMSk7XHJcbn07XHJcbmV4cG9ydHMucmVxdWVzdElkbGVDYWxsYmFjayA9IHJlcXVlc3RJZGxlQ2FsbGJhY2s7XHJcbmNvbnN0IGNhbmNlbElkbGVDYWxsYmFjayA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLmNhbmNlbElkbGVDYWxsYmFjayAmJiBzZWxmLmNhbmNlbElkbGVDYWxsYmFjay5iaW5kKHdpbmRvdykgfHwgZnVuY3Rpb24oaWQpIHtcclxuICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xyXG59O1xyXG5leHBvcnRzLmNhbmNlbElkbGVDYWxsYmFjayA9IGNhbmNlbElkbGVDYWxsYmFjaztcclxuXHJcbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XHJcbn1cclxuXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3QtaWRsZS1jYWxsYmFjay5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwic2VsZiIsImJpbmQiLCJ3aW5kb3ciLCJjYiIsInN0YXJ0IiwiRGF0ZSIsIm5vdyIsInNldFRpbWVvdXQiLCJkaWRUaW1lb3V0IiwidGltZVJlbWFpbmluZyIsIk1hdGgiLCJtYXgiLCJpZCIsImNsZWFyVGltZW91dCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/route-loader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-loader.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.markAssetError = markAssetError;\nexports.isAssetError = isAssetError;\nexports.getClientBuildManifest = getClientBuildManifest;\nexports.createRouteLoader = createRouteLoader;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _getAssetPathFromRoute = _interop_require_default(__webpack_require__(/*! ../shared/lib/router/utils/get-asset-path-from-route */ \"./node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js\"));\nvar _trustedTypes = __webpack_require__(/*! ./trusted-types */ \"./node_modules/next/dist/client/trusted-types.js\");\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\n// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\nconst MS_MAX_IDLE_DELAY = 3800;\nfunction withFuture(key, map, generator) {\n    let entry = map.get(key);\n    if (entry) {\n        if (\"future\" in entry) {\n            return entry.future;\n        }\n        return Promise.resolve(entry);\n    }\n    let resolver;\n    const prom = new Promise((resolve)=>{\n        resolver = resolve;\n    });\n    map.set(key, entry = {\n        resolve: resolver,\n        future: prom\n    });\n    return generator ? generator() // eslint-disable-next-line no-sequences\n    .then((value)=>(resolver(value), value)).catch((err)=>{\n        map.delete(key);\n        throw err;\n    }) : prom;\n}\nconst ASSET_LOAD_ERROR = Symbol(\"ASSET_LOAD_ERROR\");\nfunction markAssetError(err) {\n    return Object.defineProperty(err, ASSET_LOAD_ERROR, {});\n}\nfunction isAssetError(err) {\n    return err && ASSET_LOAD_ERROR in err;\n}\nfunction hasPrefetch(link) {\n    try {\n        link = document.createElement(\"link\");\n        return(// with relList.support\n        !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports(\"prefetch\"));\n    } catch (e) {\n        return false;\n    }\n}\nconst canPrefetch = hasPrefetch();\nfunction prefetchViaDom(href, as, link) {\n    return new Promise((resolve, reject)=>{\n        const selector = '\\n      link[rel=\"prefetch\"][href^=\"'.concat(href, '\"],\\n      link[rel=\"preload\"][href^=\"').concat(href, '\"],\\n      script[src^=\"').concat(href, '\"]');\n        if (document.querySelector(selector)) {\n            return resolve();\n        }\n        link = document.createElement(\"link\");\n        // The order of property assignment here is intentional:\n        if (as) link.as = as;\n        link.rel = \"prefetch\";\n        link.crossOrigin = undefined;\n        link.onload = resolve;\n        link.onerror = ()=>reject(markAssetError(new Error(\"Failed to prefetch: \".concat(href))));\n        // `href` should always be last:\n        link.href = href;\n        document.head.appendChild(link);\n    });\n}\nfunction appendScript(src, script) {\n    return new Promise((resolve, reject)=>{\n        script = document.createElement(\"script\");\n        // The order of property assignment here is intentional.\n        // 1. Setup success/failure hooks in case the browser synchronously\n        //    executes when `src` is set.\n        script.onload = resolve;\n        script.onerror = ()=>reject(markAssetError(new Error(\"Failed to load script: \".concat(src))));\n        // 2. Configure the cross-origin attribute before setting `src` in case the\n        //    browser begins to fetch.\n        script.crossOrigin = undefined;\n        // 3. Finally, set the source and inject into the DOM in case the child\n        //    must be appended for fetching to start.\n        script.src = src;\n        document.body.appendChild(script);\n    });\n}\n// We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\nlet devBuildPromise;\n// Resolve a promise that times out after given amount of milliseconds.\nfunction resolvePromiseWithTimeout(p, ms, err) {\n    return new Promise((resolve, reject)=>{\n        let cancelled = false;\n        p.then((r)=>{\n            // Resolved, cancel the timeout\n            cancelled = true;\n            resolve(r);\n        }).catch(reject);\n        // We wrap these checks separately for better dead-code elimination in\n        // production bundles.\n        if (true) {\n            (devBuildPromise || Promise.resolve()).then(()=>{\n                (0, _requestIdleCallback).requestIdleCallback(()=>setTimeout(()=>{\n                        if (!cancelled) {\n                            reject(err);\n                        }\n                    }, ms));\n            });\n        }\n        if (false) {}\n    });\n}\nfunction getClientBuildManifest() {\n    if (self.__BUILD_MANIFEST) {\n        return Promise.resolve(self.__BUILD_MANIFEST);\n    }\n    const onBuildManifest = new Promise((resolve)=>{\n        // Mandatory because this is not concurrent safe:\n        const cb = self.__BUILD_MANIFEST_CB;\n        self.__BUILD_MANIFEST_CB = ()=>{\n            resolve(self.__BUILD_MANIFEST);\n            cb && cb();\n        };\n    });\n    return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error(\"Failed to load client build manifest\")));\n}\nfunction getFilesForRoute(assetPrefix, route) {\n    if (true) {\n        const scriptUrl = assetPrefix + \"/_next/static/chunks/pages\" + encodeURI((0, _getAssetPathFromRoute).default(route, \".js\"));\n        return Promise.resolve({\n            scripts: [\n                (0, _trustedTypes).__unsafeCreateTrustedScriptURL(scriptUrl)\n            ],\n            // Styles are handled by `style-loader` in development:\n            css: []\n        });\n    }\n    return getClientBuildManifest().then((manifest)=>{\n        if (!(route in manifest)) {\n            throw markAssetError(new Error(\"Failed to lookup route: \".concat(route)));\n        }\n        const allFiles = manifest[route].map((entry)=>assetPrefix + \"/_next/\" + encodeURI(entry));\n        return {\n            scripts: allFiles.filter((v)=>v.endsWith(\".js\")).map((v)=>(0, _trustedTypes).__unsafeCreateTrustedScriptURL(v)),\n            css: allFiles.filter((v)=>v.endsWith(\".css\"))\n        };\n    });\n}\nfunction createRouteLoader(assetPrefix) {\n    const entrypoints = new Map();\n    const loadedScripts = new Map();\n    const styleSheets = new Map();\n    const routes = new Map();\n    function maybeExecuteScript(src) {\n        // With HMR we might need to \"reload\" scripts when they are\n        // disposed and readded. Executing scripts twice has no functional\n        // differences\n        if (false) {} else {\n            return appendScript(src);\n        }\n    }\n    function fetchStyleSheet(href) {\n        let prom = styleSheets.get(href);\n        if (prom) {\n            return prom;\n        }\n        styleSheets.set(href, prom = fetch(href).then((res)=>{\n            if (!res.ok) {\n                throw new Error(\"Failed to load stylesheet: \".concat(href));\n            }\n            return res.text().then((text)=>({\n                    href: href,\n                    content: text\n                }));\n        }).catch((err)=>{\n            throw markAssetError(err);\n        }));\n        return prom;\n    }\n    return {\n        whenEntrypoint (route) {\n            return withFuture(route, entrypoints);\n        },\n        onEntrypoint (route, execute) {\n            (execute ? Promise.resolve().then(()=>execute()).then((exports1)=>({\n                    component: exports1 && exports1.default || exports1,\n                    exports: exports1\n                }), (err)=>({\n                    error: err\n                })) : Promise.resolve(undefined)).then((input)=>{\n                const old = entrypoints.get(route);\n                if (old && \"resolve\" in old) {\n                    if (input) {\n                        entrypoints.set(route, input);\n                        old.resolve(input);\n                    }\n                } else {\n                    if (input) {\n                        entrypoints.set(route, input);\n                    } else {\n                        entrypoints.delete(route);\n                    }\n                    // when this entrypoint has been resolved before\n                    // the route is outdated and we want to invalidate\n                    // this cache entry\n                    routes.delete(route);\n                }\n            });\n        },\n        loadRoute (route, prefetch) {\n            return withFuture(route, routes, ()=>{\n                let devBuildPromiseResolve;\n                if (true) {\n                    devBuildPromise = new Promise((resolve)=>{\n                        devBuildPromiseResolve = resolve;\n                    });\n                }\n                return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then((param)=>{\n                    let { scripts , css  } = param;\n                    return Promise.all([\n                        entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)),\n                        Promise.all(css.map(fetchStyleSheet))\n                    ]);\n                }).then((res)=>{\n                    return this.whenEntrypoint(route).then((entrypoint)=>({\n                            entrypoint,\n                            styles: res[1]\n                        }));\n                }), MS_MAX_IDLE_DELAY, markAssetError(new Error(\"Route did not complete loading: \".concat(route)))).then((param)=>{\n                    let { entrypoint , styles  } = param;\n                    const res = Object.assign({\n                        styles: styles\n                    }, entrypoint);\n                    return \"error\" in entrypoint ? entrypoint : res;\n                }).catch((err)=>{\n                    if (prefetch) {\n                        // we don't want to cache errors during prefetch\n                        throw err;\n                    }\n                    return {\n                        error: err\n                    };\n                }).finally(()=>{\n                    return devBuildPromiseResolve == null ? void 0 : devBuildPromiseResolve();\n                });\n            });\n        },\n        prefetch (route) {\n            // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n            // License: Apache 2.0\n            let cn;\n            if (cn = navigator.connection) {\n                // Don't prefetch if using 2G or if Save-Data is enabled.\n                if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n            }\n            return getFilesForRoute(assetPrefix, route).then((output)=>Promise.all(canPrefetch ? output.scripts.map((script)=>prefetchViaDom(script.toString(), \"script\")) : [])).then(()=>{\n                (0, _requestIdleCallback).requestIdleCallback(()=>this.loadRoute(route, true).catch(()=>{}));\n            }).catch(()=>{});\n        }\n    };\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=route-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZS1sb2FkZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsc0JBQXNCLEdBQUdFO0FBQ3pCRixvQkFBb0IsR0FBR0c7QUFDdkJILDhCQUE4QixHQUFHSTtBQUNqQ0oseUJBQXlCLEdBQUdLO0FBQzVCLElBQUlDLDJCQUEyQkMsbUpBQStEO0FBQzlGLElBQUlFLHlCQUF5QkgseUJBQXlCQyxtQkFBT0EsQ0FBQywySUFBc0Q7QUFDcEgsSUFBSUcsZ0JBQWdCSCxtQkFBT0EsQ0FBQyx5RUFBaUI7QUFDN0MsSUFBSUksdUJBQXVCSixtQkFBT0EsQ0FBQyx5RkFBeUI7QUFDNUQsdUVBQXVFO0FBQ3ZFLHlFQUF5RTtBQUN6RSwyRUFBMkU7QUFDM0Usb0NBQW9DO0FBQ3BDLE1BQU1LLG9CQUFvQjtBQUMxQixTQUFTQyxXQUFXQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsU0FBUyxFQUFFO0lBQ3JDLElBQUlDLFFBQVFGLElBQUlHLEdBQUcsQ0FBQ0o7SUFDcEIsSUFBSUcsT0FBTztRQUNQLElBQUksWUFBWUEsT0FBTztZQUNuQixPQUFPQSxNQUFNRSxNQUFNO1FBQ3ZCLENBQUM7UUFDRCxPQUFPQyxRQUFRQyxPQUFPLENBQUNKO0lBQzNCLENBQUM7SUFDRCxJQUFJSztJQUNKLE1BQU1DLE9BQU8sSUFBSUgsUUFBUSxDQUFDQyxVQUFVO1FBQ2hDQyxXQUFXRDtJQUNmO0lBQ0FOLElBQUlTLEdBQUcsQ0FBQ1YsS0FBS0csUUFBUTtRQUNqQkksU0FBU0M7UUFDVEgsUUFBUUk7SUFDWjtJQUNBLE9BQU9QLFlBQVlBLFlBQVcsd0NBQXdDO0tBQ3JFUyxJQUFJLENBQUMsQ0FBQ3hCLFFBQVNxQixDQUFBQSxTQUFTckIsUUFBUUEsS0FBSyxHQUFHeUIsS0FBSyxDQUFDLENBQUNDLE1BQU07UUFDbERaLElBQUlhLE1BQU0sQ0FBQ2Q7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QXNIO1lBQ3RILHNCQUFzQjtZQUN0QixJQUFJeUM7WUFDSixJQUFJQSxLQUFLQyxVQUFVQyxVQUFVLEVBQUU7Z0JBQzNCLHlEQUF5RDtnQkFDekQsSUFBSUYsR0FBR0csUUFBUSxJQUFJLEtBQUtDLElBQUksQ0FBQ0osR0FBR0ssYUFBYSxHQUFHLE9BQU92RyxRQUFRQyxPQUFPO1lBQzFFLENBQUM7WUFDRCxPQUFPc0QsaUJBQWlCQyxhQUFhQyxPQUFPcEQsSUFBSSxDQUFDLENBQUNtRyxTQUFTeEcsUUFBUTRGLEdBQUcsQ0FBQ3ZFLGNBQWNtRixPQUFPNUMsT0FBTyxDQUFDakUsR0FBRyxDQUFDLENBQUM2QyxTQUFTbEIsZUFBZWtCLE9BQU9rQyxRQUFRLElBQUksYUFBYSxFQUFFLEdBQUdyRSxJQUFJLENBQUMsSUFBSTtnQkFDMUssSUFBR2Qsb0JBQW9CLEVBQUV5RCxtQkFBbUIsQ0FBQyxJQUFJLElBQUksQ0FBQ3lDLFNBQVMsQ0FBQ2hDLE9BQU8sSUFBSSxFQUFFbkQsS0FBSyxDQUFDLElBQUksQ0FBQztZQUM3RixHQUFHQSxLQUFLLENBQ1IsSUFBSSxDQUFDO1FBQ1Q7SUFDSjtBQUNKO0FBRUEsSUFBSSxDQUFDLE9BQU8xQixRQUFRUSxPQUFPLEtBQUssY0FBZSxPQUFPUixRQUFRUSxPQUFPLEtBQUssWUFBWVIsUUFBUVEsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPUixRQUFRUSxPQUFPLENBQUNxSCxVQUFVLEtBQUssYUFBYTtJQUNySy9ILE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUVEsT0FBTyxFQUFFLGNBQWM7UUFBRVAsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9zSCxNQUFNLENBQUNwSCxRQUFRUSxPQUFPLEVBQUVSO0lBQy9COEgsT0FBTzlILE9BQU8sR0FBR0EsUUFBUVEsT0FBTztBQUNsQyxDQUFDLENBRUQsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JvdXRlLWxvYWRlci5qcz9lYTM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICAgIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLm1hcmtBc3NldEVycm9yID0gbWFya0Fzc2V0RXJyb3I7XHJcbmV4cG9ydHMuaXNBc3NldEVycm9yID0gaXNBc3NldEVycm9yO1xyXG5leHBvcnRzLmdldENsaWVudEJ1aWxkTWFuaWZlc3QgPSBnZXRDbGllbnRCdWlsZE1hbmlmZXN0O1xyXG5leHBvcnRzLmNyZWF0ZVJvdXRlTG9hZGVyID0gY3JlYXRlUm91dGVMb2FkZXI7XHJcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcclxudmFyIF9nZXRBc3NldFBhdGhGcm9tUm91dGUgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGVcIikpO1xyXG52YXIgX3RydXN0ZWRUeXBlcyA9IHJlcXVpcmUoXCIuL3RydXN0ZWQtdHlwZXNcIik7XHJcbnZhciBfcmVxdWVzdElkbGVDYWxsYmFjayA9IHJlcXVpcmUoXCIuL3JlcXVlc3QtaWRsZS1jYWxsYmFja1wiKTtcclxuLy8gMy44cyB3YXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGl0J3Mgd2hhdCBodHRwczovL3dlYi5kZXYvaW50ZXJhY3RpdmVcclxuLy8gY29uc2lkZXJzIGFzIFwiR29vZFwiIHRpbWUtdG8taW50ZXJhY3RpdmUuIFdlIG11c3QgYXNzdW1lIHNvbWV0aGluZyB3ZW50XHJcbi8vIHdyb25nIGJleW9uZCB0aGlzIHBvaW50LCBhbmQgdGhlbiBmYWxsLWJhY2sgdG8gYSBmdWxsIHBhZ2UgdHJhbnNpdGlvbiB0b1xyXG4vLyBzaG93IHRoZSB1c2VyIHNvbWV0aGluZyBvZiB2YWx1ZS5cclxuY29uc3QgTVNfTUFYX0lETEVfREVMQVkgPSAzODAwO1xyXG5mdW5jdGlvbiB3aXRoRnV0dXJlKGtleSwgbWFwLCBnZW5lcmF0b3IpIHtcclxuICAgIGxldCBlbnRyeSA9IG1hcC5nZXQoa2V5KTtcclxuICAgIGlmIChlbnRyeSkge1xyXG4gICAgICAgIGlmICgnZnV0dXJlJyBpbiBlbnRyeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkuZnV0dXJlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVudHJ5KTtcclxuICAgIH1cclxuICAgIGxldCByZXNvbHZlcjtcclxuICAgIGNvbnN0IHByb20gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PntcclxuICAgICAgICByZXNvbHZlciA9IHJlc29sdmU7XHJcbiAgICB9KTtcclxuICAgIG1hcC5zZXQoa2V5LCBlbnRyeSA9IHtcclxuICAgICAgICByZXNvbHZlOiByZXNvbHZlcixcclxuICAgICAgICBmdXR1cmU6IHByb21cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGdlbmVyYXRvciA/IGdlbmVyYXRvcigpLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xyXG4gICAgLnRoZW4oKHZhbHVlKT0+KHJlc29sdmVyKHZhbHVlKSwgdmFsdWUpKS5jYXRjaCgoZXJyKT0+e1xyXG4gICAgICAgIG1hcC5kZWxldGUoa2V5KTtcclxuICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICB9KSA6IHByb207XHJcbn1cclxuY29uc3QgQVNTRVRfTE9BRF9FUlJPUiA9IFN5bWJvbCgnQVNTRVRfTE9BRF9FUlJPUicpO1xyXG5mdW5jdGlvbiBtYXJrQXNzZXRFcnJvcihlcnIpIHtcclxuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCBBU1NFVF9MT0FEX0VSUk9SLCB7fSk7XHJcbn1cclxuZnVuY3Rpb24gaXNBc3NldEVycm9yKGVycikge1xyXG4gICAgcmV0dXJuIGVyciAmJiBBU1NFVF9MT0FEX0VSUk9SIGluIGVycjtcclxufVxyXG5mdW5jdGlvbiBoYXNQcmVmZXRjaChsaW5rKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XHJcbiAgICAgICAgcmV0dXJuKC8vIGRldGVjdCBJRTExIHNpbmNlIGl0IHN1cHBvcnRzIHByZWZldGNoIGJ1dCBpc24ndCBkZXRlY3RlZFxyXG4gICAgICAgIC8vIHdpdGggcmVsTGlzdC5zdXBwb3J0XHJcbiAgICAgICAgKCEhd2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB8fCBsaW5rLnJlbExpc3Quc3VwcG9ydHMoJ3ByZWZldGNoJykpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5jb25zdCBjYW5QcmVmZXRjaCA9IGhhc1ByZWZldGNoKCk7XHJcbmZ1bmN0aW9uIHByZWZldGNoVmlhRG9tKGhyZWYsIGFzLCBsaW5rKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcclxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGBcclxuICAgICAgbGlua1tyZWw9XCJwcmVmZXRjaFwiXVtocmVmXj1cIiR7aHJlZn1cIl0sXHJcbiAgICAgIGxpbmtbcmVsPVwicHJlbG9hZFwiXVtocmVmXj1cIiR7aHJlZn1cIl0sXHJcbiAgICAgIHNjcmlwdFtzcmNePVwiJHtocmVmfVwiXWA7XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XHJcbiAgICAgICAgLy8gVGhlIG9yZGVyIG9mIHByb3BlcnR5IGFzc2lnbm1lbnQgaGVyZSBpcyBpbnRlbnRpb25hbDpcclxuICAgICAgICBpZiAoYXMpIGxpbmsuYXMgPSBhcztcclxuICAgICAgICBsaW5rLnJlbCA9IGBwcmVmZXRjaGA7XHJcbiAgICAgICAgbGluay5jcm9zc09yaWdpbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DUk9TU19PUklHSU47XHJcbiAgICAgICAgbGluay5vbmxvYWQgPSByZXNvbHZlO1xyXG4gICAgICAgIGxpbmsub25lcnJvciA9ICgpPT5yZWplY3QobWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gcHJlZmV0Y2g6ICR7aHJlZn1gKSkpO1xyXG4gICAgICAgIC8vIGBocmVmYCBzaG91bGQgYWx3YXlzIGJlIGxhc3Q6XHJcbiAgICAgICAgbGluay5ocmVmID0gaHJlZjtcclxuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gYXBwZW5kU2NyaXB0KHNyYywgc2NyaXB0KSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcclxuICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcclxuICAgICAgICAvLyBUaGUgb3JkZXIgb2YgcHJvcGVydHkgYXNzaWdubWVudCBoZXJlIGlzIGludGVudGlvbmFsLlxyXG4gICAgICAgIC8vIDEuIFNldHVwIHN1Y2Nlc3MvZmFpbHVyZSBob29rcyBpbiBjYXNlIHRoZSBicm93c2VyIHN5bmNocm9ub3VzbHlcclxuICAgICAgICAvLyAgICBleGVjdXRlcyB3aGVuIGBzcmNgIGlzIHNldC5cclxuICAgICAgICBzY3JpcHQub25sb2FkID0gcmVzb2x2ZTtcclxuICAgICAgICBzY3JpcHQub25lcnJvciA9ICgpPT5yZWplY3QobWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzY3JpcHQ6ICR7c3JjfWApKSk7XHJcbiAgICAgICAgLy8gMi4gQ29uZmlndXJlIHRoZSBjcm9zcy1vcmlnaW4gYXR0cmlidXRlIGJlZm9yZSBzZXR0aW5nIGBzcmNgIGluIGNhc2UgdGhlXHJcbiAgICAgICAgLy8gICAgYnJvd3NlciBiZWdpbnMgdG8gZmV0Y2guXHJcbiAgICAgICAgc2NyaXB0LmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NST1NTX09SSUdJTjtcclxuICAgICAgICAvLyAzLiBGaW5hbGx5LCBzZXQgdGhlIHNvdXJjZSBhbmQgaW5qZWN0IGludG8gdGhlIERPTSBpbiBjYXNlIHRoZSBjaGlsZFxyXG4gICAgICAgIC8vICAgIG11c3QgYmUgYXBwZW5kZWQgZm9yIGZldGNoaW5nIHRvIHN0YXJ0LlxyXG4gICAgICAgIHNjcmlwdC5zcmMgPSBzcmM7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xyXG4gICAgfSk7XHJcbn1cclxuLy8gV2Ugd2FpdCBmb3IgcGFnZXMgdG8gYmUgYnVpbHQgaW4gZGV2IGJlZm9yZSB3ZSBzdGFydCB0aGUgcm91dGUgdHJhbnNpdGlvblxyXG4vLyB0aW1lb3V0IHRvIHByZXZlbnQgYW4gdW4tbmVjZXNzYXJ5IGhhcmQgbmF2aWdhdGlvbiBpbiBkZXZlbG9wbWVudC5cclxubGV0IGRldkJ1aWxkUHJvbWlzZTtcclxuLy8gUmVzb2x2ZSBhIHByb21pc2UgdGhhdCB0aW1lcyBvdXQgYWZ0ZXIgZ2l2ZW4gYW1vdW50IG9mIG1pbGxpc2Vjb25kcy5cclxuZnVuY3Rpb24gcmVzb2x2ZVByb21pc2VXaXRoVGltZW91dChwLCBtcywgZXJyKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcclxuICAgICAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgcC50aGVuKChyKT0+e1xyXG4gICAgICAgICAgICAvLyBSZXNvbHZlZCwgY2FuY2VsIHRoZSB0aW1lb3V0XHJcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlc29sdmUocik7XHJcbiAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAvLyBXZSB3cmFwIHRoZXNlIGNoZWNrcyBzZXBhcmF0ZWx5IGZvciBiZXR0ZXIgZGVhZC1jb2RlIGVsaW1pbmF0aW9uIGluXHJcbiAgICAgICAgLy8gcHJvZHVjdGlvbiBidW5kbGVzLlxyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xyXG4gICAgICAgICAgICAoZGV2QnVpbGRQcm9taXNlIHx8IFByb21pc2UucmVzb2x2ZSgpKS50aGVuKCgpPT57XHJcbiAgICAgICAgICAgICAgICAoMCwgX3JlcXVlc3RJZGxlQ2FsbGJhY2spLnJlcXVlc3RJZGxlQ2FsbGJhY2soKCk9PnNldFRpbWVvdXQoKCk9PntcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgbXMpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xyXG4gICAgICAgICAgICAoMCwgX3JlcXVlc3RJZGxlQ2FsbGJhY2spLnJlcXVlc3RJZGxlQ2FsbGJhY2soKCk9PnNldFRpbWVvdXQoKCk9PntcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCBtcykpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKSB7XHJcbiAgICBpZiAoc2VsZi5fX0JVSUxEX01BTklGRVNUKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzZWxmLl9fQlVJTERfTUFOSUZFU1QpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb25CdWlsZE1hbmlmZXN0ID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XHJcbiAgICAgICAgLy8gTWFuZGF0b3J5IGJlY2F1c2UgdGhpcyBpcyBub3QgY29uY3VycmVudCBzYWZlOlxyXG4gICAgICAgIGNvbnN0IGNiID0gc2VsZi5fX0JVSUxEX01BTklGRVNUX0NCO1xyXG4gICAgICAgIHNlbGYuX19CVUlMRF9NQU5JRkVTVF9DQiA9ICgpPT57XHJcbiAgICAgICAgICAgIHJlc29sdmUoc2VsZi5fX0JVSUxEX01BTklGRVNUKTtcclxuICAgICAgICAgICAgY2IgJiYgY2IoKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzb2x2ZVByb21pc2VXaXRoVGltZW91dChvbkJ1aWxkTWFuaWZlc3QsIE1TX01BWF9JRExFX0RFTEFZLCBtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGNsaWVudCBidWlsZCBtYW5pZmVzdCcpKSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xyXG4gICAgICAgIGNvbnN0IHNjcmlwdFVybCA9IGFzc2V0UHJlZml4ICsgJy9fbmV4dC9zdGF0aWMvY2h1bmtzL3BhZ2VzJyArIGVuY29kZVVSSSgoMCwgX2dldEFzc2V0UGF0aEZyb21Sb3V0ZSkuZGVmYXVsdChyb3V0ZSwgJy5qcycpKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICAgICAgc2NyaXB0czogW1xyXG4gICAgICAgICAgICAgICAgKDAsIF90cnVzdGVkVHlwZXMpLl9fdW5zYWZlQ3JlYXRlVHJ1c3RlZFNjcmlwdFVSTChzY3JpcHRVcmwpXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIC8vIFN0eWxlcyBhcmUgaGFuZGxlZCBieSBgc3R5bGUtbG9hZGVyYCBpbiBkZXZlbG9wbWVudDpcclxuICAgICAgICAgICAgY3NzOiBbXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKS50aGVuKChtYW5pZmVzdCk9PntcclxuICAgICAgICBpZiAoIShyb3V0ZSBpbiBtYW5pZmVzdCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9va3VwIHJvdXRlOiAke3JvdXRlfWApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWxsRmlsZXMgPSBtYW5pZmVzdFtyb3V0ZV0ubWFwKChlbnRyeSk9PmFzc2V0UHJlZml4ICsgJy9fbmV4dC8nICsgZW5jb2RlVVJJKGVudHJ5KSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2NyaXB0czogYWxsRmlsZXMuZmlsdGVyKCh2KT0+di5lbmRzV2l0aCgnLmpzJykpLm1hcCgodik9PigwLCBfdHJ1c3RlZFR5cGVzKS5fX3Vuc2FmZUNyZWF0ZVRydXN0ZWRTY3JpcHRVUkwodikpLFxyXG4gICAgICAgICAgICBjc3M6IGFsbEZpbGVzLmZpbHRlcigodik9PnYuZW5kc1dpdGgoJy5jc3MnKSlcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUm91dGVMb2FkZXIoYXNzZXRQcmVmaXgpIHtcclxuICAgIGNvbnN0IGVudHJ5cG9pbnRzID0gbmV3IE1hcCgpO1xyXG4gICAgY29uc3QgbG9hZGVkU2NyaXB0cyA9IG5ldyBNYXAoKTtcclxuICAgIGNvbnN0IHN0eWxlU2hlZXRzID0gbmV3IE1hcCgpO1xyXG4gICAgY29uc3Qgcm91dGVzID0gbmV3IE1hcCgpO1xyXG4gICAgZnVuY3Rpb24gbWF5YmVFeGVjdXRlU2NyaXB0KHNyYykge1xyXG4gICAgICAgIC8vIFdpdGggSE1SIHdlIG1pZ2h0IG5lZWQgdG8gXCJyZWxvYWRcIiBzY3JpcHRzIHdoZW4gdGhleSBhcmVcclxuICAgICAgICAvLyBkaXNwb3NlZCBhbmQgcmVhZGRlZC4gRXhlY3V0aW5nIHNjcmlwdHMgdHdpY2UgaGFzIG5vIGZ1bmN0aW9uYWxcclxuICAgICAgICAvLyBkaWZmZXJlbmNlc1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xyXG4gICAgICAgICAgICBsZXQgcHJvbSA9IGxvYWRlZFNjcmlwdHMuZ2V0KHNyYy50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgaWYgKHByb20pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNraXAgZXhlY3V0aW5nIHNjcmlwdCBpZiBpdCdzIGFscmVhZHkgaW4gdGhlIERPTTpcclxuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHNjcmlwdFtzcmNePVwiJHtzcmN9XCJdYCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2FkZWRTY3JpcHRzLnNldChzcmMudG9TdHJpbmcoKSwgcHJvbSA9IGFwcGVuZFNjcmlwdChzcmMpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb207XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcGVuZFNjcmlwdChzcmMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZldGNoU3R5bGVTaGVldChocmVmKSB7XHJcbiAgICAgICAgbGV0IHByb20gPSBzdHlsZVNoZWV0cy5nZXQoaHJlZik7XHJcbiAgICAgICAgaWYgKHByb20pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0eWxlU2hlZXRzLnNldChocmVmLCBwcm9tID0gZmV0Y2goaHJlZikudGhlbigocmVzKT0+e1xyXG4gICAgICAgICAgICBpZiAoIXJlcy5vaykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdHlsZXNoZWV0OiAke2hyZWZ9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlcy50ZXh0KCkudGhlbigodGV4dCk9Pih7XHJcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogaHJlZixcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0ZXh0XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcclxuICAgICAgICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IoZXJyKTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuIHByb207XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHdoZW5FbnRyeXBvaW50IChyb3V0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gd2l0aEZ1dHVyZShyb3V0ZSwgZW50cnlwb2ludHMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25FbnRyeXBvaW50IChyb3V0ZSwgZXhlY3V0ZSkge1xyXG4gICAgICAgICAgICAoZXhlY3V0ZSA/IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PmV4ZWN1dGUoKSkudGhlbigoZXhwb3J0cyk9Pih7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBleHBvcnRzICYmIGV4cG9ydHMuZGVmYXVsdCB8fCBleHBvcnRzLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IGV4cG9ydHNcclxuICAgICAgICAgICAgICAgIH0pLCAoZXJyKT0+KHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgICAgICB9KSkgOiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKSkudGhlbigoaW5wdXQpPT57XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGQgPSBlbnRyeXBvaW50cy5nZXQocm91dGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9sZCAmJiAncmVzb2x2ZScgaW4gb2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLnNldChyb3V0ZSwgaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGQucmVzb2x2ZShpbnB1dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnlwb2ludHMuc2V0KHJvdXRlLCBpbnB1dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnlwb2ludHMuZGVsZXRlKHJvdXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGlzIGVudHJ5cG9pbnQgaGFzIGJlZW4gcmVzb2x2ZWQgYmVmb3JlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJvdXRlIGlzIG91dGRhdGVkIGFuZCB3ZSB3YW50IHRvIGludmFsaWRhdGVcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNhY2hlIGVudHJ5XHJcbiAgICAgICAgICAgICAgICAgICAgcm91dGVzLmRlbGV0ZShyb3V0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG9hZFJvdXRlIChyb3V0ZSwgcHJlZmV0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpdGhGdXR1cmUocm91dGUsIHJvdXRlcywgKCk9PntcclxuICAgICAgICAgICAgICAgIGxldCBkZXZCdWlsZFByb21pc2VSZXNvbHZlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGV2QnVpbGRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldkJ1aWxkUHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQoZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpLnRoZW4oKHsgc2NyaXB0cyAsIGNzcyAgfSk9PntcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeXBvaW50cy5oYXMocm91dGUpID8gW10gOiBQcm9taXNlLmFsbChzY3JpcHRzLm1hcChtYXliZUV4ZWN1dGVTY3JpcHQpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoY3NzLm1hcChmZXRjaFN0eWxlU2hlZXQpKSwgXHJcbiAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICB9KS50aGVuKChyZXMpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlbkVudHJ5cG9pbnQocm91dGUpLnRoZW4oKGVudHJ5cG9pbnQpPT4oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnlwb2ludCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogcmVzWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH0pLCBNU19NQVhfSURMRV9ERUxBWSwgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKGBSb3V0ZSBkaWQgbm90IGNvbXBsZXRlIGxvYWRpbmc6ICR7cm91dGV9YCkpKS50aGVuKCh7IGVudHJ5cG9pbnQgLCBzdHlsZXMgIH0pPT57XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogc3R5bGVzXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZW50cnlwb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdlcnJvcicgaW4gZW50cnlwb2ludCA/IGVudHJ5cG9pbnQgOiByZXM7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmZXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGNhY2hlIGVycm9ycyBkdXJpbmcgcHJlZmV0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoKCk9PntcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGV2QnVpbGRQcm9taXNlUmVzb2x2ZSA9PSBudWxsID8gdm9pZCAwIDogZGV2QnVpbGRQcm9taXNlUmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJlZmV0Y2ggKHJvdXRlKSB7XHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWVMYWJzL3F1aWNrbGluay9ibG9iLzQ1M2E2NjFmYTFmYTk0MGUyZDJlMDQ0NDUyMzk4ZTM4YzY3YTk4ZmIvc3JjL2luZGV4Lm1qcyNMMTE1LUwxMThcclxuICAgICAgICAgICAgLy8gTGljZW5zZTogQXBhY2hlIDIuMFxyXG4gICAgICAgICAgICBsZXQgY247XHJcbiAgICAgICAgICAgIGlmIChjbiA9IG5hdmlnYXRvci5jb25uZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBwcmVmZXRjaCBpZiB1c2luZyAyRyBvciBpZiBTYXZlLURhdGEgaXMgZW5hYmxlZC5cclxuICAgICAgICAgICAgICAgIGlmIChjbi5zYXZlRGF0YSB8fCAvMmcvLnRlc3QoY24uZWZmZWN0aXZlVHlwZSkpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpLnRoZW4oKG91dHB1dCk9PlByb21pc2UuYWxsKGNhblByZWZldGNoID8gb3V0cHV0LnNjcmlwdHMubWFwKChzY3JpcHQpPT5wcmVmZXRjaFZpYURvbShzY3JpcHQudG9TdHJpbmcoKSwgJ3NjcmlwdCcpKSA6IFtdKSkudGhlbigoKT0+e1xyXG4gICAgICAgICAgICAgICAgKDAsIF9yZXF1ZXN0SWRsZUNhbGxiYWNrKS5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpPT50aGlzLmxvYWRSb3V0ZShyb3V0ZSwgdHJ1ZSkuY2F0Y2goKCk9Pnt9KSk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKC8vIHN3YWxsb3cgcHJlZmV0Y2ggZXJyb3JzXHJcbiAgICAgICAgICAgICgpPT57fSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcclxuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcclxufVxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGUtbG9hZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1hcmtBc3NldEVycm9yIiwiaXNBc3NldEVycm9yIiwiZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCIsImNyZWF0ZVJvdXRlTG9hZGVyIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsImRlZmF1bHQiLCJfZ2V0QXNzZXRQYXRoRnJvbVJvdXRlIiwiX3RydXN0ZWRUeXBlcyIsIl9yZXF1ZXN0SWRsZUNhbGxiYWNrIiwiTVNfTUFYX0lETEVfREVMQVkiLCJ3aXRoRnV0dXJlIiwia2V5IiwibWFwIiwiZ2VuZXJhdG9yIiwiZW50cnkiLCJnZXQiLCJmdXR1cmUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc29sdmVyIiwicHJvbSIsInNldCIsInRoZW4iLCJjYXRjaCIsImVyciIsImRlbGV0ZSIsIkFTU0VUX0xPQURfRVJST1IiLCJTeW1ib2wiLCJoYXNQcmVmZXRjaCIsImxpbmsiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ3aW5kb3ciLCJNU0lucHV0TWV0aG9kQ29udGV4dCIsImRvY3VtZW50TW9kZSIsInJlbExpc3QiLCJzdXBwb3J0cyIsImUiLCJjYW5QcmVmZXRjaCIsInByZWZldGNoVmlhRG9tIiwiaHJlZiIsImFzIiwicmVqZWN0Iiwic2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yIiwicmVsIiwiY3Jvc3NPcmlnaW4iLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0NST1NTX09SSUdJTiIsIm9ubG9hZCIsIm9uZXJyb3IiLCJFcnJvciIsImhlYWQiLCJhcHBlbmRDaGlsZCIsImFwcGVuZFNjcmlwdCIsInNyYyIsInNjcmlwdCIsImJvZHkiLCJkZXZCdWlsZFByb21pc2UiLCJyZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0IiwicCIsIm1zIiwiY2FuY2VsbGVkIiwiciIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJzZXRUaW1lb3V0Iiwic2VsZiIsIl9fQlVJTERfTUFOSUZFU1QiLCJvbkJ1aWxkTWFuaWZlc3QiLCJjYiIsIl9fQlVJTERfTUFOSUZFU1RfQ0IiLCJnZXRGaWxlc0ZvclJvdXRlIiwiYXNzZXRQcmVmaXgiLCJyb3V0ZSIsInNjcmlwdFVybCIsImVuY29kZVVSSSIsInNjcmlwdHMiLCJfX3Vuc2FmZUNyZWF0ZVRydXN0ZWRTY3JpcHRVUkwiLCJjc3MiLCJtYW5pZmVzdCIsImFsbEZpbGVzIiwiZmlsdGVyIiwidiIsImVuZHNXaXRoIiwiZW50cnlwb2ludHMiLCJNYXAiLCJsb2FkZWRTY3JpcHRzIiwic3R5bGVTaGVldHMiLCJyb3V0ZXMiLCJtYXliZUV4ZWN1dGVTY3JpcHQiLCJ0b1N0cmluZyIsImZldGNoU3R5bGVTaGVldCIsImZldGNoIiwicmVzIiwib2siLCJ0ZXh0IiwiY29udGVudCIsIndoZW5FbnRyeXBvaW50Iiwib25FbnRyeXBvaW50IiwiZXhlY3V0ZSIsImNvbXBvbmVudCIsImVycm9yIiwidW5kZWZpbmVkIiwiaW5wdXQiLCJvbGQiLCJsb2FkUm91dGUiLCJwcmVmZXRjaCIsImRldkJ1aWxkUHJvbWlzZVJlc29sdmUiLCJhbGwiLCJoYXMiLCJlbnRyeXBvaW50Iiwic3R5bGVzIiwiYXNzaWduIiwiZmluYWxseSIsImNuIiwibmF2aWdhdG9yIiwiY29ubmVjdGlvbiIsInNhdmVEYXRhIiwidGVzdCIsImVmZmVjdGl2ZVR5cGUiLCJvdXRwdXQiLCJfX2VzTW9kdWxlIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/route-loader.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Router\", ({\n    enumerable: true,\n    get: function() {\n        return _router.default;\n    }\n}));\nObject.defineProperty(exports, \"withRouter\", ({\n    enumerable: true,\n    get: function() {\n        return _withRouter.default;\n    }\n}));\nexports.useRouter = useRouter;\nexports.createRouter = createRouter;\nexports.makePublicRouterInstance = makePublicRouterInstance;\nexports[\"default\"] = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _router = _interop_require_default(__webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\"));\nvar _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\nvar _isError = _interop_require_default(__webpack_require__(/*! ../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nvar _withRouter = _interop_require_default(__webpack_require__(/*! ./with-router */ \"./node_modules/next/dist/client/with-router.js\"));\nconst singletonRouter = {\n    router: null,\n    readyCallbacks: [],\n    ready (cb) {\n        if (this.router) return cb();\n        if (true) {\n            this.readyCallbacks.push(cb);\n        }\n    }\n};\n// Create public properties and methods of the router in the singletonRouter\nconst urlPropertyFields = [\n    \"pathname\",\n    \"route\",\n    \"query\",\n    \"asPath\",\n    \"components\",\n    \"isFallback\",\n    \"basePath\",\n    \"locale\",\n    \"locales\",\n    \"defaultLocale\",\n    \"isReady\",\n    \"isPreview\",\n    \"isLocaleDomain\",\n    \"domainLocales\"\n];\nconst routerEvents = [\n    \"routeChangeStart\",\n    \"beforeHistoryChange\",\n    \"routeChangeComplete\",\n    \"routeChangeError\",\n    \"hashChangeStart\",\n    \"hashChangeComplete\"\n];\nconst coreMethodFields = [\n    \"push\",\n    \"replace\",\n    \"reload\",\n    \"back\",\n    \"prefetch\",\n    \"beforePopState\"\n];\n// Events is a static property on the router, the router doesn't have to be initialized to use it\nObject.defineProperty(singletonRouter, \"events\", {\n    get () {\n        return _router.default.events;\n    }\n});\nfunction getRouter() {\n    if (!singletonRouter.router) {\n        const message = \"No router instance found.\\n\" + 'You should only use \"next/router\" on the client side of your app.\\n';\n        throw new Error(message);\n    }\n    return singletonRouter.router;\n}\nurlPropertyFields.forEach((field)=>{\n    // Here we need to use Object.defineProperty because we need to return\n    // the property assigned to the actual router\n    // The value might get changed as we change routes and this is the\n    // proper way to access it\n    Object.defineProperty(singletonRouter, field, {\n        get () {\n            const router = getRouter();\n            return router[field];\n        }\n    });\n});\ncoreMethodFields.forEach((field)=>{\n    singletonRouter[field] = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const router = getRouter();\n        return router[field](...args);\n    };\n});\nrouterEvents.forEach((event)=>{\n    singletonRouter.ready(()=>{\n        _router.default.events.on(event, function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            const eventField = \"on\".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));\n            const _singletonRouter = singletonRouter;\n            if (_singletonRouter[eventField]) {\n                try {\n                    _singletonRouter[eventField](...args);\n                } catch (err) {\n                    console.error(\"Error when running the Router event: \".concat(eventField));\n                    console.error((0, _isError).default(err) ? \"\".concat(err.message, \"\\n\").concat(err.stack) : err + \"\");\n                }\n            }\n        });\n    });\n});\nvar _default = singletonRouter;\nexports[\"default\"] = _default;\nfunction useRouter() {\n    _s();\n    const router = _react.default.useContext(_routerContext.RouterContext);\n    if (!router) {\n        throw new Error(\"Error: NextRouter was not mounted. https://nextjs.org/docs/messages/next-router-not-mounted\");\n    }\n    return router;\n}\n_s(useRouter, \"rbAhEc3dLGnVlsHWaSDsgP4MZS0=\");\nfunction createRouter() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    singletonRouter.router = new _router.default(...args);\n    singletonRouter.readyCallbacks.forEach((cb)=>cb());\n    singletonRouter.readyCallbacks = [];\n    return singletonRouter.router;\n}\nfunction makePublicRouterInstance(router) {\n    const scopedRouter = router;\n    const instance = {};\n    for (const property of urlPropertyFields){\n        if (typeof scopedRouter[property] === \"object\") {\n            instance[property] = Object.assign(Array.isArray(scopedRouter[property]) ? [] : {}, scopedRouter[property]) // makes sure query is not stateful\n            ;\n            continue;\n        }\n        instance[property] = scopedRouter[property];\n    }\n    // Events is a static property on the router, the router doesn't have to be initialized to use it\n    instance.events = _router.default.events;\n    coreMethodFields.forEach((field)=>{\n        instance[field] = function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            return scopedRouter[field](...args);\n        };\n    });\n    return instance;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZILDBDQUF5QztJQUNyQ0ksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPQyxRQUFRQyxPQUFPO0lBQzFCO0FBQ0osQ0FBQyxFQUFDO0FBQ0ZQLDhDQUE2QztJQUN6Q0ksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPRyxZQUFZRCxPQUFPO0lBQzlCO0FBQ0osQ0FBQyxFQUFDO0FBQ0ZMLGlCQUFpQixHQUFHTztBQUNwQlAsb0JBQW9CLEdBQUdRO0FBQ3ZCUixnQ0FBZ0MsR0FBR1M7QUFDbkNULGtCQUFlLEdBQUcsS0FBSztBQUN2QixJQUFJVSwyQkFBMkJDLG1KQUErRDtBQUM5RixJQUFJQyxTQUFTRix5QkFBeUJDLG1CQUFPQSxDQUFDLDRDQUFPO0FBQ3JELElBQUlQLFVBQVVNLHlCQUF5QkMsbUJBQU9BLENBQUMseUZBQTZCO0FBQzVFLElBQUlFLGlCQUFpQkYsbUJBQU9BLENBQUMsMkZBQThCO0FBQzNELElBQUlHLFdBQVdKLHlCQUF5QkMsbUJBQU9BLENBQUMsaUVBQWlCO0FBQ2pFLElBQUlMLGNBQWNJLHlCQUF5QkMsbUJBQU9BLENBQUMscUVBQWU7QUFDbEUsTUFBTUksa0JBQWtCO0lBQ3BCQyxRQUFRLElBQUk7SUFDWkMsZ0JBQWdCLEVBQUU7SUFDbEJDLE9BQU9DLEVBQUUsRUFBRTtRQUNQLElBQUksSUFBSSxDQUFDSCxNQUFNLEVBQUUsT0FBT0c7UUFDeEIsSUFBSSxJQUFrQixFQUFhO1lBQy9CLElBQUksQ0FBQ0YsY0FBYyxDQUFDRyxJQUFJLENBQUNEO1FBQzdCLENBQUM7SUFDTDtBQUNKO0FBQ0EsNEVBQTRFO0FBQzVFLE1BQU1FLG9CQUFvQjtJQUN0QjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJ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SSxPQUFPd0IsWUFBWSxDQUFDRSxTQUFTLEtBQUssVUFBVTtZQUM1Q0QsUUFBUSxDQUFDQyxTQUFTLEdBQUdqRCxPQUFPa0QsTUFBTSxDQUFDQyxNQUFNQyxPQUFPLENBQUNMLFlBQVksQ0FBQ0UsU0FBUyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRUYsWUFBWSxDQUFDRSxTQUFTLEVBQUUsbUNBQW1DOztZQUUvSSxRQUFTO1FBQ2IsQ0FBQztRQUNERCxRQUFRLENBQUNDLFNBQVMsR0FBR0YsWUFBWSxDQUFDRSxTQUFTO0lBQy9DO0lBQ0EsaUdBQWlHO0lBQ2pHRCxTQUFTdEIsTUFBTSxHQUFHcEIsUUFBUUMsT0FBTyxDQUFDbUIsTUFBTTtJQUN4Q0QsaUJBQWlCSyxPQUFPLENBQUMsQ0FBQ0MsUUFBUTtRQUM5QmlCLFFBQVEsQ0FBQ2pCLE1BQU0sR0FBRyxXQUFXOzZDQUFQQztnQkFBQUE7O1lBQ2xCLE9BQU9lLFlBQVksQ0FBQ2hCLE1BQU0sSUFBSUM7UUFDbEM7SUFDSjtJQUNBLE9BQU9nQjtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU85QyxRQUFRSyxPQUFPLEtBQUssY0FBZSxPQUFPTCxRQUFRSyxPQUFPLEtBQUssWUFBWUwsUUFBUUssT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTCxRQUFRSyxPQUFPLENBQUM4QyxVQUFVLEtBQUssYUFBYTtJQUNyS3JELE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUssT0FBTyxFQUFFLGNBQWM7UUFBRUosT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9rRCxNQUFNLENBQUNoRCxRQUFRSyxPQUFPLEVBQUVMO0lBQy9Cb0QsT0FBT3BELE9BQU8sR0FBR0EsUUFBUUssT0FBTztBQUNsQyxDQUFDLENBRUQsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JvdXRlci5qcz8zMWZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICAgIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSb3V0ZXJcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9yb3V0ZXIuZGVmYXVsdDtcclxuICAgIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndpdGhSb3V0ZXJcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF93aXRoUm91dGVyLmRlZmF1bHQ7XHJcbiAgICB9XHJcbn0pO1xyXG5leHBvcnRzLnVzZVJvdXRlciA9IHVzZVJvdXRlcjtcclxuZXhwb3J0cy5jcmVhdGVSb3V0ZXIgPSBjcmVhdGVSb3V0ZXI7XHJcbmV4cG9ydHMubWFrZVB1YmxpY1JvdXRlckluc3RhbmNlID0gbWFrZVB1YmxpY1JvdXRlckluc3RhbmNlO1xyXG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XHJcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX3JvdXRlciA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyXCIpKTtcclxudmFyIF9yb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHRcIik7XHJcbnZhciBfaXNFcnJvciA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi4vbGliL2lzLWVycm9yXCIpKTtcclxudmFyIF93aXRoUm91dGVyID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCIuL3dpdGgtcm91dGVyXCIpKTtcclxuY29uc3Qgc2luZ2xldG9uUm91dGVyID0ge1xyXG4gICAgcm91dGVyOiBudWxsLFxyXG4gICAgcmVhZHlDYWxsYmFja3M6IFtdLFxyXG4gICAgcmVhZHkgKGNiKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucm91dGVyKSByZXR1cm4gY2IoKTtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWFkeUNhbGxiYWNrcy5wdXNoKGNiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8vIENyZWF0ZSBwdWJsaWMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBvZiB0aGUgcm91dGVyIGluIHRoZSBzaW5nbGV0b25Sb3V0ZXJcclxuY29uc3QgdXJsUHJvcGVydHlGaWVsZHMgPSBbXHJcbiAgICAncGF0aG5hbWUnLFxyXG4gICAgJ3JvdXRlJyxcclxuICAgICdxdWVyeScsXHJcbiAgICAnYXNQYXRoJyxcclxuICAgICdjb21wb25lbnRzJyxcclxuICAgICdpc0ZhbGxiYWNrJyxcclxuICAgICdiYXNlUGF0aCcsXHJcbiAgICAnbG9jYWxlJyxcclxuICAgICdsb2NhbGVzJyxcclxuICAgICdkZWZhdWx0TG9jYWxlJyxcclxuICAgICdpc1JlYWR5JyxcclxuICAgICdpc1ByZXZpZXcnLFxyXG4gICAgJ2lzTG9jYWxlRG9tYWluJyxcclxuICAgICdkb21haW5Mb2NhbGVzJywgXHJcbl07XHJcbmNvbnN0IHJvdXRlckV2ZW50cyA9IFtcclxuICAgICdyb3V0ZUNoYW5nZVN0YXJ0JyxcclxuICAgICdiZWZvcmVIaXN0b3J5Q2hhbmdlJyxcclxuICAgICdyb3V0ZUNoYW5nZUNvbXBsZXRlJyxcclxuICAgICdyb3V0ZUNoYW5nZUVycm9yJyxcclxuICAgICdoYXNoQ2hhbmdlU3RhcnQnLFxyXG4gICAgJ2hhc2hDaGFuZ2VDb21wbGV0ZScsIFxyXG5dO1xyXG5jb25zdCBjb3JlTWV0aG9kRmllbGRzID0gW1xyXG4gICAgJ3B1c2gnLFxyXG4gICAgJ3JlcGxhY2UnLFxyXG4gICAgJ3JlbG9hZCcsXHJcbiAgICAnYmFjaycsXHJcbiAgICAncHJlZmV0Y2gnLFxyXG4gICAgJ2JlZm9yZVBvcFN0YXRlJywgXHJcbl07XHJcbi8vIEV2ZW50cyBpcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiB0aGUgcm91dGVyLCB0aGUgcm91dGVyIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbml0aWFsaXplZCB0byB1c2UgaXRcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpbmdsZXRvblJvdXRlciwgJ2V2ZW50cycsIHtcclxuICAgIGdldCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9yb3V0ZXIuZGVmYXVsdC5ldmVudHM7XHJcbiAgICB9XHJcbn0pO1xyXG5mdW5jdGlvbiBnZXRSb3V0ZXIoKSB7XHJcbiAgICBpZiAoIXNpbmdsZXRvblJvdXRlci5yb3V0ZXIpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ05vIHJvdXRlciBpbnN0YW5jZSBmb3VuZC5cXG4nICsgJ1lvdSBzaG91bGQgb25seSB1c2UgXCJuZXh0L3JvdXRlclwiIG9uIHRoZSBjbGllbnQgc2lkZSBvZiB5b3VyIGFwcC5cXG4nO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzaW5nbGV0b25Sb3V0ZXIucm91dGVyO1xyXG59XHJcbnVybFByb3BlcnR5RmllbGRzLmZvckVhY2goKGZpZWxkKT0+e1xyXG4gICAgLy8gSGVyZSB3ZSBuZWVkIHRvIHVzZSBPYmplY3QuZGVmaW5lUHJvcGVydHkgYmVjYXVzZSB3ZSBuZWVkIHRvIHJldHVyblxyXG4gICAgLy8gdGhlIHByb3BlcnR5IGFzc2lnbmVkIHRvIHRoZSBhY3R1YWwgcm91dGVyXHJcbiAgICAvLyBUaGUgdmFsdWUgbWlnaHQgZ2V0IGNoYW5nZWQgYXMgd2UgY2hhbmdlIHJvdXRlcyBhbmQgdGhpcyBpcyB0aGVcclxuICAgIC8vIHByb3BlciB3YXkgdG8gYWNjZXNzIGl0XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2luZ2xldG9uUm91dGVyLCBmaWVsZCwge1xyXG4gICAgICAgIGdldCAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlciA9IGdldFJvdXRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcm91dGVyW2ZpZWxkXTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufSk7XHJcbmNvcmVNZXRob2RGaWVsZHMuZm9yRWFjaCgoZmllbGQpPT57XHJcbiAgICBzaW5nbGV0b25Sb3V0ZXJbZmllbGRdID0gKC4uLmFyZ3MpPT57XHJcbiAgICAgICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCk7XHJcbiAgICAgICAgcmV0dXJuIHJvdXRlcltmaWVsZF0oLi4uYXJncyk7XHJcbiAgICB9O1xyXG59KTtcclxucm91dGVyRXZlbnRzLmZvckVhY2goKGV2ZW50KT0+e1xyXG4gICAgc2luZ2xldG9uUm91dGVyLnJlYWR5KCgpPT57XHJcbiAgICAgICAgX3JvdXRlci5kZWZhdWx0LmV2ZW50cy5vbihldmVudCwgKC4uLmFyZ3MpPT57XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50RmllbGQgPSBgb24ke2V2ZW50LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7ZXZlbnQuc3Vic3RyaW5nKDEpfWA7XHJcbiAgICAgICAgICAgIGNvbnN0IF9zaW5nbGV0b25Sb3V0ZXIgPSBzaW5nbGV0b25Sb3V0ZXI7XHJcbiAgICAgICAgICAgIGlmIChfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zaW5nbGV0b25Sb3V0ZXJbZXZlbnRGaWVsZF0oLi4uYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aGVuIHJ1bm5pbmcgdGhlIFJvdXRlciBldmVudDogJHtldmVudEZpZWxkfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoKDAsIF9pc0Vycm9yKS5kZWZhdWx0KGVycikgPyBgJHtlcnIubWVzc2FnZX1cXG4ke2Vyci5zdGFja31gIDogZXJyICsgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufSk7XHJcbnZhciBfZGVmYXVsdCA9IHNpbmdsZXRvblJvdXRlcjtcclxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XHJcbmZ1bmN0aW9uIHVzZVJvdXRlcigpIHtcclxuICAgIGNvbnN0IHJvdXRlciA9IF9yZWFjdC5kZWZhdWx0LnVzZUNvbnRleHQoX3JvdXRlckNvbnRleHQuUm91dGVyQ29udGV4dCk7XHJcbiAgICBpZiAoIXJvdXRlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3I6IE5leHRSb3V0ZXIgd2FzIG5vdCBtb3VudGVkLiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LXJvdXRlci1ub3QtbW91bnRlZCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJvdXRlcjtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXIoLi4uYXJncykge1xyXG4gICAgc2luZ2xldG9uUm91dGVyLnJvdXRlciA9IG5ldyBfcm91dGVyLmRlZmF1bHQoLi4uYXJncyk7XHJcbiAgICBzaW5nbGV0b25Sb3V0ZXIucmVhZHlDYWxsYmFja3MuZm9yRWFjaCgoY2IpPT5jYigpKTtcclxuICAgIHNpbmdsZXRvblJvdXRlci5yZWFkeUNhbGxiYWNrcyA9IFtdO1xyXG4gICAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXI7XHJcbn1cclxuZnVuY3Rpb24gbWFrZVB1YmxpY1JvdXRlckluc3RhbmNlKHJvdXRlcikge1xyXG4gICAgY29uc3Qgc2NvcGVkUm91dGVyID0gcm91dGVyO1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSB7fTtcclxuICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgdXJsUHJvcGVydHlGaWVsZHMpe1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2NvcGVkUm91dGVyW3Byb3BlcnR5XSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2VbcHJvcGVydHldID0gT2JqZWN0LmFzc2lnbihBcnJheS5pc0FycmF5KHNjb3BlZFJvdXRlcltwcm9wZXJ0eV0pID8gW10gOiB7fSwgc2NvcGVkUm91dGVyW3Byb3BlcnR5XSkgLy8gbWFrZXMgc3VyZSBxdWVyeSBpcyBub3Qgc3RhdGVmdWxcclxuICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2VbcHJvcGVydHldID0gc2NvcGVkUm91dGVyW3Byb3BlcnR5XTtcclxuICAgIH1cclxuICAgIC8vIEV2ZW50cyBpcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiB0aGUgcm91dGVyLCB0aGUgcm91dGVyIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbml0aWFsaXplZCB0byB1c2UgaXRcclxuICAgIGluc3RhbmNlLmV2ZW50cyA9IF9yb3V0ZXIuZGVmYXVsdC5ldmVudHM7XHJcbiAgICBjb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkKT0+e1xyXG4gICAgICAgIGluc3RhbmNlW2ZpZWxkXSA9ICguLi5hcmdzKT0+e1xyXG4gICAgICAgICAgICByZXR1cm4gc2NvcGVkUm91dGVyW2ZpZWxkXSguLi5hcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbn1cclxuXHJcbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XHJcbn1cclxuXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3JvdXRlciIsImRlZmF1bHQiLCJfd2l0aFJvdXRlciIsInVzZVJvdXRlciIsImNyZWF0ZVJvdXRlciIsIm1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZSIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfcmVhY3QiLCJfcm91dGVyQ29udGV4dCIsIl9pc0Vycm9yIiwic2luZ2xldG9uUm91dGVyIiwicm91dGVyIiwicmVhZHlDYWxsYmFja3MiLCJyZWFkeSIsImNiIiwicHVzaCIsInVybFByb3BlcnR5RmllbGRzIiwicm91dGVyRXZlbnRzIiwiY29yZU1ldGhvZEZpZWxkcyIsImV2ZW50cyIsImdldFJvdXRlciIsIm1lc3NhZ2UiLCJFcnJvciIsImZvckVhY2giLCJmaWVsZCIsImFyZ3MiLCJldmVudCIsIm9uIiwiZXZlbnRGaWVsZCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic3Vic3RyaW5nIiwiX3NpbmdsZXRvblJvdXRlciIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsInN0YWNrIiwiX2RlZmF1bHQiLCJ1c2VDb250ZXh0IiwiUm91dGVyQ29udGV4dCIsInNjb3BlZFJvdXRlciIsImluc3RhbmNlIiwicHJvcGVydHkiLCJhc3NpZ24iLCJBcnJheSIsImlzQXJyYXkiLCJfX2VzTW9kdWxlIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/router.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/script.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/script.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use client\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.handleClientScriptLoad = handleClientScriptLoad;\nexports.initScriptLoader = initScriptLoader;\nexports[\"default\"] = void 0;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ \"./node_modules/@swc/helpers/lib/_object_without_properties_loose.js\")[\"default\"]);\nvar _reactDom = _interop_require_default(__webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\"));\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _headManagerContext = __webpack_require__(/*! ../shared/lib/head-manager-context */ \"./node_modules/next/dist/shared/lib/head-manager-context.js\");\nvar _headManager = __webpack_require__(/*! ./head-manager */ \"./node_modules/next/dist/client/head-manager.js\");\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\n\"use client\";\nconst ScriptCache = new Map();\nconst LoadCache = new Set();\nconst ignoreProps = [\n    \"onLoad\",\n    \"onReady\",\n    \"dangerouslySetInnerHTML\",\n    \"children\",\n    \"onError\",\n    \"strategy\"\n];\nconst loadScript = (props)=>{\n    const { src , id , onLoad =()=>{} , onReady =null , dangerouslySetInnerHTML , children =\"\" , strategy =\"afterInteractive\" , onError  } = props;\n    const cacheKey = id || src;\n    // Script has already loaded\n    if (cacheKey && LoadCache.has(cacheKey)) {\n        return;\n    }\n    // Contents of this script are already loading/loaded\n    if (ScriptCache.has(src)) {\n        LoadCache.add(cacheKey);\n        // It is possible that multiple `next/script` components all have same \"src\", but has different \"onLoad\"\n        // This is to make sure the same remote script will only load once, but \"onLoad\" are executed in order\n        ScriptCache.get(src).then(onLoad, onError);\n        return;\n    }\n    /** Execute after the script first loaded */ const afterLoad = ()=>{\n        // Run onReady for the first time after load event\n        if (onReady) {\n            onReady();\n        }\n        // add cacheKey to LoadCache when load successfully\n        LoadCache.add(cacheKey);\n    };\n    const el = document.createElement(\"script\");\n    const loadPromise = new Promise((resolve, reject)=>{\n        el.addEventListener(\"load\", function(e) {\n            resolve();\n            if (onLoad) {\n                onLoad.call(this, e);\n            }\n            afterLoad();\n        });\n        el.addEventListener(\"error\", function(e) {\n            reject(e);\n        });\n    }).catch(function(e) {\n        if (onError) {\n            onError(e);\n        }\n    });\n    if (dangerouslySetInnerHTML) {\n        el.innerHTML = dangerouslySetInnerHTML.__html || \"\";\n        afterLoad();\n    } else if (children) {\n        el.textContent = typeof children === \"string\" ? children : Array.isArray(children) ? children.join(\"\") : \"\";\n        afterLoad();\n    } else if (src) {\n        el.src = src;\n        // do not add cacheKey into LoadCache for remote script here\n        // cacheKey will be added to LoadCache when it is actually loaded (see loadPromise above)\n        ScriptCache.set(src, loadPromise);\n    }\n    for (const [k, value] of Object.entries(props)){\n        if (value === undefined || ignoreProps.includes(k)) {\n            continue;\n        }\n        const attr = _headManager.DOMAttributeNames[k] || k.toLowerCase();\n        el.setAttribute(attr, value);\n    }\n    if (strategy === \"worker\") {\n        el.setAttribute(\"type\", \"text/partytown\");\n    }\n    el.setAttribute(\"data-nscript\", strategy);\n    document.body.appendChild(el);\n};\nfunction handleClientScriptLoad(props) {\n    const { strategy =\"afterInteractive\"  } = props;\n    if (strategy === \"lazyOnload\") {\n        window.addEventListener(\"load\", ()=>{\n            (0, _requestIdleCallback).requestIdleCallback(()=>loadScript(props));\n        });\n    } else {\n        loadScript(props);\n    }\n}\nfunction loadLazyScript(props) {\n    if (document.readyState === \"complete\") {\n        (0, _requestIdleCallback).requestIdleCallback(()=>loadScript(props));\n    } else {\n        window.addEventListener(\"load\", ()=>{\n            (0, _requestIdleCallback).requestIdleCallback(()=>loadScript(props));\n        });\n    }\n}\nfunction addBeforeInteractiveToCache() {\n    const scripts = [\n        ...document.querySelectorAll('[data-nscript=\"beforeInteractive\"]'),\n        ...document.querySelectorAll('[data-nscript=\"beforePageRender\"]')\n    ];\n    scripts.forEach((script)=>{\n        const cacheKey = script.id || script.getAttribute(\"src\");\n        LoadCache.add(cacheKey);\n    });\n}\nfunction initScriptLoader(scriptLoaderItems) {\n    scriptLoaderItems.forEach(handleClientScriptLoad);\n    addBeforeInteractiveToCache();\n}\nfunction Script(props) {\n    _s();\n    const { id , src =\"\" , onLoad =()=>{} , onReady =null , strategy =\"afterInteractive\" , onError  } = props, restProps = _object_without_properties_loose(props, [\n        \"id\",\n        \"src\",\n        \"onLoad\",\n        \"onReady\",\n        \"strategy\",\n        \"onError\"\n    ]);\n    // Context is available only during SSR\n    const { updateScripts , scripts , getIsSsr , appDir , nonce  } = (0, _react).useContext(_headManagerContext.HeadManagerContext);\n    /**\r\n   * - First mount:\r\n   *   1. The useEffect for onReady executes\r\n   *   2. hasOnReadyEffectCalled.current is false, but the script hasn't loaded yet (not in LoadCache)\r\n   *      onReady is skipped, set hasOnReadyEffectCalled.current to true\r\n   *   3. The useEffect for loadScript executes\r\n   *   4. hasLoadScriptEffectCalled.current is false, loadScript executes\r\n   *      Once the script is loaded, the onLoad and onReady will be called by then\r\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\r\n   *   5. The useEffect for onReady executes again\r\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\r\n   *   7. The useEffect for loadScript executes again\r\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\r\n   *\r\n   * - Second mount:\r\n   *   1. The useEffect for onReady executes\r\n   *   2. hasOnReadyEffectCalled.current is false, but the script has already loaded (found in LoadCache)\r\n   *      onReady is called, set hasOnReadyEffectCalled.current to true\r\n   *   3. The useEffect for loadScript executes\r\n   *   4. The script is already loaded, loadScript bails out\r\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\r\n   *   5. The useEffect for onReady executes again\r\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\r\n   *   7. The useEffect for loadScript executes again\r\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\r\n   */ const hasOnReadyEffectCalled = (0, _react).useRef(false);\n    (0, _react).useEffect(()=>{\n        const cacheKey = id || src;\n        if (!hasOnReadyEffectCalled.current) {\n            // Run onReady if script has loaded before but component is re-mounted\n            if (onReady && cacheKey && LoadCache.has(cacheKey)) {\n                onReady();\n            }\n            hasOnReadyEffectCalled.current = true;\n        }\n    }, [\n        onReady,\n        id,\n        src\n    ]);\n    const hasLoadScriptEffectCalled = (0, _react).useRef(false);\n    (0, _react).useEffect(()=>{\n        if (!hasLoadScriptEffectCalled.current) {\n            if (strategy === \"afterInteractive\") {\n                loadScript(props);\n            } else if (strategy === \"lazyOnload\") {\n                loadLazyScript(props);\n            }\n            hasLoadScriptEffectCalled.current = true;\n        }\n    }, [\n        props,\n        strategy\n    ]);\n    if (strategy === \"beforeInteractive\" || strategy === \"worker\") {\n        if (updateScripts) {\n            scripts[strategy] = (scripts[strategy] || []).concat([\n                _extends({\n                    id,\n                    src,\n                    onLoad,\n                    onReady,\n                    onError\n                }, restProps)\n            ]);\n            updateScripts(scripts);\n        } else if (getIsSsr && getIsSsr()) {\n            // Script has already loaded during SSR\n            LoadCache.add(id || src);\n        } else if (getIsSsr && !getIsSsr()) {\n            loadScript(props);\n        }\n    }\n    // For the app directory, we need React Float to preload these scripts.\n    if (appDir) {\n        // Before interactive scripts need to be loaded by Next.js' runtime instead\n        // of native <script> tags, because they no longer have `defer`.\n        if (strategy === \"beforeInteractive\") {\n            if (!src) {\n                // For inlined scripts, we put the content in `children`.\n                if (restProps.dangerouslySetInnerHTML) {\n                    restProps.children = restProps.dangerouslySetInnerHTML.__html;\n                    delete restProps.dangerouslySetInnerHTML;\n                }\n                return /*#__PURE__*/ _react.default.createElement(\"script\", {\n                    nonce: nonce,\n                    dangerouslySetInnerHTML: {\n                        __html: \"(self.__next_s=self.__next_s||[]).push(\".concat(JSON.stringify([\n                            0,\n                            _extends({}, restProps)\n                        ]), \")\")\n                    }\n                });\n            }\n            // @ts-ignore\n            _reactDom.default.preload(src, restProps.integrity ? {\n                as: \"script\",\n                integrity: restProps.integrity\n            } : {\n                as: \"script\"\n            });\n            return /*#__PURE__*/ _react.default.createElement(\"script\", {\n                nonce: nonce,\n                dangerouslySetInnerHTML: {\n                    __html: \"(self.__next_s=self.__next_s||[]).push(\".concat(JSON.stringify([\n                        src\n                    ]), \")\")\n                }\n            });\n        } else if (strategy === \"afterInteractive\") {\n            if (src) {\n                // @ts-ignore\n                _reactDom.default.preload(src, restProps.integrity ? {\n                    as: \"script\",\n                    integrity: restProps.integrity\n                } : {\n                    as: \"script\"\n                });\n            }\n        }\n    }\n    return null;\n}\n_s(Script, \"DhDg2Zc8aDaIY/opmpZUJ4ZZRaA=\");\n_c = Script;\nObject.defineProperty(Script, \"__nextScript\", {\n    value: true\n});\nvar _default = Script;\nexports[\"default\"] = _default;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=script.js.map\nvar _c;\n$RefreshReg$(_c, \"Script\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9zY3JpcHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQ2E7O0FBRGI7QUFFQUEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsOEJBQThCLEdBQUdFO0FBQ2pDRix3QkFBd0IsR0FBR0c7QUFDM0JILGtCQUFlLEdBQUcsS0FBSztBQUN2QixJQUFJSyxXQUFXQyxtSEFBK0M7QUFDOUQsSUFBSUMsMkJBQTJCRCxtSkFBK0Q7QUFDOUYsSUFBSUUsNEJBQTRCRixxSkFBZ0U7QUFDaEcsSUFBSUcsbUNBQW1DSCxtS0FBdUU7QUFDOUcsSUFBSUksWUFBWUgseUJBQXlCRCxtQkFBT0EsQ0FBQyxvREFBVztBQUM1RCxJQUFJSyxTQUFTSCwwQkFBMEJGLG1CQUFPQSxDQUFDLDRDQUFPO0FBQ3RELElBQUlNLHNCQUFzQk4sbUJBQU9BLENBQUMsdUdBQW9DO0FBQ3RFLElBQUlPLGVBQWVQLG1CQUFPQSxDQUFDLHVFQUFnQjtBQUMzQyxJQUFJUSx1QkFBdUJSLG1CQUFPQSxDQUFDLHlGQUF5QjtBQUM1RDtBQUNBLE1BQU1TLGNBQWMsSUFBSUM7QUFDeEIsTUFBTUMsWUFBWSxJQUFJQztBQUN0QixNQUFNQyxjQUFjO0lBQ2hCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsTUFBTUMsYUFBYSxDQUFDQyxRQUFRO0lBQ3hCLE1BQU0sRUFBRUMsSUFBRyxFQUFHQyxHQUFFLEVBQUdDLFFBQVEsSUFBSSxDQUFDLEVBQUMsRUFBR0MsU0FBUyxJQUFJLEdBQUdDLHdCQUF1QixFQUFHQyxVQUFVLEdBQUUsRUFBR0MsVUFBVSxtQkFBa0IsRUFBR0MsUUFBTyxFQUFLLEdBQUdSO0lBQzNJLE1BQU1TLFdBQVdQLE1BQU1EO0lBQ3ZCLDRCQUE0QjtJQUM1QixJQUFJUSxZQUFZYixVQUFVYyxHQUFHLENBQUNELFdBQVc7UUFDckM7SUFDSixDQUFDO0lBQ0QscURBQXFEO0lBQ3JELElBQUlmLFlBQVlnQixHQUFHLENBQUNULE1BQU07UUFDdEJMLFVBQVVlLEdBQUcsQ0FBQ0Y7UUFDZCx3R0FBd0c7UUFDeEcsc0dBQXNHO1FBQ3RHZixZQUFZa0IsR0FBRyxDQUFDWCxLQUFLWSxJQUFJLENBQUNWLFFBQVFLO1FBQ2xDO0lBQ0osQ0FBQztJQUNELDBDQUEwQyxHQUFHLE1BQU1NLFlBQVksSUFBSTtRQUMvRCxrREFBa0Q7UUFDbEQsSUFBSVYsU0FBUztZQUNUQTtRQUNKLENBQUM7UUFDRCxtREFBbUQ7UUFDbkRSLFVBQVVlLEdBQUcsQ0FBQ0Y7SUFDbEI7SUFDQSxNQUFNTSxLQUFLQyxTQUFTQyxhQUFhLENBQUM7SUFDbEMsTUFBTUMsY0FBYyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDLFNBQVM7UUFDL0NOLEdBQUdPLGdCQUFnQixDQUFDLFFBQVEsU0FBU0MsQ0FBQyxFQUFFO1lBQ3BDSDtZQUNBLElBQUlqQixRQUFRO2dCQUNSQSxPQUFPcUIsSUFBSSxDQUFDLElBQUksRUFBRUQ7WUFDdEIsQ0FBQztZQUNEVDtRQUNKO1FBQ0FDLEdBQUdPLGdCQUFnQixDQUFDLFNBQVMsU0FBU0MsQ0FBQyxFQUFFO1lBQ3JDRixPQUFPRTtRQUNYO0lBQ0osR0FBR0UsS0FBSyxDQUFDLFNBQVNGLENBQUMsRUFBRTtRQUNqQixJQUFJZixTQUFTO1lBQ1RBLFFBQVFlO1FBQ1osQ0FBQztJQUNMO0lBQ0EsSUFBSWxCLHlCQUF5QjtRQUN6QlUsR0FBR1csU0FBUyxHQUFHckIsd0JBQXdCc0IsTUFBTSxJQUFJO1FBQ2pEYjtJQUNKLE9BQU8sSUFBSVIsVUFBVTtRQUNqQlMsR0FBR2EsV0FBVyxHQUFHLE9BQU90QixhQUFhLFdBQVdBLFdBQVd1QixNQUFNQyxPQUFPLENBQUN4QixZQUFZQSxTQUFTeUIsSUFBSSxDQUFDLE1BQU0sRUFBRTtRQUMzR2pCO0lBQ0osT0FBTyxJQUFJYixLQUFLO1FBQ1pjLEdBQUdkLEdBQUcsR0FBR0E7UUFDVCw0REFBNEQ7UUFDNUQseUZBQXlGO1FBQ3pGUCxZQUFZc0MsR0FBRyxDQUFDL0IsS0FBS2lCO0lBQ3pCLENBQUM7SUFDRCxLQUFLLE1BQU0sQ0FBQ2UsR0FBR3JELE1BQU0sSUFBSUgsT0FBT3lELE9BQU8sQ0FBQ2xDLE9BQU87UUFDM0MsSUFBSXBCLFVBQVV1RCxhQUFhckMsWUFBWXNDLFFBQVEsQ0FBQ0gsSUFBSTtZQUNoRCxRQUFTO1FBQ2IsQ0FBQztRQUNELE1BQU1JLE9BQU83QyxhQUFhOEMsaUJBQWlCLENBQUNMLEVBQUUsSUFBSUEsRUFBRU0sV0FBVztRQUMvRHhCLEdBQUd5QixZQUFZLENBQUNILE1BQU16RDtJQUMxQjtJQUNBLElBQUkyQixhQUFhLFVBQVU7UUFDdkJRLEdBQUd5QixZQUFZLENBQUMsUUFBUTtJQUM1QixDQUFDO0lBQ0R6QixHQUFHeUIsWUFBWSxDQUFDLGdCQUFnQmpDO0lBQ2hDUyxTQUFTeUIsSUFBSSxDQUFDQyxXQUFXLENBQUMzQjtBQUM5QjtBQUNBLFNBQVNsQyx1QkFBdUJtQixLQUFLLEVBQUU7SUFDbkMsTUFBTSxFQUFFTyxVQUFVLG1CQUFrQixFQUFHLEdBQUdQO0lBQzFDLElBQUlPLGFBQWEsY0FBYztRQUMzQm9DLE9BQU9yQixnQkFBZ0IsQ0FBQyxRQUFRLElBQUk7WUFDL0IsSUFBRzdCLG9CQUFvQixFQUFFbUQsbUJBQW1CLENBQUMsSUFBSTdDLFdBQVdDO1FBQ2pFO0lBQ0osT0FBTztRQUNIRCxXQUFXQztJQUNmLENBQUM7QUFDTDtBQUNBLFNBQVM2QyxlQUFlN0MsS0FBSyxFQUFFO0lBQzNCLElBQUlnQixTQUFTOEIsVUFBVSxLQUFLLFlBQVk7UUFDbkMsSUFBR3JELG9CQUFvQixFQUFFbUQsbUJBQW1CLENBQUMsSUFBSTdDLFdBQVdDO0lBQ2pFLE9BQU87UUFDSDJDLE9BQU9yQixnQkFBZ0IsQ0FBQyxRQUFRLElBQUk7WUFDL0IsSUFBRzdCLG9CQUFvQixFQUFFbUQsbUJBQW1CLENBQUMsSUFBSTdDLFdBQVdDO1FBQ2pFO0lBQ0osQ0FBQztBQUNMO0FBQ0EsU0FBUytDLDhCQUE4QjtJQUNuQyxNQUFNQyxVQUFVO1dBQ1RoQyxTQUFTaUMsZ0JBQWdCLENBQUM7V0FDMUJqQyxTQUFTaUMsZ0JBQWdCLENBQUM7S0FDaEM7SUFDREQsUUFBUUUsT0FBTyxDQUFDLENBQUNDLFNBQVM7UUFDdEIsTUFBTTFDLFdBQVcwQyxPQUFPakQsRUFBRSxJQUFJaUQsT0FBT0MsWUFBWSxDQUFDO1FBQ2xEeEQsVUFBVWUsR0FBRyxDQUFDRjtJQUNsQjtBQUNKO0FBQ0EsU0FBUzNCLGlCQUFpQnVFLGlCQUFpQixFQUFFO0lBQ3pDQSxrQkFBa0JILE9BQU8sQ0FBQ3JFO0lBQzFCa0U7QUFDSjtBQUNBLFNBQVNPLE9BQU90RCxLQUFLLEVBQUU7O0lBQ25CLE1BQU0sRUFBRUUsR0FBRSxFQUFHRCxLQUFLLEdBQUUsRUFBR0UsUUFBUSxJQUFJLENBQUMsRUFBQyxFQUFHQyxTQUFTLElBQUksR0FBR0csVUFBVSxtQkFBa0IsRUFBR0MsUUFBTyxFQUFHLEdBQUdSLE9BQU91RCxZQUFZbkUsaUNBQWlDWSxPQUFPO1FBQzNKO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsdUNBQXVDO0lBQ3ZDLE1BQU0sRUFBRXdELGNBQWEsRUFBR1IsUUFBTyxFQUFHUyxTQUFRLEVBQUdDLE9BQU0sRUFBR0MsTUFBSyxFQUFHLEdBQUcsQ0FBQyxHQUFHckUsTUFBTSxFQUFFc0UsVUFBVSxDQUFDckUsb0JBQW9Cc0Usa0JBQWtCO0lBQzlIO0lBMEJDLElBQUd2RSxNQUFNLEVBQUUwRTtRQUNSLE1BQU12RCxXQUFXUCxNQUFNRDtRQUN2QixJQUFJLENBQUM2RCx1QkFBdUJHLE9BQU8sRUFBRTtZQUNqQztZQUNBLElBQUk3RCxXQUFXSyxZQUFZYjtnQkFDdkJRO1lBQ0osQ0FBQztZQUNEMEQsdUJBQXVCRyxPQUFPLEdBQUcsSUFBSTtRQUN6QyxDQUFDO0lBQ0wsR0FBRztRQUNDN0Q7UUFDQUY7O0tBRUg7SUFDRCxNQUFNZ0UsNEJBQTRCLENBQUMsR0FBRzVFO0lBQ3JDLElBQUdBLE1BQU0sRUFBRTBFLFNBQVMsQ0FBQyxJQUFJO1FBQ3RCLElBQUksQ0FBQ0UsMEJBQTBCRCxPQUFPLEVBQUU7WUFDcEMsSUFBSTFELGFBQWE7Z0JBQ2JSLFdBQVdDO1lBQ2YsT0FBTyxJQUFJTyxhQUFhLGNBQWM7Z0JBQ2xDc0MsZUFBZTdDO1lBQ25CLENBQUM7WUFDRGtFLDBCQUEwQkQsT0FBTyxHQUFHLElBQUk7UUFDNUMsQ0FBQztJQUNMLEdBQUc7UUFDQ2pFO1FBQ0FPO0tBQ0g7SUFDRCxJQUFJQSxhQUFhLHVCQUF1QkEsYUFBYSxVQUFVO1FBQzNELElBQUlpRCxlQUFlO1lBQ2ZSLE9BQU8sQ0FBQ3pDOztvQkFFQUw7Ozs7Ozs7WUFPUnNELGNBQWNSO1FBQ2xCLE9BQU8sSUFBSVMsWUFBWUE7WUFDbkI7WUFDQTdELFVBQVVlLEdBQUcsQ0FBQ1QsTUFBTUQ7UUFDeEIsT0FBTyxJQUFJd0QsWUFBWSxDQUFDQTtZQUNwQjFELFdBQVdDO1FBQ2YsQ0FBQztJQUNMLENBQUM7SUFDRDtJQUNBLElBQUkwRDtRQUNBO1FBQ0E7UUFDQSxJQUFJbkQ7O2dCQUVJO2dCQUNBLElBQUlnRDtvQkFDQUEsVUFBVWpELFFBQVEsR0FBR2lELFVBQVVsRDtvQkFDL0I7Z0JBQ0osQ0FBQztnQkFDRCxPQUFPO29CQUNIc0QsT0FBT0E7b0JBQ1B0RDt3QkFDSXNCOzRCQUNJOzt5QkFFSCxHQUFFO29CQUNQO2dCQUNKO1lBQ0osQ0FBQztZQUNELGFBQWE7WUFDYnRDLFVBQVVOLE9BQU8sQ0FBQ3VGOzs7WUFHbEIsSUFBSTtnQkFDQUU7WUFDSixDQUFDO1lBQ0QsT0FBTyxXQUFXLEdBQUdsRixPQUFPUCxPQUFPLENBQUNrQyxhQUFhLENBQUMsVUFBVTtnQkFDeEQwQyxPQUFPQTtnQkFDUHREO29CQUNJc0IsUUFBUSwwQ0FFTDt3QkFEQzFCO3FCQUNILEdBQUU7Z0JBQ1A7WUFDSjtRQUNKLE9BQU8sSUFBSU0sYUFBYSxvQkFBb0I7WUFDeEMsSUFBSU4sS0FBSztnQkFDTCxhQUFhO2dCQUNiWixVQUFVTixPQUFPLENBQUN1RixPQUFPLENBQUNyRSxLQUFLc0QsVUFBVWdCLFNBQVMsR0FBRztvQkFDakRDLElBQUk7b0JBQ0pELFdBQVdoQixVQUFVZ0IsU0FBUztnQkFDbEMsSUFBSTtvQkFDQUM7Z0JBQ0osQ0FBQztZQUNMLENBQUM7UUFDTCxDQUFDO0lBQ0wsQ0FBQztJQUNELE9BQU8sSUFBSTtBQUNmO0dBcklTbEI7S0FBQUE7QUFzSVQ3RSxPQUFPQztJQUNIRSxPQUFPLElBQUk7QUFDZjtBQUNBLElBQUk2RixXQUFXbkI7QUFDZjNFLFFBQVFJLE9BQU8sR0FBRzBGO0FBRWxCLElBQUksQ0FBQyxPQUFPOUYsUUFBUUksT0FBTztJQUN6Qk4sT0FBT0MsY0FBYyxDQUFDQztRQUFpQ0MsT0FBTztJQUFLO0lBQ25FSCxPQUFPa0csTUFBTSxDQUFDaEcsUUFBUUksT0FBTyxFQUFFSjtJQUMvQmlHLE9BQU9qRyxPQUFPLEdBQUdBO0FBQ25CLENBQUMsQ0FFRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9zY3JpcHQuanM/YmQ2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gICAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCA9IGhhbmRsZUNsaWVudFNjcmlwdExvYWQ7XHJcbmV4cG9ydHMuaW5pdFNjcmlwdExvYWRlciA9IGluaXRTY3JpcHRMb2FkZXI7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcclxudmFyIF9leHRlbmRzID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2V4dGVuZHMuanNcIikuZGVmYXVsdDtcclxudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xyXG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcclxudmFyIF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UuanNcIikuZGVmYXVsdDtcclxudmFyIF9yZWFjdERvbSA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIF9oZWFkTWFuYWdlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dFwiKTtcclxudmFyIF9oZWFkTWFuYWdlciA9IHJlcXVpcmUoXCIuL2hlYWQtbWFuYWdlclwiKTtcclxudmFyIF9yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWlyZShcIi4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrXCIpO1xyXG4ndXNlIGNsaWVudCc7XHJcbmNvbnN0IFNjcmlwdENhY2hlID0gbmV3IE1hcCgpO1xyXG5jb25zdCBMb2FkQ2FjaGUgPSBuZXcgU2V0KCk7XHJcbmNvbnN0IGlnbm9yZVByb3BzID0gW1xyXG4gICAgJ29uTG9hZCcsXHJcbiAgICAnb25SZWFkeScsXHJcbiAgICAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxyXG4gICAgJ2NoaWxkcmVuJyxcclxuICAgICdvbkVycm9yJyxcclxuICAgICdzdHJhdGVneScsIFxyXG5dO1xyXG5jb25zdCBsb2FkU2NyaXB0ID0gKHByb3BzKT0+e1xyXG4gICAgY29uc3QgeyBzcmMgLCBpZCAsIG9uTG9hZCA9KCk9Pnt9ICwgb25SZWFkeSA9bnVsbCAsIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICwgY2hpbGRyZW4gPScnICwgc3RyYXRlZ3kgPSdhZnRlckludGVyYWN0aXZlJyAsIG9uRXJyb3IgLCAgfSA9IHByb3BzO1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSBpZCB8fCBzcmM7XHJcbiAgICAvLyBTY3JpcHQgaGFzIGFscmVhZHkgbG9hZGVkXHJcbiAgICBpZiAoY2FjaGVLZXkgJiYgTG9hZENhY2hlLmhhcyhjYWNoZUtleSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBDb250ZW50cyBvZiB0aGlzIHNjcmlwdCBhcmUgYWxyZWFkeSBsb2FkaW5nL2xvYWRlZFxyXG4gICAgaWYgKFNjcmlwdENhY2hlLmhhcyhzcmMpKSB7XHJcbiAgICAgICAgTG9hZENhY2hlLmFkZChjYWNoZUtleSk7XHJcbiAgICAgICAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCBtdWx0aXBsZSBgbmV4dC9zY3JpcHRgIGNvbXBvbmVudHMgYWxsIGhhdmUgc2FtZSBcInNyY1wiLCBidXQgaGFzIGRpZmZlcmVudCBcIm9uTG9hZFwiXHJcbiAgICAgICAgLy8gVGhpcyBpcyB0byBtYWtlIHN1cmUgdGhlIHNhbWUgcmVtb3RlIHNjcmlwdCB3aWxsIG9ubHkgbG9hZCBvbmNlLCBidXQgXCJvbkxvYWRcIiBhcmUgZXhlY3V0ZWQgaW4gb3JkZXJcclxuICAgICAgICBTY3JpcHRDYWNoZS5nZXQoc3JjKS50aGVuKG9uTG9hZCwgb25FcnJvcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLyoqIEV4ZWN1dGUgYWZ0ZXIgdGhlIHNjcmlwdCBmaXJzdCBsb2FkZWQgKi8gY29uc3QgYWZ0ZXJMb2FkID0gKCk9PntcclxuICAgICAgICAvLyBSdW4gb25SZWFkeSBmb3IgdGhlIGZpcnN0IHRpbWUgYWZ0ZXIgbG9hZCBldmVudFxyXG4gICAgICAgIGlmIChvblJlYWR5KSB7XHJcbiAgICAgICAgICAgIG9uUmVhZHkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYWRkIGNhY2hlS2V5IHRvIExvYWRDYWNoZSB3aGVuIGxvYWQgc3VjY2Vzc2Z1bGx5XHJcbiAgICAgICAgTG9hZENhY2hlLmFkZChjYWNoZUtleSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcclxuICAgIGNvbnN0IGxvYWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcclxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIGlmIChvbkxvYWQpIHtcclxuICAgICAgICAgICAgICAgIG9uTG9hZC5jYWxsKHRoaXMsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFmdGVyTG9hZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgb25FcnJvcihlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmIChkYW5nZXJvdXNseVNldElubmVySFRNTCkge1xyXG4gICAgICAgIGVsLmlubmVySFRNTCA9IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbCB8fCAnJztcclxuICAgICAgICBhZnRlckxvYWQoKTtcclxuICAgIH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgICBlbC50ZXh0Q29udGVudCA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycgPyBjaGlsZHJlbiA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4uam9pbignJykgOiAnJztcclxuICAgICAgICBhZnRlckxvYWQoKTtcclxuICAgIH0gZWxzZSBpZiAoc3JjKSB7XHJcbiAgICAgICAgZWwuc3JjID0gc3JjO1xyXG4gICAgICAgIC8vIGRvIG5vdCBhZGQgY2FjaGVLZXkgaW50byBMb2FkQ2FjaGUgZm9yIHJlbW90ZSBzY3JpcHQgaGVyZVxyXG4gICAgICAgIC8vIGNhY2hlS2V5IHdpbGwgYmUgYWRkZWQgdG8gTG9hZENhY2hlIHdoZW4gaXQgaXMgYWN0dWFsbHkgbG9hZGVkIChzZWUgbG9hZFByb21pc2UgYWJvdmUpXHJcbiAgICAgICAgU2NyaXB0Q2FjaGUuc2V0KHNyYywgbG9hZFByb21pc2UpO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBbaywgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSl7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgaWdub3JlUHJvcHMuaW5jbHVkZXMoaykpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGF0dHIgPSBfaGVhZE1hbmFnZXIuRE9NQXR0cmlidXRlTmFtZXNba10gfHwgay50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RyYXRlZ3kgPT09ICd3b3JrZXInKSB7XHJcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvcGFydHl0b3duJyk7XHJcbiAgICB9XHJcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbnNjcmlwdCcsIHN0cmF0ZWd5KTtcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xyXG59O1xyXG5mdW5jdGlvbiBoYW5kbGVDbGllbnRTY3JpcHRMb2FkKHByb3BzKSB7XHJcbiAgICBjb25zdCB7IHN0cmF0ZWd5ID0nYWZ0ZXJJbnRlcmFjdGl2ZScgIH0gPSBwcm9wcztcclxuICAgIGlmIChzdHJhdGVneSA9PT0gJ2xhenlPbmxvYWQnKSB7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKT0+e1xyXG4gICAgICAgICAgICAoMCwgX3JlcXVlc3RJZGxlQ2FsbGJhY2spLnJlcXVlc3RJZGxlQ2FsbGJhY2soKCk9PmxvYWRTY3JpcHQocHJvcHMpKTtcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbG9hZFNjcmlwdChwcm9wcyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbG9hZExhenlTY3JpcHQocHJvcHMpIHtcclxuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgKDAsIF9yZXF1ZXN0SWRsZUNhbGxiYWNrKS5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpPT5sb2FkU2NyaXB0KHByb3BzKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCk9PntcclxuICAgICAgICAgICAgKDAsIF9yZXF1ZXN0SWRsZUNhbGxiYWNrKS5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpPT5sb2FkU2NyaXB0KHByb3BzKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkQmVmb3JlSW50ZXJhY3RpdmVUb0NhY2hlKCkge1xyXG4gICAgY29uc3Qgc2NyaXB0cyA9IFtcclxuICAgICAgICAuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1uc2NyaXB0PVwiYmVmb3JlSW50ZXJhY3RpdmVcIl0nKSxcclxuICAgICAgICAuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1uc2NyaXB0PVwiYmVmb3JlUGFnZVJlbmRlclwiXScpLCBcclxuICAgIF07XHJcbiAgICBzY3JpcHRzLmZvckVhY2goKHNjcmlwdCk9PntcclxuICAgICAgICBjb25zdCBjYWNoZUtleSA9IHNjcmlwdC5pZCB8fCBzY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcclxuICAgICAgICBMb2FkQ2FjaGUuYWRkKGNhY2hlS2V5KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRTY3JpcHRMb2FkZXIoc2NyaXB0TG9hZGVySXRlbXMpIHtcclxuICAgIHNjcmlwdExvYWRlckl0ZW1zLmZvckVhY2goaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCk7XHJcbiAgICBhZGRCZWZvcmVJbnRlcmFjdGl2ZVRvQ2FjaGUoKTtcclxufVxyXG5mdW5jdGlvbiBTY3JpcHQocHJvcHMpIHtcclxuICAgIGNvbnN0IHsgaWQgLCBzcmMgPScnICwgb25Mb2FkID0oKT0+e30gLCBvblJlYWR5ID1udWxsICwgc3RyYXRlZ3kgPSdhZnRlckludGVyYWN0aXZlJyAsIG9uRXJyb3IgIH0gPSBwcm9wcywgcmVzdFByb3BzID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UocHJvcHMsIFtcclxuICAgICAgICBcImlkXCIsXHJcbiAgICAgICAgXCJzcmNcIixcclxuICAgICAgICBcIm9uTG9hZFwiLFxyXG4gICAgICAgIFwib25SZWFkeVwiLFxyXG4gICAgICAgIFwic3RyYXRlZ3lcIixcclxuICAgICAgICBcIm9uRXJyb3JcIlxyXG4gICAgXSk7XHJcbiAgICAvLyBDb250ZXh0IGlzIGF2YWlsYWJsZSBvbmx5IGR1cmluZyBTU1JcclxuICAgIGNvbnN0IHsgdXBkYXRlU2NyaXB0cyAsIHNjcmlwdHMgLCBnZXRJc1NzciAsIGFwcERpciAsIG5vbmNlICB9ID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfaGVhZE1hbmFnZXJDb250ZXh0LkhlYWRNYW5hZ2VyQ29udGV4dCk7XHJcbiAgICAvKipcclxuICAgKiAtIEZpcnN0IG1vdW50OlxyXG4gICAqICAgMS4gVGhlIHVzZUVmZmVjdCBmb3Igb25SZWFkeSBleGVjdXRlc1xyXG4gICAqICAgMi4gaGFzT25SZWFkeUVmZmVjdENhbGxlZC5jdXJyZW50IGlzIGZhbHNlLCBidXQgdGhlIHNjcmlwdCBoYXNuJ3QgbG9hZGVkIHlldCAobm90IGluIExvYWRDYWNoZSlcclxuICAgKiAgICAgIG9uUmVhZHkgaXMgc2tpcHBlZCwgc2V0IGhhc09uUmVhZHlFZmZlY3RDYWxsZWQuY3VycmVudCB0byB0cnVlXHJcbiAgICogICAzLiBUaGUgdXNlRWZmZWN0IGZvciBsb2FkU2NyaXB0IGV4ZWN1dGVzXHJcbiAgICogICA0LiBoYXNMb2FkU2NyaXB0RWZmZWN0Q2FsbGVkLmN1cnJlbnQgaXMgZmFsc2UsIGxvYWRTY3JpcHQgZXhlY3V0ZXNcclxuICAgKiAgICAgIE9uY2UgdGhlIHNjcmlwdCBpcyBsb2FkZWQsIHRoZSBvbkxvYWQgYW5kIG9uUmVhZHkgd2lsbCBiZSBjYWxsZWQgYnkgdGhlblxyXG4gICAqICAgW0lmIHN0cmljdCBtb2RlIGlzIGVuYWJsZWQgLyBpcyB3cmFwcGVkIGluIDxPZmZTY3JlZW4gLz4gY29tcG9uZW50XVxyXG4gICAqICAgNS4gVGhlIHVzZUVmZmVjdCBmb3Igb25SZWFkeSBleGVjdXRlcyBhZ2FpblxyXG4gICAqICAgNi4gaGFzT25SZWFkeUVmZmVjdENhbGxlZC5jdXJyZW50IGlzIHRydWUsIHNvIGVudGlyZSBlZmZlY3QgaXMgc2tpcHBlZFxyXG4gICAqICAgNy4gVGhlIHVzZUVmZmVjdCBmb3IgbG9hZFNjcmlwdCBleGVjdXRlcyBhZ2FpblxyXG4gICAqICAgOC4gaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZC5jdXJyZW50IGlzIHRydWUsIHNvIGVudGlyZSBlZmZlY3QgaXMgc2tpcHBlZFxyXG4gICAqXHJcbiAgICogLSBTZWNvbmQgbW91bnQ6XHJcbiAgICogICAxLiBUaGUgdXNlRWZmZWN0IGZvciBvblJlYWR5IGV4ZWN1dGVzXHJcbiAgICogICAyLiBoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQgaXMgZmFsc2UsIGJ1dCB0aGUgc2NyaXB0IGhhcyBhbHJlYWR5IGxvYWRlZCAoZm91bmQgaW4gTG9hZENhY2hlKVxyXG4gICAqICAgICAgb25SZWFkeSBpcyBjYWxsZWQsIHNldCBoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQgdG8gdHJ1ZVxyXG4gICAqICAgMy4gVGhlIHVzZUVmZmVjdCBmb3IgbG9hZFNjcmlwdCBleGVjdXRlc1xyXG4gICAqICAgNC4gVGhlIHNjcmlwdCBpcyBhbHJlYWR5IGxvYWRlZCwgbG9hZFNjcmlwdCBiYWlscyBvdXRcclxuICAgKiAgIFtJZiBzdHJpY3QgbW9kZSBpcyBlbmFibGVkIC8gaXMgd3JhcHBlZCBpbiA8T2ZmU2NyZWVuIC8+IGNvbXBvbmVudF1cclxuICAgKiAgIDUuIFRoZSB1c2VFZmZlY3QgZm9yIG9uUmVhZHkgZXhlY3V0ZXMgYWdhaW5cclxuICAgKiAgIDYuIGhhc09uUmVhZHlFZmZlY3RDYWxsZWQuY3VycmVudCBpcyB0cnVlLCBzbyBlbnRpcmUgZWZmZWN0IGlzIHNraXBwZWRcclxuICAgKiAgIDcuIFRoZSB1c2VFZmZlY3QgZm9yIGxvYWRTY3JpcHQgZXhlY3V0ZXMgYWdhaW5cclxuICAgKiAgIDguIGhhc0xvYWRTY3JpcHRFZmZlY3RDYWxsZWQuY3VycmVudCBpcyB0cnVlLCBzbyBlbnRpcmUgZWZmZWN0IGlzIHNraXBwZWRcclxuICAgKi8gY29uc3QgaGFzT25SZWFkeUVmZmVjdENhbGxlZCA9ICgwLCBfcmVhY3QpLnVzZVJlZihmYWxzZSk7XHJcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcclxuICAgICAgICBjb25zdCBjYWNoZUtleSA9IGlkIHx8IHNyYztcclxuICAgICAgICBpZiAoIWhhc09uUmVhZHlFZmZlY3RDYWxsZWQuY3VycmVudCkge1xyXG4gICAgICAgICAgICAvLyBSdW4gb25SZWFkeSBpZiBzY3JpcHQgaGFzIGxvYWRlZCBiZWZvcmUgYnV0IGNvbXBvbmVudCBpcyByZS1tb3VudGVkXHJcbiAgICAgICAgICAgIGlmIChvblJlYWR5ICYmIGNhY2hlS2V5ICYmIExvYWRDYWNoZS5oYXMoY2FjaGVLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBvblJlYWR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaGFzT25SZWFkeUVmZmVjdENhbGxlZC5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbXHJcbiAgICAgICAgb25SZWFkeSxcclxuICAgICAgICBpZCxcclxuICAgICAgICBzcmNcclxuICAgIF0pO1xyXG4gICAgY29uc3QgaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZCA9ICgwLCBfcmVhY3QpLnVzZVJlZihmYWxzZSk7XHJcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcclxuICAgICAgICBpZiAoIWhhc0xvYWRTY3JpcHRFZmZlY3RDYWxsZWQuY3VycmVudCkge1xyXG4gICAgICAgICAgICBpZiAoc3RyYXRlZ3kgPT09ICdhZnRlckludGVyYWN0aXZlJykge1xyXG4gICAgICAgICAgICAgICAgbG9hZFNjcmlwdChwcm9wcyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyYXRlZ3kgPT09ICdsYXp5T25sb2FkJykge1xyXG4gICAgICAgICAgICAgICAgbG9hZExhenlTY3JpcHQocHJvcHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhhc0xvYWRTY3JpcHRFZmZlY3RDYWxsZWQuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW1xyXG4gICAgICAgIHByb3BzLFxyXG4gICAgICAgIHN0cmF0ZWd5XHJcbiAgICBdKTtcclxuICAgIGlmIChzdHJhdGVneSA9PT0gJ2JlZm9yZUludGVyYWN0aXZlJyB8fCBzdHJhdGVneSA9PT0gJ3dvcmtlcicpIHtcclxuICAgICAgICBpZiAodXBkYXRlU2NyaXB0cykge1xyXG4gICAgICAgICAgICBzY3JpcHRzW3N0cmF0ZWd5XSA9IChzY3JpcHRzW3N0cmF0ZWd5XSB8fCBbXSkuY29uY2F0KFtcclxuICAgICAgICAgICAgICAgIF9leHRlbmRzKHtcclxuICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICBzcmMsXHJcbiAgICAgICAgICAgICAgICAgICAgb25Mb2FkLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uUmVhZHksXHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvclxyXG4gICAgICAgICAgICAgICAgfSwgcmVzdFByb3BzKSwgXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB1cGRhdGVTY3JpcHRzKHNjcmlwdHMpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZ2V0SXNTc3IgJiYgZ2V0SXNTc3IoKSkge1xyXG4gICAgICAgICAgICAvLyBTY3JpcHQgaGFzIGFscmVhZHkgbG9hZGVkIGR1cmluZyBTU1JcclxuICAgICAgICAgICAgTG9hZENhY2hlLmFkZChpZCB8fCBzcmMpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZ2V0SXNTc3IgJiYgIWdldElzU3NyKCkpIHtcclxuICAgICAgICAgICAgbG9hZFNjcmlwdChwcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gRm9yIHRoZSBhcHAgZGlyZWN0b3J5LCB3ZSBuZWVkIFJlYWN0IEZsb2F0IHRvIHByZWxvYWQgdGhlc2Ugc2NyaXB0cy5cclxuICAgIGlmIChhcHBEaXIpIHtcclxuICAgICAgICAvLyBCZWZvcmUgaW50ZXJhY3RpdmUgc2NyaXB0cyBuZWVkIHRvIGJlIGxvYWRlZCBieSBOZXh0LmpzJyBydW50aW1lIGluc3RlYWRcclxuICAgICAgICAvLyBvZiBuYXRpdmUgPHNjcmlwdD4gdGFncywgYmVjYXVzZSB0aGV5IG5vIGxvbmdlciBoYXZlIGBkZWZlcmAuXHJcbiAgICAgICAgaWYgKHN0cmF0ZWd5ID09PSAnYmVmb3JlSW50ZXJhY3RpdmUnKSB7XHJcbiAgICAgICAgICAgIGlmICghc3JjKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgaW5saW5lZCBzY3JpcHRzLCB3ZSBwdXQgdGhlIGNvbnRlbnQgaW4gYGNoaWxkcmVuYC5cclxuICAgICAgICAgICAgICAgIGlmIChyZXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN0UHJvcHMuY2hpbGRyZW4gPSByZXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBub25jZTogbm9uY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX19odG1sOiBgKHNlbGYuX19uZXh0X3M9c2VsZi5fX25leHRfc3x8W10pLnB1c2goJHtKU09OLnN0cmluZ2lmeShbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2V4dGVuZHMoe30sIHJlc3RQcm9wcyksIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdKX0pYFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgX3JlYWN0RG9tLmRlZmF1bHQucHJlbG9hZChzcmMsIHJlc3RQcm9wcy5pbnRlZ3JpdHkgPyB7XHJcbiAgICAgICAgICAgICAgICBhczogJ3NjcmlwdCcsXHJcbiAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6IHJlc3RQcm9wcy5pbnRlZ3JpdHlcclxuICAgICAgICAgICAgfSA6IHtcclxuICAgICAgICAgICAgICAgIGFzOiAnc2NyaXB0J1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiLCB7XHJcbiAgICAgICAgICAgICAgICBub25jZTogbm9uY2UsXHJcbiAgICAgICAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xyXG4gICAgICAgICAgICAgICAgICAgIF9faHRtbDogYChzZWxmLl9fbmV4dF9zPXNlbGYuX19uZXh0X3N8fFtdKS5wdXNoKCR7SlNPTi5zdHJpbmdpZnkoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmMsIFxyXG4gICAgICAgICAgICAgICAgICAgIF0pfSlgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3RyYXRlZ3kgPT09ICdhZnRlckludGVyYWN0aXZlJykge1xyXG4gICAgICAgICAgICBpZiAoc3JjKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgICAgICBfcmVhY3REb20uZGVmYXVsdC5wcmVsb2FkKHNyYywgcmVzdFByb3BzLmludGVncml0eSA/IHtcclxuICAgICAgICAgICAgICAgICAgICBhczogJ3NjcmlwdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdyaXR5OiByZXN0UHJvcHMuaW50ZWdyaXR5XHJcbiAgICAgICAgICAgICAgICB9IDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzOiAnc2NyaXB0J1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NyaXB0LCAnX19uZXh0U2NyaXB0Jywge1xyXG4gICAgdmFsdWU6IHRydWVcclxufSk7XHJcbnZhciBfZGVmYXVsdCA9IFNjcmlwdDtcclxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XHJcblxyXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xyXG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xyXG59XHJcblxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3JpcHQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCIsImluaXRTY3JpcHRMb2FkZXIiLCJkZWZhdWx0IiwiX2V4dGVuZHMiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlIiwiX3JlYWN0RG9tIiwiX3JlYWN0IiwiX2hlYWRNYW5hZ2VyQ29udGV4dCIsIl9oZWFkTWFuYWdlciIsIl9yZXF1ZXN0SWRsZUNhbGxiYWNrIiwiU2NyaXB0Q2FjaGUiLCJNYXAiLCJMb2FkQ2FjaGUiLCJTZXQiLCJpZ25vcmVQcm9wcyIsImxvYWRTY3JpcHQiLCJwcm9wcyIsInNyYyIsImlkIiwib25Mb2FkIiwib25SZWFkeSIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiY2hpbGRyZW4iLCJzdHJhdGVneSIsIm9uRXJyb3IiLCJjYWNoZUtleSIsImhhcyIsImFkZCIsImdldCIsInRoZW4iLCJhZnRlckxvYWQiLCJlbCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImxvYWRQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsImNhbGwiLCJjYXRjaCIsImlubmVySFRNTCIsIl9faHRtbCIsInRleHRDb250ZW50IiwiQXJyYXkiLCJpc0FycmF5Iiwiam9pbiIsInNldCIsImsiLCJlbnRyaWVzIiwidW5kZWZpbmVkIiwiaW5jbHVkZXMiLCJhdHRyIiwiRE9NQXR0cmlidXRlTmFtZXMiLCJ0b0xvd2VyQ2FzZSIsInNldEF0dHJpYnV0ZSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsIndpbmRvdyIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJsb2FkTGF6eVNjcmlwdCIsInJlYWR5U3RhdGUiLCJhZGRCZWZvcmVJbnRlcmFjdGl2ZVRvQ2FjaGUiLCJzY3JpcHRzIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJzY3JpcHQiLCJnZXRBdHRyaWJ1dGUiLCJzY3JpcHRMb2FkZXJJdGVtcyIsIlNjcmlwdCIsInJlc3RQcm9wcyIsInVwZGF0ZVNjcmlwdHMiLCJnZXRJc1NzciIsImFwcERpciIsIm5vbmNlIiwidXNlQ29udGV4dCIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsImhhc09uUmVhZHlFZmZlY3RDYWxsZWQiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwiaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZCIsImNvbmNhdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJwcmVsb2FkIiwiaW50ZWdyaXR5IiwiYXMiLCJfZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/script.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/trusted-types.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/client/trusted-types.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.__unsafeCreateTrustedScriptURL = __unsafeCreateTrustedScriptURL;\n/**\r\n * Stores the Trusted Types Policy. Starts as undefined and can be set to null\r\n * if Trusted Types is not supported in the browser.\r\n */ let policy;\n/**\r\n * Getter for the Trusted Types Policy. If it is undefined, it is instantiated\r\n * here or set to null if Trusted Types is not supported in the browser.\r\n */ function getPolicy() {\n    if (typeof policy === \"undefined\" && \"object\" !== \"undefined\") {\n        var ref;\n        policy = ((ref = window.trustedTypes) == null ? void 0 : ref.createPolicy(\"nextjs\", {\n            createHTML: (input)=>input,\n            createScript: (input)=>input,\n            createScriptURL: (input)=>input\n        })) || null;\n    }\n    return policy;\n}\nfunction __unsafeCreateTrustedScriptURL(url) {\n    var ref;\n    return ((ref = getPolicy()) == null ? void 0 : ref.createScriptURL(url)) || url;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=trusted-types.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC90cnVzdGVkLXR5cGVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHNDQUFzQyxHQUFHRTtBQUN6QztBQUlBO0lBSUksSUFBSSxPQUFPQyxXQUFXLGVBQWU7UUFDakMsSUFBSUU7O1lBRUFJLFlBQVksQ0FBQ0MsUUFBUUE7WUFDckJDLGNBQWMsQ0FBQ0QsUUFBUUE7WUFDdkJFO1FBQ0osRUFBRSxLQUFLLElBQUk7SUFDZixDQUFDO0lBQ0QsT0FBT1Q7QUFDWDtBQUNBLFNBQVNELCtCQUErQlc7SUFDcEMsSUFBSVI7SUFDSixPQUFPLENBQUMsQ0FBQ0EsTUFBTUQ7QUFDbkI7QUFFQSxJQUFJLENBQUMsT0FBT0o7O1FBQzZDQyxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2tCLE1BQU0sQ0FBQ2hCLFFBQVFjLE9BQU8sRUFBRWQ7O0FBRWpDLENBQUMsQ0FFRCx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvdHJ1c3RlZC10eXBlcy5qcz9hNDExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICAgIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLl9fdW5zYWZlQ3JlYXRlVHJ1c3RlZFNjcmlwdFVSTCA9IF9fdW5zYWZlQ3JlYXRlVHJ1c3RlZFNjcmlwdFVSTDtcclxuLyoqXHJcbiAqIFN0b3JlcyB0aGUgVHJ1c3RlZCBUeXBlcyBQb2xpY3kuIFN0YXJ0cyBhcyB1bmRlZmluZWQgYW5kIGNhbiBiZSBzZXQgdG8gbnVsbFxyXG4gKiBpZiBUcnVzdGVkIFR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGJyb3dzZXIuXHJcbiAqLyBsZXQgcG9saWN5O1xyXG4vKipcclxuICogR2V0dGVyIGZvciB0aGUgVHJ1c3RlZCBUeXBlcyBQb2xpY3kuIElmIGl0IGlzIHVuZGVmaW5lZCwgaXQgaXMgaW5zdGFudGlhdGVkXHJcbiAqIGhlcmUgb3Igc2V0IHRvIG51bGwgaWYgVHJ1c3RlZCBUeXBlcyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBicm93c2VyLlxyXG4gKi8gZnVuY3Rpb24gZ2V0UG9saWN5KCkge1xyXG4gICAgaWYgKHR5cGVvZiBwb2xpY3kgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgdmFyIHJlZjtcclxuICAgICAgICBwb2xpY3kgPSAoKHJlZiA9IHdpbmRvdy50cnVzdGVkVHlwZXMpID09IG51bGwgPyB2b2lkIDAgOiByZWYuY3JlYXRlUG9saWN5KCduZXh0anMnLCB7XHJcbiAgICAgICAgICAgIGNyZWF0ZUhUTUw6IChpbnB1dCk9PmlucHV0LFxyXG4gICAgICAgICAgICBjcmVhdGVTY3JpcHQ6IChpbnB1dCk9PmlucHV0LFxyXG4gICAgICAgICAgICBjcmVhdGVTY3JpcHRVUkw6IChpbnB1dCk9PmlucHV0XHJcbiAgICAgICAgfSkpIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9saWN5O1xyXG59XHJcbmZ1bmN0aW9uIF9fdW5zYWZlQ3JlYXRlVHJ1c3RlZFNjcmlwdFVSTCh1cmwpIHtcclxuICAgIHZhciByZWY7XHJcbiAgICByZXR1cm4gKChyZWYgPSBnZXRQb2xpY3koKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5jcmVhdGVTY3JpcHRVUkwodXJsKSkgfHwgdXJsO1xyXG59XHJcblxyXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xyXG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xyXG59XHJcblxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10cnVzdGVkLXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl9fdW5zYWZlQ3JlYXRlVHJ1c3RlZFNjcmlwdFVSTCIsInBvbGljeSIsImdldFBvbGljeSIsInJlZiIsIndpbmRvdyIsInRydXN0ZWRUeXBlcyIsImNyZWF0ZVBvbGljeSIsImNyZWF0ZUhUTUwiLCJpbnB1dCIsImNyZWF0ZVNjcmlwdCIsImNyZWF0ZVNjcmlwdFVSTCIsInVybCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/trusted-types.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = withRouter;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _router = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nfunction withRouter(ComposedComponent) {\n    var _s = $RefreshSig$();\n    function WithRouterWrapper(props) {\n        _s();\n        return /*#__PURE__*/ _react.default.createElement(ComposedComponent, Object.assign({\n            router: (0, _router).useRouter()\n        }, props));\n    }\n    _s(WithRouterWrapper, \"CeygcqajjFExIxFEzW4x/gfWEGQ=\");\n    WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps;\n    WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;\n    if (true) {\n        const name = ComposedComponent.displayName || ComposedComponent.name || \"Unknown\";\n        WithRouterWrapper.displayName = \"withRouter(\".concat(name, \")\");\n    }\n    return WithRouterWrapper;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=with-router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC93aXRoLXJvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHRztBQUNsQixJQUFJQywyQkFBMkJDLG1KQUErRDtBQUM5RixJQUFJQyxTQUFTRix5QkFBeUJDLG1CQUFPQSxDQUFDLDRDQUFPO0FBQ3JELElBQUlFLFVBQVVGLG1CQUFPQSxDQUFDLDJEQUFVO0FBQ2hDLFNBQVNGLFdBQVdLLGlCQUFpQixFQUFFOztJQUNuQyxTQUFTQyxrQkFBa0JDLEtBQUssRUFBRTs7UUFDOUIsT0FBTyxXQUFXLEdBQUdKLE9BQU9KLE9BQU8sQ0FBQ1MsYUFBYSxDQUFDSCxtQkFBbUJWLE9BQU9jLE1BQU0sQ0FBQztZQUMvRUMsUUFBUSxDQUFDLEdBQUdOLE9BQU8sRUFBRU8sU0FBUztRQUNsQyxHQUFHSjtJQUNQO09BSlNEO0lBS1RBLGtCQUFrQk0sZUFBZSxHQUFHUCxrQkFBa0JPLGVBQWU7SUFDckVOLGtCQUFrQk8sbUJBQW1CLEdBQUdSLGtCQUFrQlEsbUJBQW1CO0lBQzdFLElBQUlDLElBQXlCLEVBQWM7UUFDdkMsTUFBTUMsT0FBT1Ysa0JBQWtCVyxXQUFXLElBQUlYLGtCQUFrQlUsSUFBSSxJQUFJO1FBQ3hFVCxrQkFBa0JVLFdBQVcsR0FBRyxjQUFtQixPQUFMRCxNQUFLO0lBQ3ZELENBQUM7SUFDRCxPQUFPVDtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9ULFFBQVFFLE9BQU8sS0FBSyxjQUFlLE9BQU9GLFFBQVFFLE9BQU8sS0FBSyxZQUFZRixRQUFRRSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9GLFFBQVFFLE9BQU8sQ0FBQ2tCLFVBQVUsS0FBSyxhQUFhO0lBQ3JLdEIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRRSxPQUFPLEVBQUUsY0FBYztRQUFFRCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2MsTUFBTSxDQUFDWixRQUFRRSxPQUFPLEVBQUVGO0lBQy9CcUIsT0FBT3JCLE9BQU8sR0FBR0EsUUFBUUUsT0FBTztBQUNsQyxDQUFDLENBRUQsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3dpdGgtcm91dGVyLmpzP2FjN2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gICAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHdpdGhSb3V0ZXI7XHJcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgX3JvdXRlciA9IHJlcXVpcmUoXCIuL3JvdXRlclwiKTtcclxuZnVuY3Rpb24gd2l0aFJvdXRlcihDb21wb3NlZENvbXBvbmVudCkge1xyXG4gICAgZnVuY3Rpb24gV2l0aFJvdXRlcldyYXBwZXIocHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbXBvc2VkQ29tcG9uZW50LCBPYmplY3QuYXNzaWduKHtcclxuICAgICAgICAgICAgcm91dGVyOiAoMCwgX3JvdXRlcikudXNlUm91dGVyKClcclxuICAgICAgICB9LCBwcm9wcykpO1xyXG4gICAgfVxyXG4gICAgV2l0aFJvdXRlcldyYXBwZXIuZ2V0SW5pdGlhbFByb3BzID0gQ29tcG9zZWRDb21wb25lbnQuZ2V0SW5pdGlhbFByb3BzO1xyXG4gICAgV2l0aFJvdXRlcldyYXBwZXIub3JpZ0dldEluaXRpYWxQcm9wcyA9IENvbXBvc2VkQ29tcG9uZW50Lm9yaWdHZXRJbml0aWFsUHJvcHM7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBDb21wb3NlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb3NlZENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJztcclxuICAgICAgICBXaXRoUm91dGVyV3JhcHBlci5kaXNwbGF5TmFtZSA9IGB3aXRoUm91dGVyKCR7bmFtZX0pYDtcclxuICAgIH1cclxuICAgIHJldHVybiBXaXRoUm91dGVyV3JhcHBlcjtcclxufVxyXG5cclxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcclxuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcclxufVxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2l0aC1yb3V0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIndpdGhSb3V0ZXIiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiX3JvdXRlciIsIkNvbXBvc2VkQ29tcG9uZW50IiwiV2l0aFJvdXRlcldyYXBwZXIiLCJwcm9wcyIsImNyZWF0ZUVsZW1lbnQiLCJhc3NpZ24iLCJyb3V0ZXIiLCJ1c2VSb3V0ZXIiLCJnZXRJbml0aWFsUHJvcHMiLCJvcmlnR2V0SW5pdGlhbFByb3BzIiwicHJvY2VzcyIsIm5hbWUiLCJkaXNwbGF5TmFtZSIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/with-router.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/head-manager-context.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/head-manager-context.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.HeadManagerContext = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nconst HeadManagerContext = _react.default.createContext({});\nexports.HeadManagerContext = HeadManagerContext;\nif (true) {\n    HeadManagerContext.displayName = \"HeadManagerContext\";\n} //# sourceMappingURL=head-manager-context.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaGVhZC1tYW5hZ2VyLWNvbnRleHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsMEJBQTBCLEdBQUcsS0FBSztBQUNsQyxJQUFJRywyQkFBMkJDLG1KQUErRDtBQUM5RixJQUFJRSxTQUFTSCx5QkFBeUJDLG1CQUFPQSxDQUFDLDRDQUFPO0FBQ3JELE1BQU1GLHFCQUFxQkksT0FBT0QsT0FBTyxDQUFDRSxhQUFhLENBQUMsQ0FBQztBQUN6RFAsMEJBQTBCLEdBQUdFO0FBQzdCLElBQUlNLElBQXlCLEVBQWM7SUFDdkNOLG1CQUFtQk8sV0FBVyxHQUFHO0FBQ3JDLENBQUMsQ0FFRCxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2hlYWQtbWFuYWdlci1jb250ZXh0LmpzPzc2ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gICAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuSGVhZE1hbmFnZXJDb250ZXh0ID0gdm9pZCAwO1xyXG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XHJcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcclxuY29uc3QgSGVhZE1hbmFnZXJDb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dCh7fSk7XHJcbmV4cG9ydHMuSGVhZE1hbmFnZXJDb250ZXh0ID0gSGVhZE1hbmFnZXJDb250ZXh0O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgSGVhZE1hbmFnZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0hlYWRNYW5hZ2VyQ29udGV4dCc7XHJcbn1cclxuXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlYWQtbWFuYWdlci1jb250ZXh0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJkZWZhdWx0IiwiX3JlYWN0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/head-manager-context.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/mitt.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/mitt.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = mitt;\nfunction mitt() {\n    const all = Object.create(null);\n    return {\n        on (type, handler) {\n            (all[type] || (all[type] = [])).push(handler);\n        },\n        off (type, handler) {\n            if (all[type]) {\n                all[type].splice(all[type].indexOf(handler) >>> 0, 1);\n            }\n        },\n        emit (type) {\n            for(var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                evts[_key - 1] = arguments[_key];\n            }\n            (all[type] || []).slice().map((handler)=>{\n                handler(...evts);\n            });\n        }\n    };\n} //# sourceMappingURL=mitt.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbWl0dC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHRztBQUNsQixTQUFTQSxPQUFPO0lBQ1osTUFBTUMsTUFBTU4sT0FBT08sTUFBTSxDQUFDLElBQUk7SUFDOUIsT0FBTztRQUNIQyxJQUFJQyxJQUFJLEVBQUVDLE9BQU8sRUFBRTtZQUNkSixDQUFBQSxHQUFHLENBQUNHLEtBQUssSUFBS0gsQ0FBQUEsR0FBRyxDQUFDRyxLQUFLLEdBQUcsRUFBRSxHQUFHRSxJQUFJLENBQUNEO1FBQ3pDO1FBQ0FFLEtBQUtILElBQUksRUFBRUMsT0FBTyxFQUFFO1lBQ2hCLElBQUlKLEdBQUcsQ0FBQ0csS0FBSyxFQUFFO2dCQUNYSCxHQUFHLENBQUNHLEtBQUssQ0FBQ0ksTUFBTSxDQUFDUCxHQUFHLENBQUNHLEtBQUssQ0FBQ0ssT0FBTyxDQUFDSixhQUFhLEdBQUc7WUFDdkQsQ0FBQztRQUNMO1FBQ0FLLE1BQU1OLElBQUksRUFBVztZQUFULHlFQUFPLEdBQVA7Z0JBQUdPLEtBQUgsMkJBQU87WUFBRDtZQUNiVixDQUFBQSxHQUFHLENBQUNHLEtBQUssSUFBSSxFQUFFLEVBQUVRLEtBQUssR0FBR0MsR0FBRyxDQUFDLENBQUNSLFVBQVU7Z0JBQ3JDQSxXQUFXTTtZQUNmO1FBQ0o7SUFDSjtBQUNKLEVBRUEsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9taXR0LmpzPzg1MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gICAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IG1pdHQ7XHJcbmZ1bmN0aW9uIG1pdHQoKSB7XHJcbiAgICBjb25zdCBhbGwgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBvbiAodHlwZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICAoYWxsW3R5cGVdIHx8IChhbGxbdHlwZV0gPSBbXSkpLnB1c2goaGFuZGxlcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvZmYgKHR5cGUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgaWYgKGFsbFt0eXBlXSkge1xyXG4gICAgICAgICAgICAgICAgYWxsW3R5cGVdLnNwbGljZShhbGxbdHlwZV0uaW5kZXhPZihoYW5kbGVyKSA+Pj4gMCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVtaXQgKHR5cGUsIC4uLmV2dHMpIHtcclxuICAgICAgICAgICAgKGFsbFt0eXBlXSB8fCBbXSkuc2xpY2UoKS5tYXAoKGhhbmRsZXIpPT57XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyKC4uLmV2dHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1taXR0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJtaXR0IiwiYWxsIiwiY3JlYXRlIiwib24iLCJ0eXBlIiwiaGFuZGxlciIsInB1c2giLCJvZmYiLCJzcGxpY2UiLCJpbmRleE9mIiwiZW1pdCIsImV2dHMiLCJzbGljZSIsIm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/mitt.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router-context.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RouterContext = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nexports.RouterContext = RouterContext;\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQscUJBQXFCLEdBQUcsS0FBSztBQUM3QixJQUFJRywyQkFBMkJDLG1KQUErRDtBQUM5RixJQUFJRSxTQUFTSCx5QkFBeUJDLG1CQUFPQSxDQUFDLDRDQUFPO0FBQ3JELE1BQU1GLGdCQUFnQkksT0FBT0QsT0FBTyxDQUFDRSxhQUFhLENBQUMsSUFBSTtBQUN2RFAscUJBQXFCLEdBQUdFO0FBQ3hCLElBQUlNLElBQXlCLEVBQWM7SUFDdkNOLGNBQWNPLFdBQVcsR0FBRztBQUNoQyxDQUFDLENBRUQsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5qcz81ZTkwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICAgIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLlJvdXRlckNvbnRleHQgPSB2b2lkIDA7XHJcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcclxudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xyXG5jb25zdCBSb3V0ZXJDb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dChudWxsKTtcclxuZXhwb3J0cy5Sb3V0ZXJDb250ZXh0ID0gUm91dGVyQ29udGV4dDtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIFJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnUm91dGVyQ29udGV4dCc7XHJcbn1cclxuXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci1jb250ZXh0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJvdXRlckNvbnRleHQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9yZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router-context.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.matchesMiddleware = matchesMiddleware;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports.createKey = createKey;\nexports[\"default\"] = void 0;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nvar _removeTrailingSlash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nvar _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nvar _script = __webpack_require__(/*! ../../../client/script */ \"./node_modules/next/dist/client/script.js\");\nvar _isError = _interop_require_wildcard(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nvar _denormalizePagePath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\nvar _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nvar _mitt = _interop_require_default(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nvar _querystring = __webpack_require__(/*! ./utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nvar _resolveRewrites = _interop_require_default(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\nvar _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nvar _routeRegex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nvar _formatUrl = __webpack_require__(/*! ./utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nvar _detectDomainLocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"./node_modules/next/dist/client/detect-domain-locale.js\");\nvar _parsePath = __webpack_require__(/*! ./utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nvar _addLocale = __webpack_require__(/*! ../../../client/add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\nvar _removeLocale = __webpack_require__(/*! ../../../client/remove-locale */ \"./node_modules/next/dist/client/remove-locale.js\");\nvar _removeBasePath = __webpack_require__(/*! ../../../client/remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\nvar _addBasePath = __webpack_require__(/*! ../../../client/add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\nvar _hasBasePath = __webpack_require__(/*! ../../../client/has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nvar _getNextPathnameInfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nvar _formatNextPathnameInfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nvar _compareStates = __webpack_require__(/*! ./utils/compare-states */ \"./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\nvar _isBot = __webpack_require__(/*! ./utils/is-bot */ \"./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nfunction buildCancellationError() {\n    return Object.assign(new Error(\"Route Cancelled\"), {\n        cancelled: true\n    });\n}\nfunction matchesMiddleware(options) {\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction _matchesMiddleware() {\n    _matchesMiddleware = _async_to_generator(function*(options) {\n        const matchers = yield Promise.resolve(options.router.pageLoader.getMiddleware());\n        if (!matchers) return false;\n        const { pathname: asPathname  } = (0, _parsePath).parsePath(options.asPath);\n        // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n        const cleanedAs = (0, _hasBasePath).hasBasePath(asPathname) ? (0, _removeBasePath).removeBasePath(asPathname) : asPathname;\n        const asWithBasePathAndLocale = (0, _addBasePath).addBasePath((0, _addLocale).addLocale(cleanedAs, options.locale));\n        // Check only path match on client. Matching \"has\" should be done on server\n        // where we can access more info such as headers, HttpOnly cookie, etc.\n        return matchers.some((m)=>new RegExp(m.regexp).test(asWithBasePathAndLocale));\n    });\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction stripOrigin(url) {\n    const origin = (0, _utils).getLocationOrigin();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction omit(object, keys) {\n    const omitted = {};\n    Object.keys(object).forEach((key)=>{\n        if (!keys.includes(key)) {\n            omitted[key] = object[key];\n        }\n    });\n    return omitted;\n}\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils).isAbsoluteUrl(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils).getLocationOrigin();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasBasePath).hasBasePath(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n}\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = \"\";\n    const dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : \"\") || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || \"\";\n        const { repeat , optional  } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = \"[\".concat(repeat ? \"...\" : \"\").concat(param, \"]\");\n        if (optional) {\n            replaced = \"\".concat(!value ? \"/\" : \"\", \"[\").concat(replaced, \"]\");\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)).join(\"/\") : encodeURIComponent(value)) || \"/\");\n    })) {\n        interpolatedRoute = \"\" // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n}\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === \"string\" ? href : (0, _formatUrl).formatWithValidation(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split(\"?\");\n    if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href passed to next/router: \".concat(urlAsString, \", repeated forward-slashes (//) or backslashes \\\\ are not valid in the href\"));\n        const normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!isLocalURL(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL(\"/\", \"http://n\");\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n        let interpolatedAs = \"\";\n        if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n            const { result , params  } = interpolateAs(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formatUrl).formatWithValidation({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: omit(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_1) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    let [resolvedHref, resolvedAs] = resolveHref(router, url, true);\n    const origin = (0, _utils).getLocationOrigin();\n    const hrefHadOrigin = resolvedHref.startsWith(origin);\n    const asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    const preparedUrl = hrefHadOrigin ? resolvedHref : (0, _addBasePath).addBasePath(resolvedHref);\n    const preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asHadOrigin ? preparedAs : (0, _addBasePath).addBasePath(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    const cleanPathname = (0, _removeTrailingSlash).removeTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n    if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some((page)=>{\n            if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    const nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(false)\n    };\n    const rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n    let rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n    const matchedPath = response.headers.get(\"x-matched-path\");\n    if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith(\"/\")) {\n            const parsedRewriteTarget = (0, _parseRelativeUrl).parseRelativeUrl(rewriteTarget);\n            const pathnameInfo = (0, _getNextPathnameInfo).getNextPathnameInfo(parsedRewriteTarget.pathname, {\n                nextConfig,\n                parseData: true\n            });\n            let fsPathname = (0, _removeTrailingSlash).removeTrailingSlash(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeLoader).getClientBuildManifest()\n            ]).then((param)=>{\n                let [pages, { __rewrites: rewrites  }] = param;\n                let as = (0, _addLocale).addLocale(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isDynamic).isDynamicRoute(as) || !rewriteHeader && pages.includes((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(as), options.router.locales).pathname)) {\n                    const parsedSource = (0, _getNextPathnameInfo).getNextPathnameInfo((0, _parseRelativeUrl).parseRelativeUrl(source).pathname, {\n                        parseData: true\n                    });\n                    as = (0, _addBasePath).addBasePath(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (false) {} else if (!pages.includes(fsPathname)) {\n                    const resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isDynamic).isDynamicRoute(resolvedHref)) {\n                    const matches = (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: \"rewrite\",\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref\n                };\n            });\n        }\n        const src = (0, _parsePath).parsePath(source);\n        const pathname = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src.pathname, {\n            nextConfig,\n            parseData: true\n        }), {\n            defaultLocale: options.router.defaultLocale,\n            buildId: \"\"\n        }));\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: \"\".concat(pathname).concat(src.query).concat(src.hash)\n        });\n    }\n    const redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n    if (redirectTarget) {\n        if (redirectTarget.startsWith(\"/\")) {\n            const src1 = (0, _parsePath).parsePath(redirectTarget);\n            const pathname1 = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src1.pathname, {\n                nextConfig,\n                parseData: true\n            }), {\n                defaultLocale: options.router.defaultLocale,\n                buildId: \"\"\n            }));\n            return Promise.resolve({\n                type: \"redirect-internal\",\n                newAs: \"\".concat(pathname1).concat(src1.query).concat(src1.hash),\n                newUrl: \"\".concat(pathname1).concat(src1.query).concat(src1.hash)\n            });\n        }\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: \"next\"\n    });\n}\nfunction withMiddlewareEffects(options) {\n    return matchesMiddleware(options).then((matches)=>{\n        if (matches && options.fetchData) {\n            return options.fetchData().then((data)=>getMiddlewareData(data.dataHref, data.response, options).then((effect)=>({\n                        dataHref: data.dataHref,\n                        cacheKey: data.cacheKey,\n                        json: data.json,\n                        response: data.response,\n                        text: data.text,\n                        effect\n                    }))).catch((_err)=>{\n                /**\r\n           * TODO: Revisit this in the future.\r\n           * For now we will not consider middleware data errors to be fatal.\r\n           * maybe we should revisit in the future.\r\n           */ return null;\n            });\n        }\n        return null;\n    });\n}\nconst manualScrollRestoration =  false && 0;\nconst SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` wont send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: \"same-origin\",\n        method: options.method || \"GET\",\n        headers: Object.assign({}, options.headers, {\n            \"x-nextjs-data\": \"1\"\n        })\n    }).then((response)=>{\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nfunction handleSmoothScroll(fn) {\n    const htmlElement = document.documentElement;\n    const existing = htmlElement.style.scrollBehavior;\n    htmlElement.style.scrollBehavior = \"auto\";\n    fn();\n    htmlElement.style.scrollBehavior = existing;\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData(param) {\n    let { dataHref , inflightCache , isPrefetch , hasMiddleware , isServerRender , parseJSON , persistCache , isBackground , unstable_skipClientCache  } = param;\n    const { href: cacheKey  } = new URL(dataHref, window.location.href);\n    var ref1;\n    const getData = (params)=>{\n        return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: Object.assign({}, isPrefetch ? {\n                purpose: \"prefetch\"\n            } : {}, isPrefetch && hasMiddleware ? {\n                \"x-middleware-prefetch\": \"1\"\n            } : {}),\n            method: (ref1 = params == null ? void 0 : params.method) != null ? ref1 : \"GET\"\n        }).then((response)=>{\n            if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n                return {\n                    dataHref,\n                    response,\n                    text: \"\",\n                    json: {},\n                    cacheKey\n                };\n            }\n            return response.text().then((text)=>{\n                if (!response.ok) {\n                    /**\r\n             * When the data response is a redirect because of a middleware\r\n             * we do not consider it an error. The headers must bring the\r\n             * mapped location.\r\n             * TODO: Change the status code in the handler.\r\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref,\n                            response,\n                            text,\n                            json: {},\n                            cacheKey\n                        };\n                    }\n                    if (!hasMiddleware && response.status === 404) {\n                        var ref;\n                        if ((ref = tryToParseAsJSON(text)) == null ? void 0 : ref.notFound) {\n                            return {\n                                dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response,\n                                text,\n                                cacheKey\n                            };\n                        }\n                    }\n                    const error = new Error(\"Failed to load static props\");\n                    /**\r\n             * We should only trigger a server-side transition if this was\r\n             * caused on a client-side transition. Otherwise, we'd get into\r\n             * an infinite loop.\r\n             */ if (!isServerRender) {\n                        (0, _routeLoader).markAssetError(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response,\n                    text,\n                    cacheKey\n                };\n            });\n        }).then((data)=>{\n            if (!persistCache || \"development\" !== \"production\" || 0) {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        }).catch((err)=>{\n            if (!unstable_skipClientCache) {\n                delete inflightCache[cacheKey];\n            }\n            if (err.message === \"Failed to fetch\") {\n                (0, _routeLoader).markAssetError(err);\n            }\n            throw err;\n        });\n    };\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then((data)=>{\n            inflightCache[cacheKey] = Promise.resolve(data);\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: \"HEAD\"\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(param) {\n    let { url , router  } = param;\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addBasePath).addBasePath((0, _addLocale).addLocale(router.asPath, router.locale))) {\n        throw new Error(\"Invariant: attempted to hard navigate to the same URL \".concat(url, \" \").concat(location.href));\n    }\n    window.location.href = url;\n}\nconst getCancelledHandler = (param)=>{\n    let { route , router  } = param;\n    let cancelled = false;\n    const cancel = router.clc = ()=>{\n        cancelled = true;\n    };\n    const handleCancelled = ()=>{\n        if (cancelled) {\n            const error = new Error('Abort fetching component for route: \"'.concat(route, '\"'));\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nclass Router {\n    reload() {\n        window.location.reload();\n    }\n    /**\r\n   * Go back in history\r\n   */ back() {\n        window.history.back();\n    }\n    /**\r\n   * Go forward in history\r\n   */ forward() {\n        window.history.forward();\n    }\n    /**\r\n   * Performs a `pushState` with arguments\r\n   * @param url of the route\r\n   * @param as masks `url` for the browser\r\n   * @param options object you can define `shallow` and other options\r\n   */ push(url, as) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        if (false) {}\n        ({ url , as  } = prepareUrlAs(this, url, as));\n        return this.change(\"pushState\", url, as, options);\n    }\n    /**\r\n   * Performs a `replaceState` with arguments\r\n   * @param url of the route\r\n   * @param as masks `url` for the browser\r\n   * @param options object you can define `shallow` and other options\r\n   */ replace(url, as) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        ({ url , as  } = prepareUrlAs(this, url, as));\n        return this.change(\"replaceState\", url, as, options);\n    }\n    change(method, url, as, options, forcedScroll) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            if (!isLocalURL(url)) {\n                handleHardNavigation({\n                    url,\n                    router: _this\n                });\n                return false;\n            }\n            // WARNING: `_h` is an internal option for handing Next.js client-side\n            // hydration. Your app should _never_ use this property. It may change at\n            // any time without notice.\n            const isQueryUpdating = options._h;\n            let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsePath).parsePath(url).pathname === (0, _parsePath).parsePath(as).pathname;\n            const nextState = _extends({}, _this.state);\n            // for static pages with query params in the URL we delay\n            // marking the router ready until after the query is updated\n            // or a navigation has occurred\n            const readyStateChange = _this.isReady !== true;\n            _this.isReady = true;\n            const isSsr = _this.isSsr;\n            if (!isQueryUpdating) {\n                _this.isSsr = false;\n            }\n            // if a route transition is already in progress before\n            // the query updating is triggered ignore query updating\n            if (isQueryUpdating && _this.clc) {\n                return false;\n            }\n            const prevLocale = nextState.locale;\n            if (false) { var ref; }\n            // marking route changes as a navigation start entry\n            if (_utils.ST) {\n                performance.mark(\"routeChange\");\n            }\n            const { shallow =false , scroll =true  } = options;\n            const routeProps = {\n                shallow\n            };\n            if (_this._inFlightRoute && _this.clc) {\n                if (!isSsr) {\n                    Router.events.emit(\"routeChangeError\", buildCancellationError(), _this._inFlightRoute, routeProps);\n                }\n                _this.clc();\n                _this.clc = null;\n            }\n            as = (0, _addBasePath).addBasePath((0, _addLocale).addLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, options.locale, _this.defaultLocale));\n            const cleanedAs = (0, _removeLocale).removeLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, nextState.locale);\n            _this._inFlightRoute = as;\n            const localeChange = prevLocale !== nextState.locale;\n            // If the url change is only related to a hash change\n            // We should not proceed. We should only change the state.\n            if (!isQueryUpdating && _this.onlyAHashChange(cleanedAs) && !localeChange) {\n                nextState.asPath = cleanedAs;\n                Router.events.emit(\"hashChangeStart\", as, routeProps);\n                // TODO: do we need the resolved href when only a hash change?\n                _this.changeState(method, url, as, _extends({}, options, {\n                    scroll: false\n                }));\n                if (scroll) {\n                    _this.scrollToHash(cleanedAs);\n                }\n                try {\n                    yield _this.set(nextState, _this.components[nextState.route], null);\n                } catch (err) {\n                    if ((0, _isError).default(err) && err.cancelled) {\n                        Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n                    }\n                    throw err;\n                }\n                Router.events.emit(\"hashChangeComplete\", as, routeProps);\n                return true;\n            }\n            let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            let { pathname , query  } = parsed;\n            // The build manifest needs to be loaded before auto-static dynamic pages\n            // get their query parameters to allow ensuring they can be parsed properly\n            // when rewritten to\n            let pages, rewrites;\n            try {\n                [pages, { __rewrites: rewrites  }] = yield Promise.all([\n                    _this.pageLoader.getPageList(),\n                    (0, _routeLoader).getClientBuildManifest(),\n                    _this.pageLoader.getMiddleware()\n                ]);\n            } catch (err1) {\n                // If we fail to resolve the page list or client-build manifest, we must\n                // do a server-side transition:\n                handleHardNavigation({\n                    url: as,\n                    router: _this\n                });\n                return false;\n            }\n            // If asked to change the current URL we should reload the current page\n            // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n            // We also need to set the method = replaceState always\n            // as this should not go into the history (That's how browsers work)\n            // We should compare the new asPath to the current asPath, not the url\n            if (!_this.urlIsNew(cleanedAs) && !localeChange) {\n                method = \"replaceState\";\n            }\n            // we need to resolve the as value using rewrites for dynamic SSG\n            // pages to allow building the data URL correctly\n            let resolvedAs = as;\n            // url and as should always be prefixed with basePath by this\n            // point by either next/link or router.push/replace so strip the\n            // basePath from the pathname to match the pages dir 1-to-1\n            pathname = pathname ? (0, _removeTrailingSlash).removeTrailingSlash((0, _removeBasePath).removeBasePath(pathname)) : pathname;\n            let route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n            const parsedAsPathname = as.startsWith(\"/\") && (0, _parseRelativeUrl).parseRelativeUrl(as).pathname;\n            const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isDynamic).isDynamicRoute(route) || !(0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(route))(parsedAsPathname)));\n            // we don't attempt resolve asPath when we need to execute\n            // middleware as the resolving will occur server-side\n            const isMiddlewareMatch = yield matchesMiddleware({\n                asPath: as,\n                locale: nextState.locale,\n                router: _this\n            });\n            if (options.shallow && isMiddlewareMatch) {\n                pathname = _this.pathname;\n            }\n            if (isQueryUpdating && isMiddlewareMatch) {\n                shouldResolveHref = false;\n            }\n            if (shouldResolveHref && pathname !== \"/_error\") {\n                options._shouldResolveHref = true;\n                if (false) {} else {\n                    parsed.pathname = resolveDynamicRoute(pathname, pages);\n                    if (parsed.pathname !== pathname) {\n                        pathname = parsed.pathname;\n                        parsed.pathname = (0, _addBasePath).addBasePath(pathname);\n                        if (!isMiddlewareMatch) {\n                            url = (0, _formatUrl).formatWithValidation(parsed);\n                        }\n                    }\n                }\n            }\n            if (!isLocalURL(as)) {\n                if (true) {\n                    throw new Error('Invalid href: \"'.concat(url, '\" and as: \"').concat(as, '\", received relative href and external as') + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n                }\n                handleHardNavigation({\n                    url: as,\n                    router: _this\n                });\n                return false;\n            }\n            resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(resolvedAs), nextState.locale);\n            route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n            let routeMatch = false;\n            if ((0, _isDynamic).isDynamicRoute(route)) {\n                const parsedAs1 = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n                const asPathname = parsedAs1.pathname;\n                const routeRegex = (0, _routeRegex).getRouteRegex(route);\n                routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n                const shouldInterpolate = route === asPathname;\n                const interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};\n                if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                    const missingParams = Object.keys(routeRegex.groups).filter((param)=>!query[param] && !routeRegex.groups[param].optional);\n                    if (missingParams.length > 0 && !isMiddlewareMatch) {\n                        if (true) {\n                            console.warn(\"\".concat(shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\", \" failed to manually provide \") + \"the params: \".concat(missingParams.join(\", \"), \" in the `href`'s `query`\"));\n                        }\n                        throw new Error((shouldInterpolate ? \"The provided `href` (\".concat(url, \") value is missing query values (\").concat(missingParams.join(\", \"), \") to be interpolated properly. \") : \"The provided `as` value (\".concat(asPathname, \") is incompatible with the `href` value (\").concat(route, \"). \")) + \"Read more: https://nextjs.org/docs/messages/\".concat(shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\"));\n                    }\n                } else if (shouldInterpolate) {\n                    as = (0, _formatUrl).formatWithValidation(Object.assign({}, parsedAs1, {\n                        pathname: interpolatedAs.result,\n                        query: omit(query, interpolatedAs.params)\n                    }));\n                } else {\n                    // Merge params into `query`, overwriting any specified in search\n                    Object.assign(query, routeMatch);\n                }\n            }\n            if (!isQueryUpdating) {\n                Router.events.emit(\"routeChangeStart\", as, routeProps);\n            }\n            try {\n                var ref2, ref3;\n                let routeInfo = yield _this.getRouteInfo({\n                    route,\n                    pathname,\n                    query,\n                    as,\n                    resolvedAs,\n                    routeProps,\n                    locale: nextState.locale,\n                    isPreview: nextState.isPreview,\n                    hasMiddleware: isMiddlewareMatch,\n                    unstable_skipClientCache: options.unstable_skipClientCache,\n                    isQueryUpdating: isQueryUpdating && !_this.isFallback,\n                    isMiddlewareRewrite\n                });\n                if (\"route\" in routeInfo && isMiddlewareMatch) {\n                    pathname = routeInfo.route || route;\n                    route = pathname;\n                    if (!routeProps.shallow) {\n                        query = Object.assign({}, routeInfo.query || {}, query);\n                    }\n                    const cleanedParsedPathname = (0, _hasBasePath).hasBasePath(parsed.pathname) ? (0, _removeBasePath).removeBasePath(parsed.pathname) : parsed.pathname;\n                    if (routeMatch && pathname !== cleanedParsedPathname) {\n                        Object.keys(routeMatch).forEach((key)=>{\n                            if (routeMatch && query[key] === routeMatch[key]) {\n                                delete query[key];\n                            }\n                        });\n                    }\n                    if ((0, _isDynamic).isDynamicRoute(pathname)) {\n                        const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addBasePath).addBasePath((0, _addLocale).addLocale(new URL(as, location.href).pathname, nextState.locale), true);\n                        let rewriteAs = prefixedAs;\n                        if ((0, _hasBasePath).hasBasePath(rewriteAs)) {\n                            rewriteAs = (0, _removeBasePath).removeBasePath(rewriteAs);\n                        }\n                        if (false) {}\n                        const routeRegex1 = (0, _routeRegex).getRouteRegex(pathname);\n                        const curRouteMatch = (0, _routeMatcher).getRouteMatcher(routeRegex1)(new URL(rewriteAs, location.href).pathname);\n                        if (curRouteMatch) {\n                            Object.assign(query, curRouteMatch);\n                        }\n                    }\n                }\n                // If the routeInfo brings a redirect we simply apply it.\n                if (\"type\" in routeInfo) {\n                    if (routeInfo.type === \"redirect-internal\") {\n                        return _this.change(method, routeInfo.newUrl, routeInfo.newAs, options);\n                    } else {\n                        handleHardNavigation({\n                            url: routeInfo.destination,\n                            router: _this\n                        });\n                        return new Promise(()=>{});\n                    }\n                }\n                let { error , props , __N_SSG , __N_SSP  } = routeInfo;\n                const component = routeInfo.Component;\n                if (component && component.unstable_scriptLoader) {\n                    const scripts = [].concat(component.unstable_scriptLoader());\n                    scripts.forEach((script)=>{\n                        (0, _script).handleClientScriptLoad(script.props);\n                    });\n                }\n                // handle redirect on client-transition\n                if ((__N_SSG || __N_SSP) && props) {\n                    if (props.pageProps && props.pageProps.__N_REDIRECT) {\n                        // Use the destination from redirect without adding locale\n                        options.locale = false;\n                        const destination = props.pageProps.__N_REDIRECT;\n                        // check if destination is internal (resolves to a page) and attempt\n                        // client-navigation if it is falling back to hard navigation if\n                        // it's not\n                        if (destination.startsWith(\"/\") && props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                            const parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                            parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                            const { url: newUrl , as: newAs  } = prepareUrlAs(_this, destination, destination);\n                            return _this.change(method, newUrl, newAs, options);\n                        }\n                        handleHardNavigation({\n                            url: destination,\n                            router: _this\n                        });\n                        return new Promise(()=>{});\n                    }\n                    nextState.isPreview = !!props.__N_PREVIEW;\n                    // handle SSG data 404\n                    if (props.notFound === SSG_DATA_NOT_FOUND) {\n                        let notFoundRoute;\n                        try {\n                            yield _this.fetchComponent(\"/404\");\n                            notFoundRoute = \"/404\";\n                        } catch (_) {\n                            notFoundRoute = \"/_error\";\n                        }\n                        routeInfo = yield _this.getRouteInfo({\n                            route: notFoundRoute,\n                            pathname: notFoundRoute,\n                            query,\n                            as,\n                            resolvedAs,\n                            routeProps: {\n                                shallow: false\n                            },\n                            locale: nextState.locale,\n                            isPreview: nextState.isPreview\n                        });\n                        if (\"type\" in routeInfo) {\n                            throw new Error(\"Unexpected middleware effect on /404\");\n                        }\n                    }\n                }\n                Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n                _this.changeState(method, url, as, options);\n                if (isQueryUpdating && pathname === \"/_error\" && ((ref2 = self.__NEXT_DATA__.props) == null ? void 0 : (ref3 = ref2.pageProps) == null ? void 0 : ref3.statusCode) === 500 && (props == null ? void 0 : props.pageProps)) {\n                    // ensure statusCode is still correct for static 500 page\n                    // when updating query information\n                    props.pageProps.statusCode = 500;\n                }\n                var _route;\n                // shallow routing is only allowed for same page URL changes.\n                const isValidShallowRoute = options.shallow && nextState.route === ((_route = routeInfo.route) != null ? _route : route);\n                var _scroll;\n                const shouldScroll = (_scroll = options.scroll) != null ? _scroll : !options._h && !isValidShallowRoute;\n                const resetScroll = shouldScroll ? {\n                    x: 0,\n                    y: 0\n                } : null;\n                // the new state that the router gonna set\n                const upcomingRouterState = _extends({}, nextState, {\n                    route,\n                    pathname,\n                    query,\n                    asPath: cleanedAs,\n                    isFallback: false\n                });\n                const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n                // for query updates we can skip it if the state is unchanged and we don't\n                // need to scroll\n                // https://github.com/vercel/next.js/issues/37139\n                const canSkipUpdating = options._h && !upcomingScrollState && !readyStateChange && !localeChange && (0, _compareStates).compareRouterStates(upcomingRouterState, _this.state);\n                if (!canSkipUpdating) {\n                    yield _this.set(upcomingRouterState, routeInfo, upcomingScrollState).catch((e)=>{\n                        if (e.cancelled) error = error || e;\n                        else throw e;\n                    });\n                    if (error) {\n                        if (!isQueryUpdating) {\n                            Router.events.emit(\"routeChangeError\", error, cleanedAs, routeProps);\n                        }\n                        throw error;\n                    }\n                    if (false) {}\n                    if (!isQueryUpdating) {\n                        Router.events.emit(\"routeChangeComplete\", as, routeProps);\n                    }\n                    // A hash mark # is the optional last part of a URL\n                    const hashRegex = /#.+$/;\n                    if (shouldScroll && hashRegex.test(as)) {\n                        _this.scrollToHash(as);\n                    }\n                }\n                return true;\n            } catch (err11) {\n                if ((0, _isError).default(err11) && err11.cancelled) {\n                    return false;\n                }\n                throw err11;\n            }\n        })();\n    }\n    changeState(method, url, as) {\n        let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        if (true) {\n            if (typeof window.history === \"undefined\") {\n                console.error(\"Warning: window.history is not available.\");\n                return;\n            }\n            if (typeof window.history[method] === \"undefined\") {\n                console.error(\"Warning: window.history.\".concat(method, \" is not available\"));\n                return;\n            }\n        }\n        if (method !== \"pushState\" || (0, _utils).getURL() !== as) {\n            this._shallow = options.shallow;\n            window.history[method]({\n                url,\n                as,\n                options,\n                __N: true,\n                key: this._key = method !== \"pushState\" ? this._key : createKey()\n            }, // Passing the empty string here should be safe against future changes to the method.\n            // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n            \"\", as);\n        }\n    }\n    handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            console.error(err);\n            if (err.cancelled) {\n                // bubble up cancellation errors\n                throw err;\n            }\n            if ((0, _routeLoader).isAssetError(err) || loadErrorFail) {\n                Router.events.emit(\"routeChangeError\", err, as, routeProps);\n                // If we can't load the page it could be one of following reasons\n                //  1. Page doesn't exists\n                //  2. Page does exist in a different zone\n                //  3. Internal error while loading the page\n                // So, doing a hard reload is the proper way to deal with this.\n                handleHardNavigation({\n                    url: as,\n                    router: _this\n                });\n                // Changing the URL doesn't block executing the current code path.\n                // So let's throw a cancellation error stop the routing logic.\n                throw buildCancellationError();\n            }\n            try {\n                let props;\n                const { page: Component , styleSheets  } = yield _this.fetchComponent(\"/_error\");\n                const routeInfo = {\n                    props,\n                    Component,\n                    styleSheets,\n                    err,\n                    error: err\n                };\n                if (!routeInfo.props) {\n                    try {\n                        routeInfo.props = yield _this.getInitialProps(Component, {\n                            err,\n                            pathname,\n                            query\n                        });\n                    } catch (gipErr) {\n                        console.error(\"Error in error page `getInitialProps`: \", gipErr);\n                        routeInfo.props = {};\n                    }\n                }\n                return routeInfo;\n            } catch (routeInfoErr) {\n                return _this.handleRouteInfoError((0, _isError).default(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + \"\"), pathname, query, as, routeProps, true);\n            }\n        })();\n    }\n    getRouteInfo(param) {\n        let { route: requestedRoute , pathname , query , as , resolvedAs , routeProps , locale , hasMiddleware , isPreview , unstable_skipClientCache , isQueryUpdating , isMiddlewareRewrite  } = param;\n        var _this = this;\n        return _async_to_generator(function*() {\n            /**\r\n     * This `route` binding can change if there's a rewrite\r\n     * so we keep a reference to the original requested route\r\n     * so we can store the cache for it and avoid re-requesting every time\r\n     * for shallow routing purposes.\r\n     */ let route = requestedRoute;\n            try {\n                var ref, ref4, ref5, ref6;\n                const handleCancelled = getCancelledHandler({\n                    route,\n                    router: _this\n                });\n                let existingInfo = _this.components[route];\n                if (routeProps.shallow && existingInfo && _this.route === route) {\n                    return existingInfo;\n                }\n                if (hasMiddleware) {\n                    existingInfo = undefined;\n                }\n                let cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && \"development\" !== \"development\" ? 0 : undefined;\n                const isBackground = isQueryUpdating;\n                const fetchNextDataParams = {\n                    dataHref: _this.pageLoader.getDataHref({\n                        href: (0, _formatUrl).formatWithValidation({\n                            pathname,\n                            query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale\n                    }),\n                    hasMiddleware: true,\n                    isServerRender: _this.isSsr,\n                    parseJSON: true,\n                    inflightCache: isBackground ? _this.sbc : _this.sdc,\n                    persistCache: !isPreview,\n                    isPrefetch: false,\n                    unstable_skipClientCache,\n                    isBackground\n                };\n                const data = isQueryUpdating && !isMiddlewareRewrite ? {} : yield withMiddlewareEffects({\n                    fetchData: ()=>fetchNextData(fetchNextDataParams),\n                    asPath: resolvedAs,\n                    locale: locale,\n                    router: _this\n                }).catch((err)=>{\n                    // we don't hard error during query updating\n                    // as it's un-necessary and doesn't need to be fatal\n                    // unless it is a fallback route and the props can't\n                    // be loaded\n                    if (isQueryUpdating) {\n                        return {};\n                    }\n                    throw err;\n                });\n                if (isQueryUpdating) {\n                    data.json = self.__NEXT_DATA__.props;\n                }\n                handleCancelled();\n                if ((data == null ? void 0 : (ref = data.effect) == null ? void 0 : ref.type) === \"redirect-internal\" || (data == null ? void 0 : (ref4 = data.effect) == null ? void 0 : ref4.type) === \"redirect-external\") {\n                    return data.effect;\n                }\n                if ((data == null ? void 0 : (ref5 = data.effect) == null ? void 0 : ref5.type) === \"rewrite\") {\n                    const resolvedRoute = (0, _removeTrailingSlash).removeTrailingSlash(data.effect.resolvedHref);\n                    const pages = yield _this.pageLoader.getPageList();\n                    // during query updating the page must match although during\n                    // client-transition a redirect that doesn't match a page\n                    // can be returned and this should trigger a hard navigation\n                    // which is valid for incremental migration\n                    if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n                        route = resolvedRoute;\n                        pathname = data.effect.resolvedHref;\n                        query = _extends({}, query, data.effect.parsedAs.query);\n                        resolvedAs = (0, _removeBasePath).removeBasePath((0, _normalizeLocalePath).normalizeLocalePath(data.effect.parsedAs.pathname, _this.locales).pathname);\n                        // Check again the cache with the new destination.\n                        existingInfo = _this.components[route];\n                        if (routeProps.shallow && existingInfo && _this.route === route && !hasMiddleware) {\n                            // If we have a match with the current route due to rewrite,\n                            // we can copy the existing information to the rewritten one.\n                            // Then, we return the information along with the matched route.\n                            return _extends({}, existingInfo, {\n                                route\n                            });\n                        }\n                    }\n                }\n                if (route === \"/api\" || route.startsWith(\"/api/\")) {\n                    handleHardNavigation({\n                        url: as,\n                        router: _this\n                    });\n                    return new Promise(()=>{});\n                }\n                const routeInfo = cachedRouteInfo || (yield _this.fetchComponent(route).then((res)=>({\n                        Component: res.page,\n                        styleSheets: res.styleSheets,\n                        __N_SSG: res.mod.__N_SSG,\n                        __N_SSP: res.mod.__N_SSP\n                    })));\n                if (true) {\n                    const { isValidElementType  } = __webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\");\n                    if (!isValidElementType(routeInfo.Component)) {\n                        throw new Error('The default export is not a React Component in page: \"'.concat(pathname, '\"'));\n                    }\n                }\n                const wasBailedPrefetch = data == null ? void 0 : (ref6 = data.response) == null ? void 0 : ref6.headers.get(\"x-middleware-skip\");\n                const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n                // For non-SSG prefetches that bailed before sending data\n                // we clear the cache to fetch full response\n                if (wasBailedPrefetch) {\n                    delete _this.sdc[data == null ? void 0 : data.dataHref];\n                }\n                const { props , cacheKey  } = yield _this._getData(_async_to_generator(function*() {\n                    if (shouldFetchData) {\n                        const { json , cacheKey: _cacheKey  } = (data == null ? void 0 : data.json) && !wasBailedPrefetch ? data : yield fetchNextData({\n                            dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this.pageLoader.getDataHref({\n                                href: (0, _formatUrl).formatWithValidation({\n                                    pathname,\n                                    query\n                                }),\n                                asPath: resolvedAs,\n                                locale\n                            }),\n                            isServerRender: _this.isSsr,\n                            parseJSON: true,\n                            inflightCache: wasBailedPrefetch ? {} : _this.sdc,\n                            persistCache: !isPreview,\n                            isPrefetch: false,\n                            unstable_skipClientCache\n                        });\n                        return {\n                            cacheKey: _cacheKey,\n                            props: json || {}\n                        };\n                    }\n                    return {\n                        headers: {},\n                        cacheKey: \"\",\n                        props: yield _this.getInitialProps(routeInfo.Component, {\n                            pathname,\n                            query,\n                            asPath: as,\n                            locale,\n                            locales: _this.locales,\n                            defaultLocale: _this.defaultLocale\n                        })\n                    };\n                }));\n                // Only bust the data cache for SSP routes although\n                // middleware can skip cache per request with\n                // x-middleware-cache: no-cache as well\n                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref) {\n                    delete _this.sdc[cacheKey];\n                }\n                // we kick off a HEAD request in the background\n                // when a non-prefetch request is made to signal revalidation\n                if (!_this.isPreview && routeInfo.__N_SSG && \"development\" !== \"development\" && 0) {}\n                props.pageProps = Object.assign({}, props.pageProps);\n                routeInfo.props = props;\n                routeInfo.route = route;\n                routeInfo.query = query;\n                routeInfo.resolvedAs = resolvedAs;\n                _this.components[route] = routeInfo;\n                return routeInfo;\n            } catch (err) {\n                return _this.handleRouteInfoError((0, _isError).getProperError(err), pathname, query, as, routeProps);\n            }\n        })();\n    }\n    set(state, data, resetScroll) {\n        this.state = state;\n        return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n    }\n    /**\r\n   * Callback to execute before replacing router state\r\n   * @param cb callback to be executed\r\n   */ beforePopState(cb) {\n        this._bps = cb;\n    }\n    onlyAHashChange(as) {\n        if (!this.asPath) return false;\n        const [oldUrlNoHash, oldHash] = this.asPath.split(\"#\");\n        const [newUrlNoHash, newHash] = as.split(\"#\");\n        // Makes sure we scroll to the provided hash if the url/hash are the same\n        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n            return true;\n        }\n        // If the urls are change, there's more than a hash change\n        if (oldUrlNoHash !== newUrlNoHash) {\n            return false;\n        }\n        // If the hash has changed, then it's a hash only change.\n        // This check is necessary to handle both the enter and\n        // leave hash === '' cases. The identity case falls through\n        // and is treated as a next reload.\n        return oldHash !== newHash;\n    }\n    scrollToHash(as) {\n        const [, hash = \"\"] = as.split(\"#\");\n        // Scroll to top if the hash is just `#` with no value or `#top`\n        // To mirror browsers\n        if (hash === \"\" || hash === \"top\") {\n            handleSmoothScroll(()=>window.scrollTo(0, 0));\n            return;\n        }\n        // Decode hash to make non-latin anchor works.\n        const rawHash = decodeURIComponent(hash);\n        // First we check if the element by id is found\n        const idEl = document.getElementById(rawHash);\n        if (idEl) {\n            handleSmoothScroll(()=>idEl.scrollIntoView());\n            return;\n        }\n        // If there's no element with the id, we check the `name` property\n        // To mirror browsers\n        const nameEl = document.getElementsByName(rawHash)[0];\n        if (nameEl) {\n            handleSmoothScroll(()=>nameEl.scrollIntoView());\n        }\n    }\n    urlIsNew(asPath) {\n        return this.asPath !== asPath;\n    }\n    /**\r\n   * Prefetch page code, you may wait for the data during page rendering.\r\n   * This feature only works in production!\r\n   * @param url the href of prefetched page\r\n   * @param asPath the as path of the prefetched page\r\n   */ prefetch(url) {\n        let asPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : url, options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        var _this = this;\n        return _async_to_generator(function*() {\n            if ( true && (0, _isBot).isBot(window.navigator.userAgent)) {\n                // No prefetches for bots that render the link since they are typically navigating\n                // links via the equivalent of a hard navigation and hence never utilize these\n                // prefetches.\n                return;\n            }\n            let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            let { pathname , query  } = parsed;\n            const originalPathname = pathname;\n            if (false) {}\n            const pages = yield _this.pageLoader.getPageList();\n            let resolvedAs = asPath;\n            const locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : _this.locale;\n            const isMiddlewareMatch = yield matchesMiddleware({\n                asPath: asPath,\n                locale: locale,\n                router: _this\n            });\n            if (false) {}\n            parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n            if ((0, _isDynamic).isDynamicRoute(parsed.pathname)) {\n                pathname = parsed.pathname;\n                parsed.pathname = pathname;\n                Object.assign(query, (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(parsed.pathname))((0, _parsePath).parsePath(asPath).pathname) || {});\n                if (!isMiddlewareMatch) {\n                    url = (0, _formatUrl).formatWithValidation(parsed);\n                }\n            }\n            // Prefetch is not supported in development mode because it would trigger on-demand-entries\n            if (true) {\n                return;\n            }\n            const data =  false ? 0 : yield withMiddlewareEffects({\n                fetchData: ()=>fetchNextData({\n                        dataHref: _this.pageLoader.getDataHref({\n                            href: (0, _formatUrl).formatWithValidation({\n                                pathname: originalPathname,\n                                query\n                            }),\n                            skipInterpolation: true,\n                            asPath: resolvedAs,\n                            locale\n                        }),\n                        hasMiddleware: true,\n                        isServerRender: _this.isSsr,\n                        parseJSON: true,\n                        inflightCache: _this.sdc,\n                        persistCache: !_this.isPreview,\n                        isPrefetch: true\n                    }),\n                asPath: asPath,\n                locale: locale,\n                router: _this\n            });\n            /**\r\n     * If there was a rewrite we apply the effects of the rewrite on the\r\n     * current parameters for the prefetch.\r\n     */ if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n                parsed.pathname = data.effect.resolvedHref;\n                pathname = data.effect.resolvedHref;\n                query = _extends({}, query, data.effect.parsedAs.query);\n                resolvedAs = data.effect.parsedAs.pathname;\n                url = (0, _formatUrl).formatWithValidation(parsed);\n            }\n            /**\r\n     * If there is a redirect to an external destination then we don't have\r\n     * to prefetch content as it will be unused.\r\n     */ if ((data == null ? void 0 : data.effect.type) === \"redirect-external\") {\n                return;\n            }\n            const route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n            yield Promise.all([\n                _this.pageLoader._isSsg(route).then((isSsg)=>{\n                    return isSsg ? fetchNextData({\n                        dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this.pageLoader.getDataHref({\n                            href: url,\n                            asPath: resolvedAs,\n                            locale: locale\n                        }),\n                        isServerRender: false,\n                        parseJSON: true,\n                        inflightCache: _this.sdc,\n                        persistCache: !_this.isPreview,\n                        isPrefetch: true,\n                        unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                    }).then(()=>false) : false;\n                }),\n                _this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)\n            ]);\n        })();\n    }\n    fetchComponent(route) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            const handleCancelled = getCancelledHandler({\n                route,\n                router: _this\n            });\n            try {\n                const componentResult = yield _this.pageLoader.loadPage(route);\n                handleCancelled();\n                return componentResult;\n            } catch (err) {\n                handleCancelled();\n                throw err;\n            }\n        })();\n    }\n    _getData(fn) {\n        let cancelled = false;\n        const cancel = ()=>{\n            cancelled = true;\n        };\n        this.clc = cancel;\n        return fn().then((data)=>{\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n            if (cancelled) {\n                const err = new Error(\"Loading initial props cancelled\");\n                err.cancelled = true;\n                throw err;\n            }\n            return data;\n        });\n    }\n    _getFlightData(dataHref) {\n        // Do not cache RSC flight response since it's not a static resource\n        return fetchNextData({\n            dataHref,\n            isServerRender: true,\n            parseJSON: false,\n            inflightCache: this.sdc,\n            persistCache: false,\n            isPrefetch: false\n        }).then((param)=>{\n            let { text  } = param;\n            return {\n                data: text\n            };\n        });\n    }\n    getInitialProps(Component, ctx) {\n        const { Component: App  } = this.components[\"/_app\"];\n        const AppTree = this._wrapApp(App);\n        ctx.AppTree = AppTree;\n        return (0, _utils).loadGetInitialProps(App, {\n            AppTree,\n            Component,\n            router: this,\n            ctx\n        });\n    }\n    get route() {\n        return this.state.route;\n    }\n    get pathname() {\n        return this.state.pathname;\n    }\n    get query() {\n        return this.state.query;\n    }\n    get asPath() {\n        return this.state.asPath;\n    }\n    get locale() {\n        return this.state.locale;\n    }\n    get isFallback() {\n        return this.state.isFallback;\n    }\n    get isPreview() {\n        return this.state.isPreview;\n    }\n    constructor(pathname1, query1, as1, { initialProps , pageLoader , App , wrapApp , Component , err , subscription , isFallback , locale , locales , defaultLocale , domainLocales , isPreview  }){\n        // Server Data Cache (full data requests)\n        this.sdc = {};\n        // Server Background Cache (HEAD requests)\n        this.sbc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = (e)=>{\n            const { isFirstPopStateEvent  } = this;\n            this.isFirstPopStateEvent = false;\n            const state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                const { pathname , query  } = this;\n                this.changeState(\"replaceState\", (0, _formatUrl).formatWithValidation({\n                    pathname: (0, _addBasePath).addBasePath(pathname),\n                    query\n                }), (0, _utils).getURL());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {\n                return;\n            }\n            let forcedScroll;\n            const { url , as , options , key  } = state;\n            if (false) {}\n            this._key = key;\n            const { pathname: pathname1  } = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (this.isSsr && as === (0, _addBasePath).addBasePath(this.asPath) && pathname1 === (0, _addBasePath).addBasePath(this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (this._bps && !this._bps(state)) {\n                return;\n            }\n            this.change(\"replaceState\", url, as, Object.assign({}, options, {\n                shallow: options.shallow && this._shallow,\n                locale: options.locale || this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        const route = (0, _removeTrailingSlash).removeTrailingSlash(pathname1);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname1 !== \"/_error\") {\n            this.components[route] = {\n                Component,\n                initial: true,\n                props: initialProps,\n                err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components[\"/_app\"] = {\n            Component: App,\n            styleSheets: []\n        };\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        const autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname1) && self.__NEXT_DATA__.autoExport;\n        this.basePath =  false || \"\";\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        if (false) {}\n        this.state = {\n            route,\n            pathname: pathname1,\n            query: query1,\n            asPath: autoExportDynamic ? pathname1 : as1,\n            isPreview: !!isPreview,\n            locale:  false ? 0 : undefined,\n            isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as1.startsWith(\"//\")) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                const options = {\n                    locale\n                };\n                const asPath = (0, _utils).getURL();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale,\n                    asPath\n                }).then((matches)=>{\n                    options._shouldResolveHref = as1 !== pathname1;\n                    this.changeState(\"replaceState\", matches ? asPath : (0, _formatUrl).formatWithValidation({\n                        pathname: (0, _addBasePath).addBasePath(pathname1),\n                        query: query1\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener(\"popstate\", this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n}\nRouter.events = (0, _mitt).default();\nexports[\"default\"] = Router; //# sourceMappingURL=router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx5QkFBeUIsR0FBR0U7QUFDNUJGLGtCQUFrQixHQUFHRztBQUNyQkgscUJBQXFCLEdBQUdJO0FBQ3hCSixtQkFBbUIsR0FBR0s7QUFDdEJMLGlCQUFpQixHQUFHTTtBQUNwQk4sa0JBQWUsR0FBRyxLQUFLO0FBQ3ZCLElBQUlRLHNCQUFzQkMseUlBQTBEO0FBQ3BGLElBQUlDLFdBQVdELG1IQUErQztBQUM5RCxJQUFJRSwyQkFBMkJGLG1KQUErRDtBQUM5RixJQUFJRyw0QkFBNEJILHFKQUFnRTtBQUNoRyxJQUFJSSwwQkFBMEJKLG1CQUFPQSxDQUFDLDZHQUEwQztBQUNoRixJQUFJSyx1QkFBdUJMLG1CQUFPQSxDQUFDLGdIQUErQjtBQUNsRSxJQUFJTSxlQUFlTixtQkFBT0EsQ0FBQyxxRkFBOEI7QUFDekQsSUFBSU8sVUFBVVAsbUJBQU9BLENBQUMseUVBQXdCO0FBQzlDLElBQUlRLFdBQVdMLDBCQUEwQkgsbUJBQU9BLENBQUMsdUVBQXVCO0FBQ3hFLElBQUlTLHVCQUF1QlQsbUJBQU9BLENBQUMsa0hBQW9DO0FBQ3ZFLElBQUlVLHVCQUF1QlYsbUJBQU9BLENBQUMsd0dBQStCO0FBQ2xFLElBQUlXLFFBQVFULHlCQUF5QkYsbUJBQU9BLENBQUMsNERBQVM7QUFDdEQsSUFBSVksU0FBU1osbUJBQU9BLENBQUMsOERBQVU7QUFDL0IsSUFBSWEsYUFBYWIsbUJBQU9BLENBQUMsMEZBQW9CO0FBQzdDLElBQUljLG9CQUFvQmQsbUJBQU9BLENBQUMsMEdBQTRCO0FBQzVELElBQUllLGVBQWVmLG1CQUFPQSxDQUFDLDRGQUFxQjtBQUNoRCxJQUFJZ0IsbUJBQW1CZCx5QkFBeUJGLG1CQUFPQSxDQUFDLHVDQUEwQjtBQUNsRixJQUFJaUIsZ0JB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dXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcz84Njg0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICAgIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLm1hdGNoZXNNaWRkbGV3YXJlID0gbWF0Y2hlc01pZGRsZXdhcmU7XHJcbmV4cG9ydHMuaXNMb2NhbFVSTCA9IGlzTG9jYWxVUkw7XHJcbmV4cG9ydHMuaW50ZXJwb2xhdGVBcyA9IGludGVycG9sYXRlQXM7XHJcbmV4cG9ydHMucmVzb2x2ZUhyZWYgPSByZXNvbHZlSHJlZjtcclxuZXhwb3J0cy5jcmVhdGVLZXkgPSBjcmVhdGVLZXk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcclxudmFyIF9hc3luY190b19nZW5lcmF0b3IgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fYXN5bmNfdG9fZ2VuZXJhdG9yLmpzXCIpLmRlZmF1bHQ7XHJcbnZhciBfZXh0ZW5kcyA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19leHRlbmRzLmpzXCIpLmRlZmF1bHQ7XHJcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcclxudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XHJcbnZhciBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoXCIpO1xyXG52YXIgX3JlbW92ZVRyYWlsaW5nU2xhc2ggPSByZXF1aXJlKFwiLi91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XHJcbnZhciBfcm91dGVMb2FkZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlclwiKTtcclxudmFyIF9zY3JpcHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3NjcmlwdFwiKTtcclxudmFyIF9pc0Vycm9yID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwiLi4vLi4vLi4vbGliL2lzLWVycm9yXCIpKTtcclxudmFyIF9kZW5vcm1hbGl6ZVBhZ2VQYXRoID0gcmVxdWlyZShcIi4uL3BhZ2UtcGF0aC9kZW5vcm1hbGl6ZS1wYWdlLXBhdGhcIik7XHJcbnZhciBfbm9ybWFsaXplTG9jYWxlUGF0aCA9IHJlcXVpcmUoXCIuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aFwiKTtcclxudmFyIF9taXR0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCIuLi9taXR0XCIpKTtcclxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcclxudmFyIF9pc0R5bmFtaWMgPSByZXF1aXJlKFwiLi91dGlscy9pcy1keW5hbWljXCIpO1xyXG52YXIgX3BhcnNlUmVsYXRpdmVVcmwgPSByZXF1aXJlKFwiLi91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmxcIik7XHJcbnZhciBfcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwiLi91dGlscy9xdWVyeXN0cmluZ1wiKTtcclxudmFyIF9yZXNvbHZlUmV3cml0ZXMgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlc1wiKSk7XHJcbnZhciBfcm91dGVNYXRjaGVyID0gcmVxdWlyZShcIi4vdXRpbHMvcm91dGUtbWF0Y2hlclwiKTtcclxudmFyIF9yb3V0ZVJlZ2V4ID0gcmVxdWlyZShcIi4vdXRpbHMvcm91dGUtcmVnZXhcIik7XHJcbnZhciBfZm9ybWF0VXJsID0gcmVxdWlyZShcIi4vdXRpbHMvZm9ybWF0LXVybFwiKTtcclxudmFyIF9kZXRlY3REb21haW5Mb2NhbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2RldGVjdC1kb21haW4tbG9jYWxlXCIpO1xyXG52YXIgX3BhcnNlUGF0aCA9IHJlcXVpcmUoXCIuL3V0aWxzL3BhcnNlLXBhdGhcIik7XHJcbnZhciBfYWRkTG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9hZGQtbG9jYWxlXCIpO1xyXG52YXIgX3JlbW92ZUxvY2FsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcmVtb3ZlLWxvY2FsZVwiKTtcclxudmFyIF9yZW1vdmVCYXNlUGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcmVtb3ZlLWJhc2UtcGF0aFwiKTtcclxudmFyIF9hZGRCYXNlUGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvYWRkLWJhc2UtcGF0aFwiKTtcclxudmFyIF9oYXNCYXNlUGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvaGFzLWJhc2UtcGF0aFwiKTtcclxudmFyIF9nZXROZXh0UGF0aG5hbWVJbmZvID0gcmVxdWlyZShcIi4vdXRpbHMvZ2V0LW5leHQtcGF0aG5hbWUtaW5mb1wiKTtcclxudmFyIF9mb3JtYXROZXh0UGF0aG5hbWVJbmZvID0gcmVxdWlyZShcIi4vdXRpbHMvZm9ybWF0LW5leHQtcGF0aG5hbWUtaW5mb1wiKTtcclxudmFyIF9jb21wYXJlU3RhdGVzID0gcmVxdWlyZShcIi4vdXRpbHMvY29tcGFyZS1zdGF0ZXNcIik7XHJcbnZhciBfaXNCb3QgPSByZXF1aXJlKFwiLi91dGlscy9pcy1ib3RcIik7XHJcbmZ1bmN0aW9uIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ1JvdXRlIENhbmNlbGxlZCcpLCB7XHJcbiAgICAgICAgY2FuY2VsbGVkOiB0cnVlXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBtYXRjaGVzTWlkZGxld2FyZShvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gX21hdGNoZXNNaWRkbGV3YXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gX21hdGNoZXNNaWRkbGV3YXJlKCkge1xyXG4gICAgX21hdGNoZXNNaWRkbGV3YXJlID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbioob3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoZXJzID0geWllbGQgUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMucm91dGVyLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZSgpKTtcclxuICAgICAgICBpZiAoIW1hdGNoZXJzKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgeyBwYXRobmFtZTogYXNQYXRobmFtZSAgfSA9ICgwLCBfcGFyc2VQYXRoKS5wYXJzZVBhdGgob3B0aW9ucy5hc1BhdGgpO1xyXG4gICAgICAgIC8vIHJlbW92ZSBiYXNlUGF0aCBmaXJzdCBzaW5jZSBwYXRoIHByZWZpeCBoYXMgdG8gYmUgaW4gdGhlIG9yZGVyIG9mIGAvJHtiYXNlUGF0aH0vJHtsb2NhbGV9YFxyXG4gICAgICAgIGNvbnN0IGNsZWFuZWRBcyA9ICgwLCBfaGFzQmFzZVBhdGgpLmhhc0Jhc2VQYXRoKGFzUGF0aG5hbWUpID8gKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgoYXNQYXRobmFtZSkgOiBhc1BhdGhuYW1lO1xyXG4gICAgICAgIGNvbnN0IGFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlID0gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZShjbGVhbmVkQXMsIG9wdGlvbnMubG9jYWxlKSk7XHJcbiAgICAgICAgLy8gQ2hlY2sgb25seSBwYXRoIG1hdGNoIG9uIGNsaWVudC4gTWF0Y2hpbmcgXCJoYXNcIiBzaG91bGQgYmUgZG9uZSBvbiBzZXJ2ZXJcclxuICAgICAgICAvLyB3aGVyZSB3ZSBjYW4gYWNjZXNzIG1vcmUgaW5mbyBzdWNoIGFzIGhlYWRlcnMsIEh0dHBPbmx5IGNvb2tpZSwgZXRjLlxyXG4gICAgICAgIHJldHVybiBtYXRjaGVycy5zb21lKChtKT0+bmV3IFJlZ0V4cChtLnJlZ2V4cCkudGVzdChhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSkpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gX21hdGNoZXNNaWRkbGV3YXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gc3RyaXBPcmlnaW4odXJsKSB7XHJcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzKS5nZXRMb2NhdGlvbk9yaWdpbigpO1xyXG4gICAgcmV0dXJuIHVybC5zdGFydHNXaXRoKG9yaWdpbikgPyB1cmwuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpIDogdXJsO1xyXG59XHJcbmZ1bmN0aW9uIG9taXQob2JqZWN0LCBrZXlzKSB7XHJcbiAgICBjb25zdCBvbWl0dGVkID0ge307XHJcbiAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goKGtleSk9PntcclxuICAgICAgICBpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICAgICAgICBvbWl0dGVkW2tleV0gPSBvYmplY3Rba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBvbWl0dGVkO1xyXG59XHJcbmZ1bmN0aW9uIGlzTG9jYWxVUkwodXJsKSB7XHJcbiAgICAvLyBwcmV2ZW50IGEgaHlkcmF0aW9uIG1pc21hdGNoIG9uIGhyZWYgZm9yIHVybCB3aXRoIGFuY2hvciByZWZzXHJcbiAgICBpZiAoISgwLCBfdXRpbHMpLmlzQWJzb2x1dGVVcmwodXJsKSkgcmV0dXJuIHRydWU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIGFic29sdXRlIHVybHMgY2FuIGJlIGxvY2FsIGlmIHRoZXkgYXJlIG9uIHRoZSBzYW1lIG9yaWdpblxyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uT3JpZ2luID0gKDAsIF91dGlscykuZ2V0TG9jYXRpb25PcmlnaW4oKTtcclxuICAgICAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbk9yaWdpbik7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkLm9yaWdpbiA9PT0gbG9jYXRpb25PcmlnaW4gJiYgKDAsIF9oYXNCYXNlUGF0aCkuaGFzQmFzZVBhdGgocmVzb2x2ZWQucGF0aG5hbWUpO1xyXG4gICAgfSBjYXRjaCAoXykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUFzKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSkge1xyXG4gICAgbGV0IGludGVycG9sYXRlZFJvdXRlID0gJyc7XHJcbiAgICBjb25zdCBkeW5hbWljUmVnZXggPSAoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocm91dGUpO1xyXG4gICAgY29uc3QgZHluYW1pY0dyb3VwcyA9IGR5bmFtaWNSZWdleC5ncm91cHM7XHJcbiAgICBjb25zdCBkeW5hbWljTWF0Y2hlcyA9IC8vIFRyeSB0byBtYXRjaCB0aGUgZHluYW1pYyByb3V0ZSBhZ2FpbnN0IHRoZSBhc1BhdGhcclxuICAgIChhc1BhdGhuYW1lICE9PSByb3V0ZSA/ICgwLCBfcm91dGVNYXRjaGVyKS5nZXRSb3V0ZU1hdGNoZXIoZHluYW1pY1JlZ2V4KShhc1BhdGhuYW1lKSA6ICcnKSB8fCAvLyBGYWxsIGJhY2sgdG8gcmVhZGluZyB0aGUgdmFsdWVzIGZyb20gdGhlIGhyZWZcclxuICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIHRha2UgcHJpb3JpdHk7IGFsc28gbmVlZCB0byBjaGFuZ2UgaW4gdGhlIHJvdXRlci5cclxuICAgIHF1ZXJ5O1xyXG4gICAgaW50ZXJwb2xhdGVkUm91dGUgPSByb3V0ZTtcclxuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5rZXlzKGR5bmFtaWNHcm91cHMpO1xyXG4gICAgaWYgKCFwYXJhbXMuZXZlcnkoKHBhcmFtKT0+e1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IGR5bmFtaWNNYXRjaGVzW3BhcmFtXSB8fCAnJztcclxuICAgICAgICBjb25zdCB7IHJlcGVhdCAsIG9wdGlvbmFsICB9ID0gZHluYW1pY0dyb3Vwc1twYXJhbV07XHJcbiAgICAgICAgLy8gc3VwcG9ydCBzaW5nbGUtbGV2ZWwgY2F0Y2gtYWxsXHJcbiAgICAgICAgLy8gVE9ETzogbW9yZSByb2J1c3QgaGFuZGxpbmcgZm9yIHVzZXItZXJyb3IgKHBhc3NpbmcgYC9gKVxyXG4gICAgICAgIGxldCByZXBsYWNlZCA9IGBbJHtyZXBlYXQgPyAnLi4uJyA6ICcnfSR7cGFyYW19XWA7XHJcbiAgICAgICAgaWYgKG9wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgIHJlcGxhY2VkID0gYCR7IXZhbHVlID8gJy8nIDogJyd9WyR7cmVwbGFjZWR9XWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXBlYXQgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFtcclxuICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICBdO1xyXG4gICAgICAgIHJldHVybiAob3B0aW9uYWwgfHwgcGFyYW0gaW4gZHluYW1pY01hdGNoZXMpICYmIC8vIEludGVycG9sYXRlIGdyb3VwIGludG8gZGF0YSBVUkwgaWYgcHJlc2VudFxyXG4gICAgICAgIChpbnRlcnBvbGF0ZWRSb3V0ZSA9IGludGVycG9sYXRlZFJvdXRlLnJlcGxhY2UocmVwbGFjZWQsIHJlcGVhdCA/IHZhbHVlLm1hcCgvLyB0aGVzZSB2YWx1ZXMgc2hvdWxkIGJlIGZ1bGx5IGVuY29kZWQgaW5zdGVhZCBvZiBqdXN0XHJcbiAgICAgICAgLy8gcGF0aCBkZWxpbWl0ZXIgZXNjYXBlZCBzaW5jZSB0aGV5IGFyZSBiZWluZyBpbnNlcnRlZFxyXG4gICAgICAgIC8vIGludG8gdGhlIFVSTCBhbmQgd2UgZXhwZWN0IFVSTCBlbmNvZGVkIHNlZ21lbnRzXHJcbiAgICAgICAgLy8gd2hlbiBwYXJzaW5nIGR5bmFtaWMgcm91dGUgcGFyYW1zXHJcbiAgICAgICAgKHNlZ21lbnQpPT5lbmNvZGVVUklDb21wb25lbnQoc2VnbWVudCkpLmpvaW4oJy8nKSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpIHx8ICcvJyk7XHJcbiAgICB9KSkge1xyXG4gICAgICAgIGludGVycG9sYXRlZFJvdXRlID0gJycgLy8gZGlkIG5vdCBzYXRpc2Z5IGFsbCByZXF1aXJlbWVudHNcclxuICAgICAgICA7XHJcbiAgICAvLyBuLmIuIFdlIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugd2UgaGFuZGxlIHdhcm5pbmcgZm9yIHRoaXMgY2FzZSBpblxyXG4gICAgLy8gZGV2ZWxvcG1lbnQgaW4gdGhlIGA8TGluaz5gIGNvbXBvbmVudCBkaXJlY3RseS5cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcGFyYW1zLFxyXG4gICAgICAgIHJlc3VsdDogaW50ZXJwb2xhdGVkUm91dGVcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZUhyZWYocm91dGVyLCBocmVmLCByZXNvbHZlQXMpIHtcclxuICAgIC8vIHdlIHVzZSBhIGR1bW15IGJhc2UgdXJsIGZvciByZWxhdGl2ZSB1cmxzXHJcbiAgICBsZXQgYmFzZTtcclxuICAgIGxldCB1cmxBc1N0cmluZyA9IHR5cGVvZiBocmVmID09PSAnc3RyaW5nJyA/IGhyZWYgOiAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24oaHJlZik7XHJcbiAgICAvLyByZXBlYXRlZCBzbGFzaGVzIGFuZCBiYWNrc2xhc2hlcyBpbiB0aGUgVVJMIGFyZSBjb25zaWRlcmVkXHJcbiAgICAvLyBpbnZhbGlkIGFuZCB3aWxsIG5ldmVyIG1hdGNoIGEgTmV4dC5qcyBwYWdlL2ZpbGVcclxuICAgIGNvbnN0IHVybFByb3RvTWF0Y2ggPSB1cmxBc1N0cmluZy5tYXRjaCgvXlthLXpBLVpdezEsfTpcXC9cXC8vKTtcclxuICAgIGNvbnN0IHVybEFzU3RyaW5nTm9Qcm90byA9IHVybFByb3RvTWF0Y2ggPyB1cmxBc1N0cmluZy5zbGljZSh1cmxQcm90b01hdGNoWzBdLmxlbmd0aCkgOiB1cmxBc1N0cmluZztcclxuICAgIGNvbnN0IHVybFBhcnRzID0gdXJsQXNTdHJpbmdOb1Byb3RvLnNwbGl0KCc/Jyk7XHJcbiAgICBpZiAoKHVybFBhcnRzWzBdIHx8ICcnKS5tYXRjaCgvKFxcL1xcL3xcXFxcKS8pKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCBocmVmIHBhc3NlZCB0byBuZXh0L3JvdXRlcjogJHt1cmxBc1N0cmluZ30sIHJlcGVhdGVkIGZvcndhcmQtc2xhc2hlcyAoLy8pIG9yIGJhY2tzbGFzaGVzIFxcXFwgYXJlIG5vdCB2YWxpZCBpbiB0aGUgaHJlZmApO1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRVcmwgPSAoMCwgX3V0aWxzKS5ub3JtYWxpemVSZXBlYXRlZFNsYXNoZXModXJsQXNTdHJpbmdOb1Byb3RvKTtcclxuICAgICAgICB1cmxBc1N0cmluZyA9ICh1cmxQcm90b01hdGNoID8gdXJsUHJvdG9NYXRjaFswXSA6ICcnKSArIG5vcm1hbGl6ZWRVcmw7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm4gYmVjYXVzZSBpdCBjYW5ub3QgYmUgcm91dGVkIGJ5IHRoZSBOZXh0LmpzIHJvdXRlclxyXG4gICAgaWYgKCFpc0xvY2FsVVJMKHVybEFzU3RyaW5nKSkge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlQXMgPyBbXHJcbiAgICAgICAgICAgIHVybEFzU3RyaW5nXHJcbiAgICAgICAgXSA6IHVybEFzU3RyaW5nO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBiYXNlID0gbmV3IFVSTCh1cmxBc1N0cmluZy5zdGFydHNXaXRoKCcjJykgPyByb3V0ZXIuYXNQYXRoIDogcm91dGVyLnBhdGhuYW1lLCAnaHR0cDovL24nKTtcclxuICAgIH0gY2F0Y2ggKF8pIHtcclxuICAgICAgICAvLyBmYWxsYmFjayB0byAvIGZvciBpbnZhbGlkIGFzUGF0aCB2YWx1ZXMgZS5nLiAvL1xyXG4gICAgICAgIGJhc2UgPSBuZXcgVVJMKCcvJywgJ2h0dHA6Ly9uJyk7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGZpbmFsVXJsID0gbmV3IFVSTCh1cmxBc1N0cmluZywgYmFzZSk7XHJcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUgPSAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGZpbmFsVXJsLnBhdGhuYW1lKTtcclxuICAgICAgICBsZXQgaW50ZXJwb2xhdGVkQXMgPSAnJztcclxuICAgICAgICBpZiAoKDAsIF9pc0R5bmFtaWMpLmlzRHluYW1pY1JvdXRlKGZpbmFsVXJsLnBhdGhuYW1lKSAmJiBmaW5hbFVybC5zZWFyY2hQYXJhbXMgJiYgcmVzb2x2ZUFzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gKDAsIF9xdWVyeXN0cmluZykuc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShmaW5hbFVybC5zZWFyY2hQYXJhbXMpO1xyXG4gICAgICAgICAgICBjb25zdCB7IHJlc3VsdCAsIHBhcmFtcyAgfSA9IGludGVycG9sYXRlQXMoZmluYWxVcmwucGF0aG5hbWUsIGZpbmFsVXJsLnBhdGhuYW1lLCBxdWVyeSk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGludGVycG9sYXRlZEFzID0gKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogcmVzdWx0LFxyXG4gICAgICAgICAgICAgICAgICAgIGhhc2g6IGZpbmFsVXJsLmhhc2gsXHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IG9taXQocXVlcnksIHBhcmFtcylcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHRoZSBvcmlnaW4gZGlkbid0IGNoYW5nZSwgaXQgbWVhbnMgd2UgcmVjZWl2ZWQgYSByZWxhdGl2ZSBocmVmXHJcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZmluYWxVcmwub3JpZ2luID09PSBiYXNlLm9yaWdpbiA/IGZpbmFsVXJsLmhyZWYuc2xpY2UoZmluYWxVcmwub3JpZ2luLmxlbmd0aCkgOiBmaW5hbFVybC5ocmVmO1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlQXMgPyBbXHJcbiAgICAgICAgICAgIHJlc29sdmVkSHJlZixcclxuICAgICAgICAgICAgaW50ZXJwb2xhdGVkQXMgfHwgcmVzb2x2ZWRIcmVmXHJcbiAgICAgICAgXSA6IHJlc29sdmVkSHJlZjtcclxuICAgIH0gY2F0Y2ggKF8xKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBcyA/IFtcclxuICAgICAgICAgICAgdXJsQXNTdHJpbmdcclxuICAgICAgICBdIDogdXJsQXNTdHJpbmc7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcHJlcGFyZVVybEFzKHJvdXRlciwgdXJsLCBhcykge1xyXG4gICAgLy8gSWYgdXJsIGFuZCBhcyBwcm92aWRlZCBhcyBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24sXHJcbiAgICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxyXG4gICAgbGV0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gcmVzb2x2ZUhyZWYocm91dGVyLCB1cmwsIHRydWUpO1xyXG4gICAgY29uc3Qgb3JpZ2luID0gKDAsIF91dGlscykuZ2V0TG9jYXRpb25PcmlnaW4oKTtcclxuICAgIGNvbnN0IGhyZWZIYWRPcmlnaW4gPSByZXNvbHZlZEhyZWYuc3RhcnRzV2l0aChvcmlnaW4pO1xyXG4gICAgY29uc3QgYXNIYWRPcmlnaW4gPSByZXNvbHZlZEFzICYmIHJlc29sdmVkQXMuc3RhcnRzV2l0aChvcmlnaW4pO1xyXG4gICAgcmVzb2x2ZWRIcmVmID0gc3RyaXBPcmlnaW4ocmVzb2x2ZWRIcmVmKTtcclxuICAgIHJlc29sdmVkQXMgPSByZXNvbHZlZEFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzO1xyXG4gICAgY29uc3QgcHJlcGFyZWRVcmwgPSBocmVmSGFkT3JpZ2luID8gcmVzb2x2ZWRIcmVmIDogKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgocmVzb2x2ZWRIcmVmKTtcclxuICAgIGNvbnN0IHByZXBhcmVkQXMgPSBhcyA/IHN0cmlwT3JpZ2luKHJlc29sdmVIcmVmKHJvdXRlciwgYXMpKSA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1cmw6IHByZXBhcmVkVXJsLFxyXG4gICAgICAgIGFzOiBhc0hhZE9yaWdpbiA/IHByZXBhcmVkQXMgOiAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aChwcmVwYXJlZEFzKVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcykge1xyXG4gICAgY29uc3QgY2xlYW5QYXRobmFtZSA9ICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaCgoMCwgX2Rlbm9ybWFsaXplUGFnZVBhdGgpLmRlbm9ybWFsaXplUGFnZVBhdGgocGF0aG5hbWUpKTtcclxuICAgIGlmIChjbGVhblBhdGhuYW1lID09PSAnLzQwNCcgfHwgY2xlYW5QYXRobmFtZSA9PT0gJy9fZXJyb3InKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lO1xyXG4gICAgfVxyXG4gICAgLy8gaGFuZGxlIHJlc29sdmluZyBocmVmIGZvciBkeW5hbWljIHJvdXRlc1xyXG4gICAgaWYgKCFwYWdlcy5pbmNsdWRlcyhjbGVhblBhdGhuYW1lKSkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cclxuICAgICAgICBwYWdlcy5zb21lKChwYWdlKT0+e1xyXG4gICAgICAgICAgICBpZiAoKDAsIF9pc0R5bmFtaWMpLmlzRHluYW1pY1JvdXRlKHBhZ2UpICYmICgwLCBfcm91dGVSZWdleCkuZ2V0Um91dGVSZWdleChwYWdlKS5yZS50ZXN0KGNsZWFuUGF0aG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhZ2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TWlkZGxld2FyZURhdGEoc291cmNlLCByZXNwb25zZSwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgbmV4dENvbmZpZyA9IHtcclxuICAgICAgICBiYXNlUGF0aDogb3B0aW9ucy5yb3V0ZXIuYmFzZVBhdGgsXHJcbiAgICAgICAgaTE4bjoge1xyXG4gICAgICAgICAgICBsb2NhbGVzOiBvcHRpb25zLnJvdXRlci5sb2NhbGVzXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cmFpbGluZ1NsYXNoOiBCb29sZWFuKHByb2Nlc3MuZW52Ll9fTkVYVF9UUkFJTElOR19TTEFTSClcclxuICAgIH07XHJcbiAgICBjb25zdCByZXdyaXRlSGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbmV4dGpzLXJld3JpdGUnKTtcclxuICAgIGxldCByZXdyaXRlVGFyZ2V0ID0gcmV3cml0ZUhlYWRlciB8fCByZXNwb25zZS5oZWFkZXJzLmdldCgneC1uZXh0anMtbWF0Y2hlZC1wYXRoJyk7XHJcbiAgICBjb25zdCBtYXRjaGVkUGF0aCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LW1hdGNoZWQtcGF0aCcpO1xyXG4gICAgaWYgKG1hdGNoZWRQYXRoICYmICFyZXdyaXRlVGFyZ2V0ICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcygnX19uZXh0X2RhdGFfY2F0Y2hhbGwnKSAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoJy9fZXJyb3InKSAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoJy80MDQnKSkge1xyXG4gICAgICAgIC8vIGxldmVyYWdlIHgtbWF0Y2hlZC1wYXRoIHRvIGRldGVjdCBuZXh0LmNvbmZpZy5qcyByZXdyaXRlc1xyXG4gICAgICAgIHJld3JpdGVUYXJnZXQgPSBtYXRjaGVkUGF0aDtcclxuICAgIH1cclxuICAgIGlmIChyZXdyaXRlVGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKHJld3JpdGVUYXJnZXQuc3RhcnRzV2l0aCgnLycpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJld3JpdGVUYXJnZXQgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwocmV3cml0ZVRhcmdldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGhuYW1lSW5mbyA9ICgwLCBfZ2V0TmV4dFBhdGhuYW1lSW5mbykuZ2V0TmV4dFBhdGhuYW1lSW5mbyhwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lLCB7XHJcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxyXG4gICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZXQgZnNQYXRobmFtZSA9ICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZUluZm8ucGF0aG5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLFxyXG4gICAgICAgICAgICAgICAgKDAsIF9yb3V0ZUxvYWRlcikuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLCBcclxuICAgICAgICAgICAgXSkudGhlbigoW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9XSk9PntcclxuICAgICAgICAgICAgICAgIGxldCBhcyA9ICgwLCBfYWRkTG9jYWxlKS5hZGRMb2NhbGUocGF0aG5hbWVJbmZvLnBhdGhuYW1lLCBwYXRobmFtZUluZm8ubG9jYWxlKTtcclxuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUoYXMpIHx8ICFyZXdyaXRlSGVhZGVyICYmIHBhZ2VzLmluY2x1ZGVzKCgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aCgoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aChhcyksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpLnBhdGhuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFNvdXJjZSA9ICgwLCBfZ2V0TmV4dFBhdGhuYW1lSW5mbykuZ2V0TmV4dFBhdGhuYW1lSW5mbygoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoc291cmNlKS5wYXRobmFtZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBhcyA9ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKHBhcnNlZFNvdXJjZS5wYXRobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSA9IGFzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgX3Jlc29sdmVSZXdyaXRlcykuZGVmYXVsdChhcywgcGFnZXMsIHJld3JpdGVzLCBwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCAocGF0aCk9PnJlc29sdmVEeW5hbWljUm91dGUocGF0aCwgcGFnZXMpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1hdGNoZWRQYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSByZXN1bHQucGFyc2VkQXMucGF0aG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzID0gcGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCByZXN1bHQucGFyc2VkQXMucXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXBhZ2VzLmluY2x1ZGVzKGZzUGF0aG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUoZnNQYXRobmFtZSwgcGFnZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFBhdGhuYW1lICE9PSBmc1BhdGhuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzUGF0aG5hbWUgPSByZXNvbHZlZFBhdGhuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9ICFwYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSA/IHJlc29sdmVEeW5hbWljUm91dGUoKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKCgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKS5wYXRobmFtZSwgcGFnZXMpIDogZnNQYXRobmFtZTtcclxuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocmVzb2x2ZWRIcmVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSAoMCwgX3JvdXRlTWF0Y2hlcikuZ2V0Um91dGVNYXRjaGVyKCgwLCBfcm91dGVSZWdleCkuZ2V0Um91dGVSZWdleChyZXNvbHZlZEhyZWYpKShhcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCBtYXRjaGVzIHx8IHt9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Jld3JpdGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFzOiBwYXJzZWRSZXdyaXRlVGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkSHJlZlxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNyYyA9ICgwLCBfcGFyc2VQYXRoKS5wYXJzZVBhdGgoc291cmNlKTtcclxuICAgICAgICBjb25zdCBwYXRobmFtZSA9ICgwLCBfZm9ybWF0TmV4dFBhdGhuYW1lSW5mbykuZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyhfZXh0ZW5kcyh7fSwgKDAsIF9nZXROZXh0UGF0aG5hbWVJbmZvKS5nZXROZXh0UGF0aG5hbWVJbmZvKHNyYy5wYXRobmFtZSwge1xyXG4gICAgICAgICAgICBuZXh0Q29uZmlnLFxyXG4gICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcclxuICAgICAgICB9KSwge1xyXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxyXG4gICAgICAgICAgICBidWlsZElkOiAnJ1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICAgICAgdHlwZTogJ3JlZGlyZWN0LWV4dGVybmFsJyxcclxuICAgICAgICAgICAgZGVzdGluYXRpb246IGAke3BhdGhuYW1lfSR7c3JjLnF1ZXJ5fSR7c3JjLmhhc2h9YFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVkaXJlY3RUYXJnZXQgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1uZXh0anMtcmVkaXJlY3QnKTtcclxuICAgIGlmIChyZWRpcmVjdFRhcmdldCkge1xyXG4gICAgICAgIGlmIChyZWRpcmVjdFRhcmdldC5zdGFydHNXaXRoKCcvJykpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3JjID0gKDAsIF9wYXJzZVBhdGgpLnBhcnNlUGF0aChyZWRpcmVjdFRhcmdldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXROZXh0UGF0aG5hbWVJbmZvKS5mb3JtYXROZXh0UGF0aG5hbWVJbmZvKF9leHRlbmRzKHt9LCAoMCwgX2dldE5leHRQYXRobmFtZUluZm8pLmdldE5leHRQYXRobmFtZUluZm8oc3JjLnBhdGhuYW1lLCB7XHJcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxyXG4gICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXHJcbiAgICAgICAgICAgIH0pLCB7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxyXG4gICAgICAgICAgICAgICAgYnVpbGRJZDogJydcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdyZWRpcmVjdC1pbnRlcm5hbCcsXHJcbiAgICAgICAgICAgICAgICBuZXdBczogYCR7cGF0aG5hbWV9JHtzcmMucXVlcnl9JHtzcmMuaGFzaH1gLFxyXG4gICAgICAgICAgICAgICAgbmV3VXJsOiBgJHtwYXRobmFtZX0ke3NyYy5xdWVyeX0ke3NyYy5oYXNofWBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xyXG4gICAgICAgICAgICB0eXBlOiAncmVkaXJlY3QtZXh0ZXJuYWwnLFxyXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogcmVkaXJlY3RUYXJnZXRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xyXG4gICAgICAgIHR5cGU6ICduZXh0J1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gd2l0aE1pZGRsZXdhcmVFZmZlY3RzKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBtYXRjaGVzTWlkZGxld2FyZShvcHRpb25zKS50aGVuKChtYXRjaGVzKT0+e1xyXG4gICAgICAgIGlmIChtYXRjaGVzICYmIG9wdGlvbnMuZmV0Y2hEYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmZldGNoRGF0YSgpLnRoZW4oKGRhdGEpPT5nZXRNaWRkbGV3YXJlRGF0YShkYXRhLmRhdGFIcmVmLCBkYXRhLnJlc3BvbnNlLCBvcHRpb25zKS50aGVuKChlZmZlY3QpPT4oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZjogZGF0YS5kYXRhSHJlZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGRhdGEuY2FjaGVLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IGRhdGEuanNvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGRhdGEucmVzcG9uc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGRhdGEudGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpKS5jYXRjaCgoX2Vycik9PntcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogVE9ETzogUmV2aXNpdCB0aGlzIGluIHRoZSBmdXR1cmUuXHJcbiAgICAgICAgICAgKiBGb3Igbm93IHdlIHdpbGwgbm90IGNvbnNpZGVyIG1pZGRsZXdhcmUgZGF0YSBlcnJvcnMgdG8gYmUgZmF0YWwuXHJcbiAgICAgICAgICAgKiBtYXliZSB3ZSBzaG91bGQgcmV2aXNpdCBpbiB0aGUgZnV0dXJlLlxyXG4gICAgICAgICAgICovIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9KTtcclxufVxyXG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiB3aW5kb3cuaGlzdG9yeSAmJiAhIWZ1bmN0aW9uKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBsZXQgdiA9ICdfX25leHQnO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZXF1ZW5jZXNcclxuICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh2LCB2KSwgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh2KSwgdHJ1ZTtcclxuICAgIH0gY2F0Y2ggKG4pIHt9XHJcbn0oKTtcclxuY29uc3QgU1NHX0RBVEFfTk9UX0ZPVU5EID0gU3ltYm9sKCdTU0dfREFUQV9OT1RfRk9VTkQnKTtcclxuZnVuY3Rpb24gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gZmV0Y2godXJsLCB7XHJcbiAgICAgICAgLy8gQ29va2llcyBhcmUgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgTmV4dC5qcycgU1NHIFwiUHJldmlldyBNb2RlXCIuXHJcbiAgICAgICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyA+IGBmZXRjaGAgd29u4oCZdCBzZW5kIGNvb2tpZXMsIHVubGVzcyB5b3Ugc2V0IHRoZSBjcmVkZW50aWFscyBpbml0XHJcbiAgICAgICAgLy8gPiBvcHRpb24uXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcclxuICAgICAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXHJcbiAgICAgICAgLy8gPiBvcHRpb24gaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0LlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xyXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxyXG4gICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgJ0dFVCcsXHJcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5oZWFkZXJzLCB7XHJcbiAgICAgICAgICAgICd4LW5leHRqcy1kYXRhJzogJzEnXHJcbiAgICAgICAgfSlcclxuICAgIH0pLnRoZW4oKHJlc3BvbnNlKT0+e1xyXG4gICAgICAgIHJldHVybiAhcmVzcG9uc2Uub2sgJiYgYXR0ZW1wdHMgPiAxICYmIHJlc3BvbnNlLnN0YXR1cyA+PSA1MDAgPyBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMgLSAxLCBvcHRpb25zKSA6IHJlc3BvbnNlO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlU21vb3RoU2Nyb2xsKGZuKSB7XHJcbiAgICBjb25zdCBodG1sRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICAgIGNvbnN0IGV4aXN0aW5nID0gaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3I7XHJcbiAgICBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9ICdhdXRvJztcclxuICAgIGZuKCk7XHJcbiAgICBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IGV4aXN0aW5nO1xyXG59XHJcbmZ1bmN0aW9uIHRyeVRvUGFyc2VBc0pTT04odGV4dCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YSh7IGRhdGFIcmVmICwgaW5mbGlnaHRDYWNoZSAsIGlzUHJlZmV0Y2ggLCBoYXNNaWRkbGV3YXJlICwgaXNTZXJ2ZXJSZW5kZXIgLCBwYXJzZUpTT04gLCBwZXJzaXN0Q2FjaGUgLCBpc0JhY2tncm91bmQgLCB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgIH0pIHtcclxuICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgIH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XHJcbiAgICB2YXIgcmVmMTtcclxuICAgIGNvbnN0IGdldERhdGEgPSAocGFyYW1zKT0+e1xyXG4gICAgICAgIHJldHVybiBmZXRjaFJldHJ5KGRhdGFIcmVmLCBpc1NlcnZlclJlbmRlciA/IDMgOiAxLCB7XHJcbiAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIGlzUHJlZmV0Y2ggPyB7XHJcbiAgICAgICAgICAgICAgICBwdXJwb3NlOiAncHJlZmV0Y2gnXHJcbiAgICAgICAgICAgIH0gOiB7fSwgaXNQcmVmZXRjaCAmJiBoYXNNaWRkbGV3YXJlID8ge1xyXG4gICAgICAgICAgICAgICAgJ3gtbWlkZGxld2FyZS1wcmVmZXRjaCc6ICcxJ1xyXG4gICAgICAgICAgICB9IDoge30pLFxyXG4gICAgICAgICAgICBtZXRob2Q6IChyZWYxID0gcGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbXMubWV0aG9kKSAhPSBudWxsID8gcmVmMSA6ICdHRVQnXHJcbiAgICAgICAgfSkudGhlbigocmVzcG9uc2UpPT57XHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5vayAmJiAocGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbXMubWV0aG9kKSA9PT0gJ0hFQUQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIGpzb246IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCkudGhlbigodGV4dCk9PntcclxuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hlbiB0aGUgZGF0YSByZXNwb25zZSBpcyBhIHJlZGlyZWN0IGJlY2F1c2Ugb2YgYSBtaWRkbGV3YXJlXHJcbiAgICAgICAgICAgICAqIHdlIGRvIG5vdCBjb25zaWRlciBpdCBhbiBlcnJvci4gVGhlIGhlYWRlcnMgbXVzdCBicmluZyB0aGVcclxuICAgICAgICAgICAgICogbWFwcGVkIGxvY2F0aW9uLlxyXG4gICAgICAgICAgICAgKiBUT0RPOiBDaGFuZ2UgdGhlIHN0YXR1cyBjb2RlIGluIHRoZSBoYW5kbGVyLlxyXG4gICAgICAgICAgICAgKi8gaWYgKGhhc01pZGRsZXdhcmUgJiYgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAzMDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgMzA3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAzMDhcclxuICAgICAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbjoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc01pZGRsZXdhcmUgJiYgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZWYgPSB0cnlUb1BhcnNlQXNKU09OKHRleHQpKSA9PSBudWxsID8gdm9pZCAwIDogcmVmLm5vdEZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmQ6IFNTR19EQVRBX05PVF9GT1VORFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzXHJcbiAgICAgICAgICAgICAqIGNhdXNlZCBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50b1xyXG4gICAgICAgICAgICAgKiBhbiBpbmZpbml0ZSBsb29wLlxyXG4gICAgICAgICAgICAgKi8gaWYgKCFpc1NlcnZlclJlbmRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3JvdXRlTG9hZGVyKS5tYXJrQXNzZXRFcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcclxuICAgICAgICAgICAgICAgICAgICBqc29uOiBwYXJzZUpTT04gPyB0cnlUb1BhcnNlQXNKU09OKHRleHQpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KS50aGVuKChkYXRhKT0+e1xyXG4gICAgICAgICAgICBpZiAoIXBlcnNpc3RDYWNoZSB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nIHx8IGRhdGEucmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbWlkZGxld2FyZS1jYWNoZScpID09PSAnbm8tY2FjaGUnKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcclxuICAgICAgICAgICAgaWYgKCF1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UgPT09ICdGYWlsZWQgdG8gZmV0Y2gnKSB7XHJcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlTG9hZGVyKS5tYXJrQXNzZXRFcnJvcihlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyB3aGVuIHNraXBwaW5nIGNsaWVudCBjYWNoZSB3ZSB3YWl0IHRvIHVwZGF0ZVxyXG4gICAgLy8gaW5mbGlnaHQgY2FjaGUgdW50aWwgc3VjY2Vzc2Z1bCBkYXRhIHJlc3BvbnNlXHJcbiAgICAvLyB0aGlzIGFsbG93cyByYWNpbmcgY2xpY2sgZXZlbnQgd2l0aCBmZXRjaGluZyBuZXdlciBkYXRhXHJcbiAgICAvLyB3aXRob3V0IGJsb2NraW5nIG5hdmlnYXRpb24gd2hlbiBzdGFsZSBkYXRhIGlzIGF2YWlsYWJsZVxyXG4gICAgaWYgKHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAmJiBwZXJzaXN0Q2FjaGUpIHtcclxuICAgICAgICByZXR1cm4gZ2V0RGF0YSh7fSkudGhlbigoZGF0YSk9PntcclxuICAgICAgICAgICAgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBQcm9taXNlLnJlc29sdmUoZGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBnZXREYXRhKGlzQmFja2dyb3VuZCA/IHtcclxuICAgICAgICBtZXRob2Q6ICdIRUFEJ1xyXG4gICAgfSA6IHt9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVLZXkoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgMTApO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHsgdXJsICwgcm91dGVyICB9KSB7XHJcbiAgICAvLyBlbnN1cmUgd2UgZG9uJ3QgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvbiB0byB0aGUgc2FtZVxyXG4gICAgLy8gVVJMIGFzIHRoaXMgY2FuIGVuZCB1cCB3aXRoIGFuIGluZmluaXRlIHJlZnJlc2hcclxuICAgIGlmICh1cmwgPT09ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKCgwLCBfYWRkTG9jYWxlKS5hZGRMb2NhbGUocm91dGVyLmFzUGF0aCwgcm91dGVyLmxvY2FsZSkpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhcmlhbnQ6IGF0dGVtcHRlZCB0byBoYXJkIG5hdmlnYXRlIHRvIHRoZSBzYW1lIFVSTCAke3VybH0gJHtsb2NhdGlvbi5ocmVmfWApO1xyXG4gICAgfVxyXG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XHJcbn1cclxuY29uc3QgZ2V0Q2FuY2VsbGVkSGFuZGxlciA9ICh7IHJvdXRlICwgcm91dGVyICB9KT0+e1xyXG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xyXG4gICAgY29uc3QgY2FuY2VsID0gcm91dGVyLmNsYyA9ICgpPT57XHJcbiAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSAoKT0+e1xyXG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEFib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJHtyb3V0ZX1cImApO1xyXG4gICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNhbmNlbCA9PT0gcm91dGVyLmNsYykge1xyXG4gICAgICAgICAgICByb3V0ZXIuY2xjID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGhhbmRsZUNhbmNlbGxlZDtcclxufTtcclxuY2xhc3MgUm91dGVyIHtcclxuICAgIHJlbG9hZCgpIHtcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBHbyBiYWNrIGluIGhpc3RvcnlcclxuICAgKi8gYmFjaygpIHtcclxuICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBHbyBmb3J3YXJkIGluIGhpc3RvcnlcclxuICAgKi8gZm9yd2FyZCgpIHtcclxuICAgICAgICB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXHJcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcclxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xyXG4gICAqLyBwdXNoKHVybCwgYXMsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlIHdoZW4gd2UgdXBkYXRlIGhpc3RvcnkgYmVmb3JlIHJvdXRlIGNoYW5nZVxyXG4gICAgICAgICAgICAvLyBpcyBjb21wbGV0ZSwgYXMgdGhlIHBvcHN0YXRlIGV2ZW50IHNob3VsZCBoYW5kbGUgdGhpcyBjYXB0dXJlLlxyXG4gICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3Qgc2Nyb2xsIHBvc2l0aW9uIHJpZ2h0IGJlZm9yZSBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2U6XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5fa2V5LCBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYucGFnZVhPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgICh7IHVybCAsIGFzICB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3B1c2hTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogUGVyZm9ybXMgYSBgcmVwbGFjZVN0YXRlYCB3aXRoIGFyZ3VtZW50c1xyXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXHJcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcclxuICAgKi8gcmVwbGFjZSh1cmwsIGFzLCBvcHRpb25zID0ge30pIHtcclxuICAgICAgICAoeyB1cmwgLCBhcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIGNoYW5nZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMsIGZvcmNlZFNjcm9sbCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKCkge1xyXG4gICAgICAgICAgICBpZiAoIWlzTG9jYWxVUkwodXJsKSkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xyXG4gICAgICAgICAgICAgICAgICAgIHVybCxcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzIGNsaWVudC1zaWRlXHJcbiAgICAgICAgICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcclxuICAgICAgICAgICAgLy8gYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXHJcbiAgICAgICAgICAgIGNvbnN0IGlzUXVlcnlVcGRhdGluZyA9IG9wdGlvbnMuX2g7XHJcbiAgICAgICAgICAgIGxldCBzaG91bGRSZXNvbHZlSHJlZiA9IGlzUXVlcnlVcGRhdGluZyB8fCBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiB8fCAoMCwgX3BhcnNlUGF0aCkucGFyc2VQYXRoKHVybCkucGF0aG5hbWUgPT09ICgwLCBfcGFyc2VQYXRoKS5wYXJzZVBhdGgoYXMpLnBhdGhuYW1lO1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0U3RhdGUgPSBfZXh0ZW5kcyh7fSwgX3RoaXMuc3RhdGUpO1xyXG4gICAgICAgICAgICAvLyBmb3Igc3RhdGljIHBhZ2VzIHdpdGggcXVlcnkgcGFyYW1zIGluIHRoZSBVUkwgd2UgZGVsYXlcclxuICAgICAgICAgICAgLy8gbWFya2luZyB0aGUgcm91dGVyIHJlYWR5IHVudGlsIGFmdGVyIHRoZSBxdWVyeSBpcyB1cGRhdGVkXHJcbiAgICAgICAgICAgIC8vIG9yIGEgbmF2aWdhdGlvbiBoYXMgb2NjdXJyZWRcclxuICAgICAgICAgICAgY29uc3QgcmVhZHlTdGF0ZUNoYW5nZSA9IF90aGlzLmlzUmVhZHkgIT09IHRydWU7XHJcbiAgICAgICAgICAgIF90aGlzLmlzUmVhZHkgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBpc1NzciA9IF90aGlzLmlzU3NyO1xyXG4gICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaXNTc3IgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiBhIHJvdXRlIHRyYW5zaXRpb24gaXMgYWxyZWFkeSBpbiBwcm9ncmVzcyBiZWZvcmVcclxuICAgICAgICAgICAgLy8gdGhlIHF1ZXJ5IHVwZGF0aW5nIGlzIHRyaWdnZXJlZCBpZ25vcmUgcXVlcnkgdXBkYXRpbmdcclxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBfdGhpcy5jbGMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwcmV2TG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcclxuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UgPyBfdGhpcy5kZWZhdWx0TG9jYWxlIDogb3B0aW9ucy5sb2NhbGUgfHwgbmV4dFN0YXRlLmxvY2FsZTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBuZXh0U3RhdGUubG9jYWxlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXMgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoKDAsIF9oYXNCYXNlUGF0aCkuaGFzQmFzZVBhdGgoYXMpID8gKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgoYXMpIDogYXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChwYXJzZWRBcy5wYXRobmFtZSwgX3RoaXMubG9jYWxlcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgocGFyc2VkQXMucGF0aG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFzID0gKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKTtcclxuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aCgoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgoKDAsIF9oYXNCYXNlUGF0aCkuaGFzQmFzZVBhdGgodXJsKSA/ICgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKHVybCkgOiB1cmwsIF90aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBkaWROYXZpZ2F0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXHJcbiAgICAgICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cclxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZjtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbG9jYWxlIGlzbid0IGNvbmZpZ3VyZWQgaGFyZCBuYXZpZ2F0ZSB0byBzaG93IDQwNCBwYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoKHJlZiA9IF90aGlzLmxvY2FsZXMpID09IG51bGwgPyB2b2lkIDAgOiByZWYuaW5jbHVkZXMobmV4dFN0YXRlLmxvY2FsZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZShwYXJzZWRBcy5wYXRobmFtZSwgbmV4dFN0YXRlLmxvY2FsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9ICgwLCBfZGV0ZWN0RG9tYWluTG9jYWxlKS5kZXRlY3REb21haW5Mb2NhbGUoX3RoaXMuZG9tYWluTG9jYWxlcywgdW5kZWZpbmVkLCBuZXh0U3RhdGUubG9jYWxlKTtcclxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxyXG4gICAgICAgICAgICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBuYXZpZ2F0aW5nIHRvIGEgZG9tYWluIGxvY2FsZSBlbnN1cmUgd2UgcmVkaXJlY3QgdG8gdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVjdCBkb21haW5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRpZE5hdmlnYXRlICYmIGRldGVjdGVkRG9tYWluICYmIF90aGlzLmlzTG9jYWxlRG9tYWluICYmIHNlbGYubG9jYXRpb24uaG9zdG5hbWUgIT09IGRldGVjdGVkRG9tYWluLmRvbWFpbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vQmFzZVBhdGggPSAoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aChhcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYGh0dHAke2RldGVjdGVkRG9tYWluLmh0dHAgPyAnJyA6ICdzJ306Ly8ke2RldGVjdGVkRG9tYWluLmRvbWFpbn0keygwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKGAke25leHRTdGF0ZS5sb2NhbGUgPT09IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGUgPyAnJyA6IGAvJHtuZXh0U3RhdGUubG9jYWxlfWB9JHthc05vQmFzZVBhdGggPT09ICcvJyA/ICcnIDogYXNOb0Jhc2VQYXRofWAgfHwgJy8nKX1gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkaWROYXZpZ2F0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcclxuICAgICAgICAgICAgaWYgKF91dGlscy5TVCkge1xyXG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyaygncm91dGVDaGFuZ2UnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IHNoYWxsb3cgPWZhbHNlICwgc2Nyb2xsID10cnVlICB9ID0gb3B0aW9ucztcclxuICAgICAgICAgICAgY29uc3Qgcm91dGVQcm9wcyA9IHtcclxuICAgICAgICAgICAgICAgIHNoYWxsb3dcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKF90aGlzLl9pbkZsaWdodFJvdXRlICYmIF90aGlzLmNsYykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1Nzcikge1xyXG4gICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSwgX3RoaXMuX2luRmxpZ2h0Um91dGUsIHJvdXRlUHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2xjKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jbGMgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzID0gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZSgoMCwgX2hhc0Jhc2VQYXRoKS5oYXNCYXNlUGF0aChhcykgPyAoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aChhcykgOiBhcywgb3B0aW9ucy5sb2NhbGUsIF90aGlzLmRlZmF1bHRMb2NhbGUpKTtcclxuICAgICAgICAgICAgY29uc3QgY2xlYW5lZEFzID0gKDAsIF9yZW1vdmVMb2NhbGUpLnJlbW92ZUxvY2FsZSgoMCwgX2hhc0Jhc2VQYXRoKS5oYXNCYXNlUGF0aChhcykgPyAoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aChhcykgOiBhcywgbmV4dFN0YXRlLmxvY2FsZSk7XHJcbiAgICAgICAgICAgIF90aGlzLl9pbkZsaWdodFJvdXRlID0gYXM7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZUNoYW5nZSA9IHByZXZMb2NhbGUgIT09IG5leHRTdGF0ZS5sb2NhbGU7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXHJcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBub3QgcHJvY2VlZC4gV2Ugc2hvdWxkIG9ubHkgY2hhbmdlIHRoZSBzdGF0ZS5cclxuICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgX3RoaXMub25seUFIYXNoQ2hhbmdlKGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlLmFzUGF0aCA9IGNsZWFuZWRBcztcclxuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZVN0YXJ0JywgYXMsIHJvdXRlUHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0aGUgcmVzb2x2ZWQgaHJlZiB3aGVuIG9ubHkgYSBoYXNoIGNoYW5nZT9cclxuICAgICAgICAgICAgICAgIF90aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGw6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2Nyb2xsVG9IYXNoKGNsZWFuZWRBcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLnNldChuZXh0U3RhdGUsIF90aGlzLmNvbXBvbmVudHNbbmV4dFN0YXRlLnJvdXRlXSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc0Vycm9yKS5kZWZhdWx0KGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnIsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZUNvbXBsZXRlJywgYXMsIHJvdXRlUHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCh1cmwpO1xyXG4gICAgICAgICAgICBsZXQgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gcGFyc2VkO1xyXG4gICAgICAgICAgICAvLyBUaGUgYnVpbGQgbWFuaWZlc3QgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBhdXRvLXN0YXRpYyBkeW5hbWljIHBhZ2VzXHJcbiAgICAgICAgICAgIC8vIGdldCB0aGVpciBxdWVyeSBwYXJhbWV0ZXJzIHRvIGFsbG93IGVuc3VyaW5nIHRoZXkgY2FuIGJlIHBhcnNlZCBwcm9wZXJseVxyXG4gICAgICAgICAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xyXG4gICAgICAgICAgICBsZXQgcGFnZXMsIHJld3JpdGVzO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9XSA9IHlpZWxkIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9yb3V0ZUxvYWRlcikuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZSgpLCBcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGZhaWwgdG8gcmVzb2x2ZSB0aGUgcGFnZSBsaXN0IG9yIGNsaWVudC1idWlsZCBtYW5pZmVzdCwgd2UgbXVzdFxyXG4gICAgICAgICAgICAgICAgLy8gZG8gYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uOlxyXG4gICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xyXG4gICAgICAgICAgICAgICAgICAgIHVybDogYXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgYXNrZWQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IFVSTCB3ZSBzaG91bGQgcmVsb2FkIHRoZSBjdXJyZW50IHBhZ2VcclxuICAgICAgICAgICAgLy8gKG5vdCBsb2NhdGlvbi5yZWxvYWQoKSBidXQgcmVsb2FkIGdldEluaXRpYWxQcm9wcyBhbmQgb3RoZXIgTmV4dC5qcyBzdHVmZnMpXHJcbiAgICAgICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcclxuICAgICAgICAgICAgLy8gYXMgdGhpcyBzaG91bGQgbm90IGdvIGludG8gdGhlIGhpc3RvcnkgKFRoYXQncyBob3cgYnJvd3NlcnMgd29yaylcclxuICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgdGhlIG5ldyBhc1BhdGggdG8gdGhlIGN1cnJlbnQgYXNQYXRoLCBub3QgdGhlIHVybFxyXG4gICAgICAgICAgICBpZiAoIV90aGlzLnVybElzTmV3KGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gJ3JlcGxhY2VTdGF0ZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhcyB2YWx1ZSB1c2luZyByZXdyaXRlcyBmb3IgZHluYW1pYyBTU0dcclxuICAgICAgICAgICAgLy8gcGFnZXMgdG8gYWxsb3cgYnVpbGRpbmcgdGhlIGRhdGEgVVJMIGNvcnJlY3RseVxyXG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzO1xyXG4gICAgICAgICAgICAvLyB1cmwgYW5kIGFzIHNob3VsZCBhbHdheXMgYmUgcHJlZml4ZWQgd2l0aCBiYXNlUGF0aCBieSB0aGlzXHJcbiAgICAgICAgICAgIC8vIHBvaW50IGJ5IGVpdGhlciBuZXh0L2xpbmsgb3Igcm91dGVyLnB1c2gvcmVwbGFjZSBzbyBzdHJpcCB0aGVcclxuICAgICAgICAgICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcclxuICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZSA/ICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaCgoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aChwYXRobmFtZSkpIDogcGF0aG5hbWU7XHJcbiAgICAgICAgICAgIGxldCByb3V0ZSA9ICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzUGF0aG5hbWUgPSBhcy5zdGFydHNXaXRoKCcvJykgJiYgKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKGFzKS5wYXRobmFtZTtcclxuICAgICAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlUmV3cml0ZSA9ICEhKHBhcnNlZEFzUGF0aG5hbWUgJiYgcm91dGUgIT09IHBhcnNlZEFzUGF0aG5hbWUgJiYgKCEoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocm91dGUpIHx8ICEoMCwgX3JvdXRlTWF0Y2hlcikuZ2V0Um91dGVNYXRjaGVyKCgwLCBfcm91dGVSZWdleCkuZ2V0Um91dGVSZWdleChyb3V0ZSkpKHBhcnNlZEFzUGF0aG5hbWUpKSk7XHJcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGF0dGVtcHQgcmVzb2x2ZSBhc1BhdGggd2hlbiB3ZSBuZWVkIHRvIGV4ZWN1dGVcclxuICAgICAgICAgICAgLy8gbWlkZGxld2FyZSBhcyB0aGUgcmVzb2x2aW5nIHdpbGwgb2NjdXIgc2VydmVyLXNpZGVcclxuICAgICAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlTWF0Y2ggPSB5aWVsZCBtYXRjaGVzTWlkZGxld2FyZSh7XHJcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGFzLFxyXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxyXG4gICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hhbGxvdyAmJiBpc01pZGRsZXdhcmVNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBfdGhpcy5wYXRobmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIGlzTWlkZGxld2FyZU1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICBzaG91bGRSZXNvbHZlSHJlZiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRSZXNvbHZlSHJlZiAmJiBwYXRobmFtZSAhPT0gJy9fZXJyb3InKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhcy5zdGFydHNXaXRoKCcvJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9ICgwLCBfcmVzb2x2ZVJld3JpdGVzKS5kZWZhdWx0KCgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKCgwLCBfYWRkTG9jYWxlKS5hZGRMb2NhbGUoY2xlYW5lZEFzLCBuZXh0U3RhdGUubG9jYWxlKSwgdHJ1ZSksIHBhZ2VzLCByZXdyaXRlcywgcXVlcnksIChwKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwLCBwYWdlcyksIF90aGlzLmxvY2FsZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5leHRlcm5hbERlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMgPSByZXdyaXRlc1Jlc3VsdC5hc1BhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgocGF0aG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aChwYXRobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNMb2NhbFVSTChhcykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhyZWY6IFwiJHt1cmx9XCIgYW5kIGFzOiBcIiR7YXN9XCIsIHJlY2VpdmVkIHJlbGF0aXZlIGhyZWYgYW5kIGV4dGVybmFsIGFzYCArIGBcXG5TZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLXJlbGF0aXZlLXVybC1leHRlcm5hbC1hc2ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xyXG4gICAgICAgICAgICAgICAgICAgIHVybDogYXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlTG9jYWxlKS5yZW1vdmVMb2NhbGUoKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgocmVzb2x2ZWRBcyksIG5leHRTdGF0ZS5sb2NhbGUpO1xyXG4gICAgICAgICAgICByb3V0ZSA9ICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XHJcbiAgICAgICAgICAgIGxldCByb3V0ZU1hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocm91dGUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybChyZXNvbHZlZEFzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzUGF0aG5hbWUgPSBwYXJzZWRBcy5wYXRobmFtZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocm91dGUpO1xyXG4gICAgICAgICAgICAgICAgcm91dGVNYXRjaCA9ICgwLCBfcm91dGVNYXRjaGVyKS5nZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkoYXNQYXRobmFtZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRJbnRlcnBvbGF0ZSA9IHJvdXRlID09PSBhc1BhdGhuYW1lO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGVkQXMgPSBzaG91bGRJbnRlcnBvbGF0ZSA/IGludGVycG9sYXRlQXMocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KSA6IHt9O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyb3V0ZU1hdGNoIHx8IHNob3VsZEludGVycG9sYXRlICYmICFpbnRlcnBvbGF0ZWRBcy5yZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaXNzaW5nUGFyYW1zID0gT2JqZWN0LmtleXMocm91dGVSZWdleC5ncm91cHMpLmZpbHRlcigocGFyYW0pPT4hcXVlcnlbcGFyYW1dICYmICFyb3V0ZVJlZ2V4Lmdyb3Vwc1twYXJhbV0ub3B0aW9uYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDAgJiYgIWlzTWlkZGxld2FyZU1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7c2hvdWxkSW50ZXJwb2xhdGUgPyBgSW50ZXJwb2xhdGluZyBocmVmYCA6IGBNaXNtYXRjaGluZyBcXGBhc1xcYCBhbmQgXFxgaHJlZlxcYGB9IGZhaWxlZCB0byBtYW51YWxseSBwcm92aWRlIGAgKyBgdGhlIHBhcmFtczogJHttaXNzaW5nUGFyYW1zLmpvaW4oJywgJyl9IGluIHRoZSBcXGBocmVmXFxgJ3MgXFxgcXVlcnlcXGBgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKHNob3VsZEludGVycG9sYXRlID8gYFRoZSBwcm92aWRlZCBcXGBocmVmXFxgICgke3VybH0pIHZhbHVlIGlzIG1pc3NpbmcgcXVlcnkgdmFsdWVzICgke21pc3NpbmdQYXJhbXMuam9pbignLCAnKX0pIHRvIGJlIGludGVycG9sYXRlZCBwcm9wZXJseS4gYCA6IGBUaGUgcHJvdmlkZWQgXFxgYXNcXGAgdmFsdWUgKCR7YXNQYXRobmFtZX0pIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBcXGBocmVmXFxgIHZhbHVlICgke3JvdXRlfSkuIGApICsgYFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvJHtzaG91bGRJbnRlcnBvbGF0ZSA/ICdocmVmLWludGVycG9sYXRpb24tZmFpbGVkJyA6ICdpbmNvbXBhdGlibGUtaHJlZi1hcyd9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzaG91bGRJbnRlcnBvbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzID0gKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZEFzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBpbnRlcnBvbGF0ZWRBcy5yZXN1bHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBvbWl0KHF1ZXJ5LCBpbnRlcnBvbGF0ZWRBcy5wYXJhbXMpXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNZXJnZSBwYXJhbXMgaW50byBgcXVlcnlgLCBvdmVyd3JpdGluZyBhbnkgc3BlY2lmaWVkIGluIHNlYXJjaFxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIHJvdXRlTWF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlU3RhcnQnLCBhcywgcm91dGVQcm9wcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciByZWYyLCByZWYzO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJvdXRlSW5mbyA9IHlpZWxkIF90aGlzLmdldFJvdXRlSW5mbyh7XHJcbiAgICAgICAgICAgICAgICAgICAgcm91dGUsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgICAgICAgICAgYXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyxcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcclxuICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogaXNNaWRkbGV3YXJlTWF0Y2gsXHJcbiAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlOiBvcHRpb25zLnVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSxcclxuICAgICAgICAgICAgICAgICAgICBpc1F1ZXJ5VXBkYXRpbmc6IGlzUXVlcnlVcGRhdGluZyAmJiAhX3RoaXMuaXNGYWxsYmFjayxcclxuICAgICAgICAgICAgICAgICAgICBpc01pZGRsZXdhcmVSZXdyaXRlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmICgncm91dGUnIGluIHJvdXRlSW5mbyAmJiBpc01pZGRsZXdhcmVNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcm91dGVJbmZvLnJvdXRlIHx8IHJvdXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlID0gcGF0aG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyb3V0ZVByb3BzLnNoYWxsb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCByb3V0ZUluZm8ucXVlcnkgfHwge30sIHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xlYW5lZFBhcnNlZFBhdGhuYW1lID0gKDAsIF9oYXNCYXNlUGF0aCkuaGFzQmFzZVBhdGgocGFyc2VkLnBhdGhuYW1lKSA/ICgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKHBhcnNlZC5wYXRobmFtZSkgOiBwYXJzZWQucGF0aG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlTWF0Y2ggJiYgcGF0aG5hbWUgIT09IGNsZWFuZWRQYXJzZWRQYXRobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyb3V0ZU1hdGNoKS5mb3JFYWNoKChrZXkpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVNYXRjaCAmJiBxdWVyeVtrZXldID09PSByb3V0ZU1hdGNoW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcXVlcnlba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocGF0aG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeGVkQXMgPSAhcm91dGVQcm9wcy5zaGFsbG93ICYmIHJvdXRlSW5mby5yZXNvbHZlZEFzID8gcm91dGVJbmZvLnJlc29sdmVkQXMgOiAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aCgoMCwgX2FkZExvY2FsZSkuYWRkTG9jYWxlKG5ldyBVUkwoYXMsIGxvY2F0aW9uLmhyZWYpLnBhdGhuYW1lLCBuZXh0U3RhdGUubG9jYWxlKSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXdyaXRlQXMgPSBwcmVmaXhlZEFzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9oYXNCYXNlUGF0aCkuaGFzQmFzZVBhdGgocmV3cml0ZUFzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZUFzID0gKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgocmV3cml0ZUFzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHJld3JpdGVBcywgX3RoaXMubG9jYWxlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlID0gbG9jYWxlUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IG5leHRTdGF0ZS5sb2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlQXMgPSBsb2NhbGVSZXN1bHQucGF0aG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9ICgwLCBfcm91dGVSZWdleCkuZ2V0Um91dGVSZWdleChwYXRobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1clJvdXRlTWF0Y2ggPSAoMCwgX3JvdXRlTWF0Y2hlcikuZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXgpKG5ldyBVUkwocmV3cml0ZUFzLCBsb2NhdGlvbi5ocmVmKS5wYXRobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJSb3V0ZU1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCBjdXJSb3V0ZU1hdGNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByb3V0ZUluZm8gYnJpbmdzIGEgcmVkaXJlY3Qgd2Ugc2ltcGx5IGFwcGx5IGl0LlxyXG4gICAgICAgICAgICAgICAgaWYgKCd0eXBlJyBpbiByb3V0ZUluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLnR5cGUgPT09ICdyZWRpcmVjdC1pbnRlcm5hbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNoYW5nZShtZXRob2QsIHJvdXRlSW5mby5uZXdVcmwsIHJvdXRlSW5mby5uZXdBcywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiByb3V0ZUluZm8uZGVzdGluYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBlcnJvciAsIHByb3BzICwgX19OX1NTRyAsIF9fTl9TU1AgIH0gPSByb3V0ZUluZm87XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSByb3V0ZUluZm8uQ29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0cyA9IFtdLmNvbmNhdChjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdHMuZm9yRWFjaCgoc2NyaXB0KT0+e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3NjcmlwdCkuaGFuZGxlQ2xpZW50U2NyaXB0TG9hZChzY3JpcHQucHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHJlZGlyZWN0IG9uIGNsaWVudC10cmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoKF9fTl9TU0cgfHwgX19OX1NTUCkgJiYgcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMucGFnZVByb3BzICYmIHByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBkZXN0aW5hdGlvbiBmcm9tIHJlZGlyZWN0IHdpdGhvdXQgYWRkaW5nIGxvY2FsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGRlc3RpbmF0aW9uIGlzIGludGVybmFsIChyZXNvbHZlcyB0byBhIHBhZ2UpIGFuZCBhdHRlbXB0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC1uYXZpZ2F0aW9uIGlmIGl0IGlzIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb24gaWZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoJy8nKSAmJiBwcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUX0JBU0VfUEFUSCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoZGVzdGluYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkSHJlZi5wYXRobmFtZSwgcGFnZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCAsIGFzOiBuZXdBcyAgfSA9IHByZXBhcmVVcmxBcyhfdGhpcywgZGVzdGluYXRpb24sIGRlc3RpbmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jaGFuZ2UobWV0aG9kLCBuZXdVcmwsIG5ld0FzLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGRlc3RpbmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5pc1ByZXZpZXcgPSAhIXByb3BzLl9fTl9QUkVWSUVXO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBTU0cgZGF0YSA0MDRcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMubm90Rm91bmQgPT09IFNTR19EQVRBX05PVF9GT1VORCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLmZldGNoQ29tcG9uZW50KCcvNDA0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gJy80MDQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gJy9fZXJyb3InO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mbyA9IHlpZWxkIF90aGlzLmdldFJvdXRlSW5mbyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZTogbm90Rm91bmRSb3V0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBub3RGb3VuZFJvdXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgndHlwZScgaW4gcm91dGVJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgbWlkZGxld2FyZSBlZmZlY3Qgb24gLzQwNGApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdiZWZvcmVIaXN0b3J5Q2hhbmdlJywgYXMsIHJvdXRlUHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgcGF0aG5hbWUgPT09ICcvX2Vycm9yJyAmJiAoKHJlZjIgPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiAocmVmMyA9IHJlZjIucGFnZVByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmMy5zdGF0dXNDb2RlKSA9PT0gNTAwICYmIChwcm9wcyA9PSBudWxsID8gdm9pZCAwIDogcHJvcHMucGFnZVByb3BzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdXBkYXRpbmcgcXVlcnkgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBfcm91dGU7XHJcbiAgICAgICAgICAgICAgICAvLyBzaGFsbG93IHJvdXRpbmcgaXMgb25seSBhbGxvd2VkIGZvciBzYW1lIHBhZ2UgVVJMIGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbGlkU2hhbGxvd1JvdXRlID0gb3B0aW9ucy5zaGFsbG93ICYmIG5leHRTdGF0ZS5yb3V0ZSA9PT0gKChfcm91dGUgPSByb3V0ZUluZm8ucm91dGUpICE9IG51bGwgPyBfcm91dGUgOiByb3V0ZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9IChfc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwpICE9IG51bGwgPyBfc2Nyb2xsIDogIW9wdGlvbnMuX2ggJiYgIWlzVmFsaWRTaGFsbG93Um91dGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXNldFNjcm9sbCA9IHNob3VsZFNjcm9sbCA/IHtcclxuICAgICAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IDBcclxuICAgICAgICAgICAgICAgIH0gOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIG5ldyBzdGF0ZSB0aGF0IHRoZSByb3V0ZXIgZ29ubmEgc2V0XHJcbiAgICAgICAgICAgICAgICBjb25zdCB1cGNvbWluZ1JvdXRlclN0YXRlID0gX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aDogY2xlYW5lZEFzLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRmFsbGJhY2s6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVwY29taW5nU2Nyb2xsU3RhdGUgPSBmb3JjZWRTY3JvbGwgIT0gbnVsbCA/IGZvcmNlZFNjcm9sbCA6IHJlc2V0U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yIHF1ZXJ5IHVwZGF0ZXMgd2UgY2FuIHNraXAgaXQgaWYgdGhlIHN0YXRlIGlzIHVuY2hhbmdlZCBhbmQgd2UgZG9uJ3RcclxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gc2Nyb2xsXHJcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzM3MTM5XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5Ta2lwVXBkYXRpbmcgPSBvcHRpb25zLl9oICYmICF1cGNvbWluZ1Njcm9sbFN0YXRlICYmICFyZWFkeVN0YXRlQ2hhbmdlICYmICFsb2NhbGVDaGFuZ2UgJiYgKDAsIF9jb21wYXJlU3RhdGVzKS5jb21wYXJlUm91dGVyU3RhdGVzKHVwY29taW5nUm91dGVyU3RhdGUsIF90aGlzLnN0YXRlKTtcclxuICAgICAgICAgICAgICAgIGlmICghY2FuU2tpcFVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgX3RoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSkuY2F0Y2goKGUpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgZXJyb3IgPSBlcnJvciB8fCBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnJvciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTdGF0ZS5sb2NhbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID0gbmV4dFN0YXRlLmxvY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLCBhcywgcm91dGVQcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgaGFzaCBtYXJrICMgaXMgdGhlIG9wdGlvbmFsIGxhc3QgcGFydCBvZiBhIFVSTFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2hSZWdleCA9IC8jLiskLztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsICYmIGhhc2hSZWdleC50ZXN0KGFzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zY3JvbGxUb0hhc2goYXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc0Vycm9yKS5kZWZhdWx0KGVycjEpICYmIGVycjEuY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKCk7XHJcbiAgICB9XHJcbiAgICBjaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnkgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlLmApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LiR7bWV0aG9kfSBpcyBub3QgYXZhaWxhYmxlYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgfHwgKDAsIF91dGlscykuZ2V0VVJMKCkgIT09IGFzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3c7XHJcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0oe1xyXG4gICAgICAgICAgICAgICAgdXJsLFxyXG4gICAgICAgICAgICAgICAgYXMsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgX19OOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLl9rZXkgPSBtZXRob2QgIT09ICdwdXNoU3RhdGUnID8gdGhpcy5fa2V5IDogY3JlYXRlS2V5KClcclxuICAgICAgICAgICAgfSwgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXHJcbiAgICAgICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXHJcbiAgICAgICAgICAgICcnLCBhcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCBsb2FkRXJyb3JGYWlsKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbiooKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxsYXRpb24gZXJyb3JzXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCgwLCBfcm91dGVMb2FkZXIpLmlzQXNzZXRFcnJvcihlcnIpIHx8IGxvYWRFcnJvckZhaWwpIHtcclxuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgYXMsIHJvdXRlUHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgY2FuJ3QgbG9hZCB0aGUgcGFnZSBpdCBjb3VsZCBiZSBvbmUgb2YgZm9sbG93aW5nIHJlYXNvbnNcclxuICAgICAgICAgICAgICAgIC8vICAxLiBQYWdlIGRvZXNuJ3QgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcclxuICAgICAgICAgICAgICAgIC8vICAzLiBJbnRlcm5hbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBwYWdlXHJcbiAgICAgICAgICAgICAgICAvLyBTbywgZG9pbmcgYSBoYXJkIHJlbG9hZCBpcyB0aGUgcHJvcGVyIHdheSB0byBkZWFsIHdpdGggdGhpcy5cclxuICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICB1cmw6IGFzLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXHJcbiAgICAgICAgICAgICAgICAvLyBTbyBsZXQncyB0aHJvdyBhIGNhbmNlbGxhdGlvbiBlcnJvciBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcHJvcHM7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhZ2U6IENvbXBvbmVudCAsIHN0eWxlU2hlZXRzICB9ID0geWllbGQgX3RoaXMuZmV0Y2hDb21wb25lbnQoJy9fZXJyb3InKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlSW5mbyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcyxcclxuICAgICAgICAgICAgICAgICAgICBDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldHMsXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyLFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJvdXRlSW5mby5wcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHlpZWxkIF90aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZ2lwRXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6ICcsIGdpcEVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKHJvdXRlSW5mb0Vycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLCBfaXNFcnJvcikuZGVmYXVsdChyb3V0ZUluZm9FcnIpID8gcm91dGVJbmZvRXJyIDogbmV3IEVycm9yKHJvdXRlSW5mb0VyciArICcnKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0Um91dGVJbmZvKHsgcm91dGU6IHJlcXVlc3RlZFJvdXRlICwgcGF0aG5hbWUgLCBxdWVyeSAsIGFzICwgcmVzb2x2ZWRBcyAsIHJvdXRlUHJvcHMgLCBsb2NhbGUgLCBoYXNNaWRkbGV3YXJlICwgaXNQcmV2aWV3ICwgdW5zdGFibGVfc2tpcENsaWVudENhY2hlICwgaXNRdWVyeVVwZGF0aW5nICwgaXNNaWRkbGV3YXJlUmV3cml0ZSAgfSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKCkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAqIFRoaXMgYHJvdXRlYCBiaW5kaW5nIGNhbiBjaGFuZ2UgaWYgdGhlcmUncyBhIHJld3JpdGVcclxuICAgICAqIHNvIHdlIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIHJlcXVlc3RlZCByb3V0ZVxyXG4gICAgICogc28gd2UgY2FuIHN0b3JlIHRoZSBjYWNoZSBmb3IgaXQgYW5kIGF2b2lkIHJlLXJlcXVlc3RpbmcgZXZlcnkgdGltZVxyXG4gICAgICogZm9yIHNoYWxsb3cgcm91dGluZyBwdXJwb3Nlcy5cclxuICAgICAqLyBsZXQgcm91dGUgPSByZXF1ZXN0ZWRSb3V0ZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciByZWYsIHJlZjQsIHJlZjUsIHJlZjY7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSBnZXRDYW5jZWxsZWRIYW5kbGVyKHtcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZSxcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGxldCBleGlzdGluZ0luZm8gPSBfdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcclxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdJbmZvICYmIF90aGlzLnJvdXRlID09PSByb3V0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0luZm87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzTWlkZGxld2FyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5mbyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBjYWNoZWRSb3V0ZUluZm8gPSBleGlzdGluZ0luZm8gJiYgISgnaW5pdGlhbCcgaW4gZXhpc3RpbmdJbmZvKSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50JyA/IGV4aXN0aW5nSW5mbyA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQmFja2dyb3VuZCA9IGlzUXVlcnlVcGRhdGluZztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoTmV4dERhdGFQYXJhbXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWY6IF90aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlXHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogX3RoaXMuaXNTc3IsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IGlzQmFja2dyb3VuZCA/IF90aGlzLnNiYyA6IF90aGlzLnNkYyxcclxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICFpc1ByZXZpZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzQmFja2dyb3VuZFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBpc1F1ZXJ5VXBkYXRpbmcgJiYgIWlzTWlkZGxld2FyZVJld3JpdGUgPyB7fSA6IHlpZWxkIHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XHJcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hEYXRhOiAoKT0+ZmV0Y2hOZXh0RGF0YShmZXRjaE5leHREYXRhUGFyYW1zKSxcclxuICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBoYXJkIGVycm9yIGR1cmluZyBxdWVyeSB1cGRhdGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIGl0J3MgdW4tbmVjZXNzYXJ5IGFuZCBkb2Vzbid0IG5lZWQgdG8gYmUgZmF0YWxcclxuICAgICAgICAgICAgICAgICAgICAvLyB1bmxlc3MgaXQgaXMgYSBmYWxsYmFjayByb3V0ZSBhbmQgdGhlIHByb3BzIGNhbid0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmUgbG9hZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuanNvbiA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiAocmVmID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiByZWYudHlwZSkgPT09ICdyZWRpcmVjdC1pbnRlcm5hbCcgfHwgKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChyZWY0ID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiByZWY0LnR5cGUpID09PSAncmVkaXJlY3QtZXh0ZXJuYWwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuZWZmZWN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiAocmVmNSA9IGRhdGEuZWZmZWN0KSA9PSBudWxsID8gdm9pZCAwIDogcmVmNS50eXBlKSA9PT0gJ3Jld3JpdGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRSb3V0ZSA9ICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VzID0geWllbGQgX3RoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGR1cmluZyBxdWVyeSB1cGRhdGluZyB0aGUgcGFnZSBtdXN0IG1hdGNoIGFsdGhvdWdoIGR1cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC10cmFuc2l0aW9uIGEgcmVkaXJlY3QgdGhhdCBkb2Vzbid0IG1hdGNoIGEgcGFnZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbiBiZSByZXR1cm5lZCBhbmQgdGhpcyBzaG91bGQgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIGlzIHZhbGlkIGZvciBpbmNyZW1lbnRhbCBtaWdyYXRpb25cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyB8fCBwYWdlcy5pbmNsdWRlcyhyZXNvbHZlZFJvdXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZSA9IHJlc29sdmVkUm91dGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IF9leHRlbmRzKHt9LCBxdWVyeSwgZGF0YS5lZmZlY3QucGFyc2VkQXMucXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgoKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lLCBfdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGFnYWluIHRoZSBjYWNoZSB3aXRoIHRoZSBuZXcgZGVzdGluYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5mbyA9IF90aGlzLmNvbXBvbmVudHNbcm91dGVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nSW5mbyAmJiBfdGhpcy5yb3V0ZSA9PT0gcm91dGUgJiYgIWhhc01pZGRsZXdhcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBtYXRjaCB3aXRoIHRoZSBjdXJyZW50IHJvdXRlIGR1ZSB0byByZXdyaXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIGNvcHkgdGhlIGV4aXN0aW5nIGluZm9ybWF0aW9uIHRvIHRoZSByZXdyaXR0ZW4gb25lLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiwgd2UgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbiBhbG9uZyB3aXRoIHRoZSBtYXRjaGVkIHJvdXRlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBleGlzdGluZ0luZm8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocm91dGUgPT09ICcvYXBpJyB8fCByb3V0ZS5zdGFydHNXaXRoKCcvYXBpLycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGFzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSBjYWNoZWRSb3V0ZUluZm8gfHwgKHlpZWxkIF90aGlzLmZldGNoQ29tcG9uZW50KHJvdXRlKS50aGVuKChyZXMpPT4oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0czogcmVzLnN0eWxlU2hlZXRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfX05fU1NHOiByZXMubW9kLl9fTl9TU0csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fTl9TU1A6IHJlcy5tb2QuX19OX1NTUFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUocm91dGVJbmZvLkNvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJHtwYXRobmFtZX1cImApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHdhc0JhaWxlZFByZWZldGNoID0gZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKHJlZjYgPSBkYXRhLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogcmVmNi5oZWFkZXJzLmdldCgneC1taWRkbGV3YXJlLXNraXAnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZEZldGNoRGF0YSA9IHJvdXRlSW5mby5fX05fU1NHIHx8IHJvdXRlSW5mby5fX05fU1NQO1xyXG4gICAgICAgICAgICAgICAgLy8gRm9yIG5vbi1TU0cgcHJlZmV0Y2hlcyB0aGF0IGJhaWxlZCBiZWZvcmUgc2VuZGluZyBkYXRhXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjbGVhciB0aGUgY2FjaGUgdG8gZmV0Y2ggZnVsbCByZXNwb25zZVxyXG4gICAgICAgICAgICAgICAgaWYgKHdhc0JhaWxlZFByZWZldGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnNkY1tkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmRhdGFIcmVmXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMgLCBjYWNoZUtleSAgfSA9IHlpZWxkIF90aGlzLl9nZXREYXRhKF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRGZXRjaERhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBqc29uICwgY2FjaGVLZXk6IF9jYWNoZUtleSAgfSA9IChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmpzb24pICYmICF3YXNCYWlsZWRQcmVmZXRjaCA/IGRhdGEgOiB5aWVsZCBmZXRjaE5leHREYXRhKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmOiAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5qc29uKSA/IGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYgOiBfdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiBfdGhpcy5pc1NzcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHdhc0JhaWxlZFByZWZldGNoID8ge30gOiBfdGhpcy5zZGMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICFpc1ByZXZpZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBfY2FjaGVLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczoganNvbiB8fCB7fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogeWllbGQgX3RoaXMuZ2V0SW5pdGlhbFByb3BzKHJvdXRlSW5mby5Db21wb25lbnQsIC8vIHdlIHByb3ZpZGUgQXBwVHJlZSBsYXRlciBzbyB0aGlzIG5lZWRzIHRvIGJlIGBhbnlgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IGFzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlczogX3RoaXMubG9jYWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IF90aGlzLmRlZmF1bHRMb2NhbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgLy8gT25seSBidXN0IHRoZSBkYXRhIGNhY2hlIGZvciBTU1Agcm91dGVzIGFsdGhvdWdoXHJcbiAgICAgICAgICAgICAgICAvLyBtaWRkbGV3YXJlIGNhbiBza2lwIGNhY2hlIHBlciByZXF1ZXN0IHdpdGhcclxuICAgICAgICAgICAgICAgIC8vIHgtbWlkZGxld2FyZS1jYWNoZTogbm8tY2FjaGUgYXMgd2VsbFxyXG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5fX05fU1NQICYmIGZldGNoTmV4dERhdGFQYXJhbXMuZGF0YUhyZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuc2RjW2NhY2hlS2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHdlIGtpY2sgb2ZmIGEgSEVBRCByZXF1ZXN0IGluIHRoZSBiYWNrZ3JvdW5kXHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGEgbm9uLXByZWZldGNoIHJlcXVlc3QgaXMgbWFkZSB0byBzaWduYWwgcmV2YWxpZGF0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmlzUHJldmlldyAmJiByb3V0ZUluZm8uX19OX1NTRyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50JyAmJiAhaXNRdWVyeVVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hOZXh0RGF0YShPYmplY3QuYXNzaWduKHt9LCBmZXRjaE5leHREYXRhUGFyYW1zLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQmFja2dyb3VuZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogX3RoaXMuc2JjXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpLmNhdGNoKCgpPT57fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcm9wcy5wYWdlUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5wYWdlUHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gcHJvcHM7XHJcbiAgICAgICAgICAgICAgICByb3V0ZUluZm8ucm91dGUgPSByb3V0ZTtcclxuICAgICAgICAgICAgICAgIHJvdXRlSW5mby5xdWVyeSA9IHF1ZXJ5O1xyXG4gICAgICAgICAgICAgICAgcm91dGVJbmZvLnJlc29sdmVkQXMgPSByZXNvbHZlZEFzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSByb3V0ZUluZm87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcigoMCwgX2lzRXJyb3IpLmdldFByb3BlckVycm9yKGVyciksIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkoKTtcclxuICAgIH1cclxuICAgIHNldChzdGF0ZSwgZGF0YSwgcmVzZXRTY3JvbGwpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKGRhdGEsIHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnQsIHJlc2V0U2Nyb2xsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcclxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcclxuICAgKi8gYmVmb3JlUG9wU3RhdGUoY2IpIHtcclxuICAgICAgICB0aGlzLl9icHMgPSBjYjtcclxuICAgIH1cclxuICAgIG9ubHlBSGFzaENoYW5nZShhcykge1xyXG4gICAgICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KCcjJyk7XHJcbiAgICAgICAgY29uc3QgW25ld1VybE5vSGFzaCwgbmV3SGFzaF0gPSBhcy5zcGxpdCgnIycpO1xyXG4gICAgICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcclxuICAgICAgICBpZiAobmV3SGFzaCAmJiBvbGRVcmxOb0hhc2ggPT09IG5ld1VybE5vSGFzaCAmJiBvbGRIYXNoID09PSBuZXdIYXNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGUgdXJscyBhcmUgY2hhbmdlLCB0aGVyZSdzIG1vcmUgdGhhbiBhIGhhc2ggY2hhbmdlXHJcbiAgICAgICAgaWYgKG9sZFVybE5vSGFzaCAhPT0gbmV3VXJsTm9IYXNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZW4gaXQncyBhIGhhc2ggb25seSBjaGFuZ2UuXHJcbiAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxyXG4gICAgICAgIC8vIGxlYXZlIGhhc2ggPT09ICcnIGNhc2VzLiBUaGUgaWRlbnRpdHkgY2FzZSBmYWxscyB0aHJvdWdoXHJcbiAgICAgICAgLy8gYW5kIGlzIHRyZWF0ZWQgYXMgYSBuZXh0IHJlbG9hZC5cclxuICAgICAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaDtcclxuICAgIH1cclxuICAgIHNjcm9sbFRvSGFzaChhcykge1xyXG4gICAgICAgIGNvbnN0IFssIGhhc2ggPSAnJ10gPSBhcy5zcGxpdCgnIycpO1xyXG4gICAgICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZSBvciBgI3RvcGBcclxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcclxuICAgICAgICBpZiAoaGFzaCA9PT0gJycgfHwgaGFzaCA9PT0gJ3RvcCcpIHtcclxuICAgICAgICAgICAgaGFuZGxlU21vb3RoU2Nyb2xsKCgpPT53aW5kb3cuc2Nyb2xsVG8oMCwgMCkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERlY29kZSBoYXNoIHRvIG1ha2Ugbm9uLWxhdGluIGFuY2hvciB3b3Jrcy5cclxuICAgICAgICBjb25zdCByYXdIYXNoID0gZGVjb2RlVVJJQ29tcG9uZW50KGhhc2gpO1xyXG4gICAgICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXHJcbiAgICAgICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJhd0hhc2gpO1xyXG4gICAgICAgIGlmIChpZEVsKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZVNtb290aFNjcm9sbCgoKT0+aWRFbC5zY3JvbGxJbnRvVmlldygpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGVsZW1lbnQgd2l0aCB0aGUgaWQsIHdlIGNoZWNrIHRoZSBgbmFtZWAgcHJvcGVydHlcclxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcclxuICAgICAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShyYXdIYXNoKVswXTtcclxuICAgICAgICBpZiAobmFtZUVsKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZVNtb290aFNjcm9sbCgoKT0+bmFtZUVsLnNjcm9sbEludG9WaWV3KCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVybElzTmV3KGFzUGF0aCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFzUGF0aCAhPT0gYXNQYXRoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogUHJlZmV0Y2ggcGFnZSBjb2RlLCB5b3UgbWF5IHdhaXQgZm9yIHRoZSBkYXRhIGR1cmluZyBwYWdlIHJlbmRlcmluZy5cclxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxyXG4gICAqIEBwYXJhbSB1cmwgdGhlIGhyZWYgb2YgcHJlZmV0Y2hlZCBwYWdlXHJcbiAgICogQHBhcmFtIGFzUGF0aCB0aGUgYXMgcGF0aCBvZiB0aGUgcHJlZmV0Y2hlZCBwYWdlXHJcbiAgICovIHByZWZldGNoKHVybCwgYXNQYXRoID0gdXJsLCBvcHRpb25zID0ge30pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKigpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICgwLCBfaXNCb3QpLmlzQm90KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gcHJlZmV0Y2hlcyBmb3IgYm90cyB0aGF0IHJlbmRlciB0aGUgbGluayBzaW5jZSB0aGV5IGFyZSB0eXBpY2FsbHkgbmF2aWdhdGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gbGlua3MgdmlhIHRoZSBlcXVpdmFsZW50IG9mIGEgaGFyZCBuYXZpZ2F0aW9uIGFuZCBoZW5jZSBuZXZlciB1dGlsaXplIHRoZXNlXHJcbiAgICAgICAgICAgICAgICAvLyBwcmVmZXRjaGVzLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBwYXJzZWQgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwodXJsKTtcclxuICAgICAgICAgICAgbGV0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHBhcnNlZDtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IHBhdGhuYW1lO1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHBhdGhuYW1lLCBfdGhpcy5sb2NhbGVzKS5wYXRobmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyc2VkQXMgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoYXNQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHBhcnNlZEFzLnBhdGhuYW1lLCBfdGhpcy5sb2NhbGVzKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IF90aGlzLmRlZmF1bHRMb2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoID0gKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwYWdlcyA9IHlpZWxkIF90aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKTtcclxuICAgICAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhc1BhdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZSA9IHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmxvY2FsZSB8fCB1bmRlZmluZWQgOiBfdGhpcy5sb2NhbGU7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZU1hdGNoID0geWllbGQgbWF0Y2hlc01pZGRsZXdhcmUoe1xyXG4gICAgICAgICAgICAgICAgYXNQYXRoOiBhc1BhdGgsXHJcbiAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcclxuICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzUGF0aC5zdGFydHNXaXRoKCcvJykpIHtcclxuICAgICAgICAgICAgICAgIGxldCByZXdyaXRlcztcclxuICAgICAgICAgICAgICAgICh7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9ID0geWllbGQgKDAsIF9yb3V0ZUxvYWRlcikuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gKDAsIF9yZXNvbHZlUmV3cml0ZXMpLmRlZmF1bHQoKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZShhc1BhdGgsIF90aGlzLmxvY2FsZSksIHRydWUpLCBwYWdlcywgcmV3cml0ZXMsIHBhcnNlZC5xdWVyeSwgKHApPT5yZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKSwgX3RoaXMubG9jYWxlcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQuZXh0ZXJuYWxEZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMgPSAoMCwgX3JlbW92ZUxvY2FsZSkucmVtb3ZlTG9jYWxlKCgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKHJld3JpdGVzUmVzdWx0LmFzUGF0aCksIF90aGlzLmxvY2FsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXJzZWQucGF0aG5hbWUsIHBhZ2VzKTtcclxuICAgICAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShwYXJzZWQucGF0aG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcclxuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgKDAsIF9yb3V0ZU1hdGNoZXIpLmdldFJvdXRlTWF0Y2hlcigoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocGFyc2VkLnBhdGhuYW1lKSkoKDAsIF9wYXJzZVBhdGgpLnBhcnNlUGF0aChhc1BhdGgpLnBhdGhuYW1lKSB8fCB7fSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUHJlZmV0Y2ggaXMgbm90IHN1cHBvcnRlZCBpbiBkZXZlbG9wbWVudCBtb2RlIGJlY2F1c2UgaXQgd291bGQgdHJpZ2dlciBvbi1kZW1hbmQtZW50cmllc1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBwcm9jZXNzLmVudi5fX05FWFRfTUlERExFV0FSRV9QUkVGRVRDSCA9PT0gJ3N0cmljdCcgPyB7fSA6IHlpZWxkIHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XHJcbiAgICAgICAgICAgICAgICBmZXRjaERhdGE6ICgpPT5mZXRjaE5leHREYXRhKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWY6IF90aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogb3JpZ2luYWxQYXRobmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwSW50ZXJwb2xhdGlvbjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IF90aGlzLmlzU3NyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IF90aGlzLnNkYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhX3RoaXMuaXNQcmV2aWV3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGFzUGF0aCxcclxuICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxyXG4gICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgKiBJZiB0aGVyZSB3YXMgYSByZXdyaXRlIHdlIGFwcGx5IHRoZSBlZmZlY3RzIG9mIHRoZSByZXdyaXRlIG9uIHRoZVxyXG4gICAgICogY3VycmVudCBwYXJhbWV0ZXJzIGZvciB0aGUgcHJlZmV0Y2guXHJcbiAgICAgKi8gaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmVmZmVjdC50eXBlKSA9PT0gJ3Jld3JpdGUnKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XHJcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZjtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gX2V4dGVuZHMoe30sIHF1ZXJ5LCBkYXRhLmVmZmVjdC5wYXJzZWRBcy5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gZGF0YS5lZmZlY3QucGFyc2VkQXMucGF0aG5hbWU7XHJcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAqIElmIHRoZXJlIGlzIGEgcmVkaXJlY3QgdG8gYW4gZXh0ZXJuYWwgZGVzdGluYXRpb24gdGhlbiB3ZSBkb24ndCBoYXZlXHJcbiAgICAgKiB0byBwcmVmZXRjaCBjb250ZW50IGFzIGl0IHdpbGwgYmUgdW51c2VkLlxyXG4gICAgICovIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5lZmZlY3QudHlwZSkgPT09ICdyZWRpcmVjdC1leHRlcm5hbCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByb3V0ZSA9ICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XHJcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgIF90aGlzLnBhZ2VMb2FkZXIuX2lzU3NnKHJvdXRlKS50aGVuKChpc1NzZyk9PntcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNTc2cgPyBmZXRjaE5leHREYXRhKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWY6IChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmpzb24pID8gZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZiA6IF90aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogdXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiBfdGhpcy5zZGMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIV90aGlzLmlzUHJldmlldyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlOiBvcHRpb25zLnVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSB8fCBvcHRpb25zLnByaW9yaXR5ICYmICEhcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVNUSUNfQ0xJRU5UX0NBQ0hFXHJcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoKT0+ZmFsc2UpIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgIF90aGlzLnBhZ2VMb2FkZXJbb3B0aW9ucy5wcmlvcml0eSA/ICdsb2FkUGFnZScgOiAncHJlZmV0Y2gnXShyb3V0ZSksIFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgfVxyXG4gICAgZmV0Y2hDb21wb25lbnQocm91dGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKigpIHtcclxuICAgICAgICAgICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gZ2V0Q2FuY2VsbGVkSGFuZGxlcih7XHJcbiAgICAgICAgICAgICAgICByb3V0ZSxcclxuICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSB5aWVsZCBfdGhpcy5wYWdlTG9hZGVyLmxvYWRQYWdlKHJvdXRlKTtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlc3VsdDtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKCk7XHJcbiAgICB9XHJcbiAgICBfZ2V0RGF0YShmbikge1xyXG4gICAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKT0+e1xyXG4gICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5jbGMgPSBjYW5jZWw7XHJcbiAgICAgICAgcmV0dXJuIGZuKCkudGhlbigoZGF0YSk9PntcclxuICAgICAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0xvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWQnKTtcclxuICAgICAgICAgICAgICAgIGVyci5jYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2dldEZsaWdodERhdGEoZGF0YUhyZWYpIHtcclxuICAgICAgICAvLyBEbyBub3QgY2FjaGUgUlNDIGZsaWdodCByZXNwb25zZSBzaW5jZSBpdCdzIG5vdCBhIHN0YXRpYyByZXNvdXJjZVxyXG4gICAgICAgIHJldHVybiBmZXRjaE5leHREYXRhKHtcclxuICAgICAgICAgICAgZGF0YUhyZWYsXHJcbiAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0cnVlLFxyXG4gICAgICAgICAgICBwYXJzZUpTT046IGZhbHNlLFxyXG4gICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNkYyxcclxuICAgICAgICAgICAgcGVyc2lzdENhY2hlOiBmYWxzZSxcclxuICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2VcclxuICAgICAgICB9KS50aGVuKCh7IHRleHQgIH0pPT4oe1xyXG4gICAgICAgICAgICAgICAgZGF0YTogdGV4dFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICBnZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCBjdHgpIHtcclxuICAgICAgICBjb25zdCB7IENvbXBvbmVudDogQXBwICB9ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddO1xyXG4gICAgICAgIGNvbnN0IEFwcFRyZWUgPSB0aGlzLl93cmFwQXBwKEFwcCk7XHJcbiAgICAgICAgY3R4LkFwcFRyZWUgPSBBcHBUcmVlO1xyXG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzKS5sb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwge1xyXG4gICAgICAgICAgICBBcHBUcmVlLFxyXG4gICAgICAgICAgICBDb21wb25lbnQsXHJcbiAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcclxuICAgICAgICAgICAgY3R4XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQgcm91dGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucm91dGU7XHJcbiAgICB9XHJcbiAgICBnZXQgcGF0aG5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucGF0aG5hbWU7XHJcbiAgICB9XHJcbiAgICBnZXQgcXVlcnkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucXVlcnk7XHJcbiAgICB9XHJcbiAgICBnZXQgYXNQYXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmFzUGF0aDtcclxuICAgIH1cclxuICAgIGdldCBsb2NhbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubG9jYWxlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRmFsbGJhY2soKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNGYWxsYmFjaztcclxuICAgIH1cclxuICAgIGdldCBpc1ByZXZpZXcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNQcmV2aWV3O1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IocGF0aG5hbWUxLCBxdWVyeTEsIGFzMSwgeyBpbml0aWFsUHJvcHMgLCBwYWdlTG9hZGVyICwgQXBwICwgd3JhcEFwcCAsIENvbXBvbmVudCAsIGVyciAsIHN1YnNjcmlwdGlvbiAsIGlzRmFsbGJhY2sgLCBsb2NhbGUgLCBsb2NhbGVzICwgZGVmYXVsdExvY2FsZSAsIGRvbWFpbkxvY2FsZXMgLCBpc1ByZXZpZXcgIH0pe1xyXG4gICAgICAgIC8vIFNlcnZlciBEYXRhIENhY2hlIChmdWxsIGRhdGEgcmVxdWVzdHMpXHJcbiAgICAgICAgdGhpcy5zZGMgPSB7fTtcclxuICAgICAgICAvLyBTZXJ2ZXIgQmFja2dyb3VuZCBDYWNoZSAoSEVBRCByZXF1ZXN0cylcclxuICAgICAgICB0aGlzLnNiYyA9IHt9O1xyXG4gICAgICAgIHRoaXMuaXNGaXJzdFBvcFN0YXRlRXZlbnQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IGNyZWF0ZUtleSgpO1xyXG4gICAgICAgIHRoaXMub25Qb3BTdGF0ZSA9IChlKT0+e1xyXG4gICAgICAgICAgICBjb25zdCB7IGlzRmlyc3RQb3BTdGF0ZUV2ZW50ICB9ID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5pc0ZpcnN0UG9wU3RhdGVFdmVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGUuc3RhdGU7XHJcbiAgICAgICAgICAgIGlmICghc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGdldCBzdGF0ZSBhcyB1bmRlZmluZWQgZm9yIHR3byByZWFzb25zLlxyXG4gICAgICAgICAgICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXHJcbiAgICAgICAgICAgICAgICAvLyAgMi4gV2hlbiB0aGUgVVJMIGNoYW5nZWQgd2l0aCAjXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cclxuICAgICAgICAgICAgICAgIC8vIChhcyBpdCdzIGFscmVhZHkgY2hhbmdlZClcclxuICAgICAgICAgICAgICAgIC8vIEJ1dCB3ZSBjYW4gc2ltcGx5IHJlcGxhY2UgdGhlIHN0YXRlIHdpdGggdGhlIG5ldyBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgLy8gU28sIGRvaW5nIHRoZSBmb2xsb3dpbmcgZm9yICgxKSBkb2VzIG5vIGhhcm0uXHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgncmVwbGFjZVN0YXRlJywgKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgocGF0aG5hbWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5XHJcbiAgICAgICAgICAgICAgICB9KSwgKDAsIF91dGlscykuZ2V0VVJMKCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIF9fTkEgaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgYXBwLXJvdXRlci5cclxuICAgICAgICAgICAgaWYgKHN0YXRlLl9fTkEpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXN0YXRlLl9fTikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNhZmFyaSBmaXJlcyBwb3BzdGF0ZWV2ZW50IHdoZW4gcmVvcGVuaW5nIHRoZSBicm93c2VyLlxyXG4gICAgICAgICAgICBpZiAoaXNGaXJzdFBvcFN0YXRlRXZlbnQgJiYgdGhpcy5sb2NhbGUgPT09IHN0YXRlLm9wdGlvbnMubG9jYWxlICYmIHN0YXRlLmFzID09PSB0aGlzLmFzUGF0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBmb3JjZWRTY3JvbGw7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdXJsICwgYXMgLCBvcHRpb25zICwga2V5ICB9ID0gc3RhdGU7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fa2V5ICE9PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3QgY3VycmVudCBzY3JvbGwgcG9zaXRpb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdfX25leHRfc2Nyb2xsXycgKyB0aGlzLl9rZXksIEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnBhZ2VYT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBvbGQgc2Nyb2xsIHBvc2l0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ19fbmV4dF9zY3JvbGxfJyArIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSBKU09OLnBhcnNlKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgIH0gPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwodXJsKTtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHJlLXJlbmRlciBvbiBpbml0aWFsIGxvYWQsXHJcbiAgICAgICAgICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1NzciAmJiBhcyA9PT0gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgodGhpcy5hc1BhdGgpICYmIHBhdGhuYW1lID09PSAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aCh0aGlzLnBhdGhuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cclxuICAgICAgICAgICAgLy8gVGhleSB3aWxsIHRoZW4gYmUgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRoZSBldmVudC5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XHJcbiAgICAgICAgICAgICAgICBzaGFsbG93OiBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5fc2hhbGxvdyxcclxuICAgICAgICAgICAgICAgIGxvY2FsZTogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlLFxyXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbCB2YWx1ZSBub3QgZXhwb3NlZCBvbiB0eXBlc1xyXG4gICAgICAgICAgICAgICAgX2g6IDBcclxuICAgICAgICAgICAgfSksIGZvcmNlZFNjcm9sbCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGNvbXBvbmVudCBrZXlcclxuICAgICAgICBjb25zdCByb3V0ZSA9ICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZTEpO1xyXG4gICAgICAgIC8vIHNldCB1cCB0aGUgY29tcG9uZW50IGNhY2hlIChieSByb3V0ZSBrZXlzKVxyXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IHt9O1xyXG4gICAgICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcclxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoaXMgY2F1c2UgaXNzdWVzIHdoZW4gd2hlbiBnb2luZyBiYWNrIGFuZFxyXG4gICAgICAgIC8vIGNvbWUgYWdhaW4gdG8gdGhlIGVycm9yZWQgcGFnZS5cclxuICAgICAgICBpZiAocGF0aG5hbWUxICE9PSAnL19lcnJvcicpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHtcclxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIGluaXRpYWw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwcm9wczogaW5pdGlhbFByb3BzLFxyXG4gICAgICAgICAgICAgICAgZXJyLFxyXG4gICAgICAgICAgICAgICAgX19OX1NTRzogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NHLFxyXG4gICAgICAgICAgICAgICAgX19OX1NTUDogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NQXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcG9uZW50c1snL19hcHAnXSA9IHtcclxuICAgICAgICAgICAgQ29tcG9uZW50OiBBcHAsXHJcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3IgUm91dGVyLnJvdXRlci5ldmVudHNcclxuICAgICAgICAvLyBUT0RPOiBTaG91bGQgYmUgcmVtb3ZlIHRoZSBmb2xsb3dpbmcgbWFqb3IgdmVyc2lvbiBhcyBpdCB3YXMgbmV2ZXIgZG9jdW1lbnRlZFxyXG4gICAgICAgIHRoaXMuZXZlbnRzID0gUm91dGVyLmV2ZW50cztcclxuICAgICAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyO1xyXG4gICAgICAgIC8vIGlmIGF1dG8gcHJlcmVuZGVyZWQgYW5kIGR5bmFtaWMgcm91dGUgd2FpdCB0byB1cGRhdGUgYXNQYXRoXHJcbiAgICAgICAgLy8gdW50aWwgYWZ0ZXIgbW91bnQgdG8gcHJldmVudCBoeWRyYXRpb24gbWlzbWF0Y2hcclxuICAgICAgICBjb25zdCBhdXRvRXhwb3J0RHluYW1pYyA9ICgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShwYXRobmFtZTEpICYmIHNlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0O1xyXG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnO1xyXG4gICAgICAgIHRoaXMuc3ViID0gc3Vic2NyaXB0aW9uO1xyXG4gICAgICAgIHRoaXMuY2xjID0gbnVsbDtcclxuICAgICAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcDtcclxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaWdub3JlIGV4dHJhIHBvcFN0YXRlIGluIHNhZmFyaSBvbiBuYXZpZ2F0aW5nXHJcbiAgICAgICAgLy8gYmFjayBmcm9tIGV4dGVybmFsIHNpdGVcclxuICAgICAgICB0aGlzLmlzU3NyID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gISEoc2VsZi5fX05FWFRfREFUQV9fLmdzc3AgfHwgc2VsZi5fX05FWFRfREFUQV9fLmdpcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uYXBwR2lwICYmICFzZWxmLl9fTkVYVF9EQVRBX18uZ3NwIHx8ICFhdXRvRXhwb3J0RHluYW1pYyAmJiAhc2VsZi5sb2NhdGlvbi5zZWFyY2ggJiYgIXByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpO1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYWxlcyA9IGxvY2FsZXM7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXM7XHJcbiAgICAgICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSAhISgwLCBfZGV0ZWN0RG9tYWluTG9jYWxlKS5kZXRlY3REb21haW5Mb2NhbGUoZG9tYWluTG9jYWxlcywgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIHJvdXRlLFxyXG4gICAgICAgICAgICBwYXRobmFtZTogcGF0aG5hbWUxLFxyXG4gICAgICAgICAgICBxdWVyeTogcXVlcnkxLFxyXG4gICAgICAgICAgICBhc1BhdGg6IGF1dG9FeHBvcnREeW5hbWljID8gcGF0aG5hbWUxIDogYXMxLFxyXG4gICAgICAgICAgICBpc1ByZXZpZXc6ICEhaXNQcmV2aWV3LFxyXG4gICAgICAgICAgICBsb2NhbGU6IHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQgPyBsb2NhbGUgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGlzRmFsbGJhY2tcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgXCJhc1wiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBkb3VibGUgc2xhc2hlcyBvciBlbHNlIGl0IGNhblxyXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBlcnJvciBhcyBpdCdzIGNvbnNpZGVyZWQgaW52YWxpZFxyXG4gICAgICAgICAgICBpZiAoIWFzMS5zdGFydHNXaXRoKCcvLycpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxyXG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byByZWdpc3RlciB0aGUgaW5pdGlhbCByb3V0ZSB1cG9uIGluaXRpYWxpemF0aW9uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzUGF0aCA9ICgwLCBfdXRpbHMpLmdldFVSTCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSA9IG1hdGNoZXNNaWRkbGV3YXJlKHtcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aFxyXG4gICAgICAgICAgICAgICAgfSkudGhlbigobWF0Y2hlcyk9PntcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiA9IGFzMSAhPT0gcGF0aG5hbWUxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ3JlcGxhY2VTdGF0ZScsIG1hdGNoZXMgPyBhc1BhdGggOiAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgocGF0aG5hbWUxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5MVxyXG4gICAgICAgICAgICAgICAgICAgIH0pLCBhc1BhdGgsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5vblBvcFN0YXRlKTtcclxuICAgICAgICAgICAgLy8gZW5hYmxlIGN1c3RvbSBzY3JvbGwgcmVzdG9yYXRpb24gaGFuZGxpbmcgd2hlbiBhdmFpbGFibGVcclxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIGJyb3dzZXIncyBkZWZhdWx0IGhhbmRsaW5nXHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9ICdtYW51YWwnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblJvdXRlci5ldmVudHMgPSAoMCwgX21pdHQpLmRlZmF1bHQoKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGVyO1xyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1hdGNoZXNNaWRkbGV3YXJlIiwiaXNMb2NhbFVSTCIsImludGVycG9sYXRlQXMiLCJyZXNvbHZlSHJlZiIsImNyZWF0ZUtleSIsImRlZmF1bHQiLCJfYXN5bmNfdG9fZ2VuZXJhdG9yIiwicmVxdWlyZSIsIl9leHRlbmRzIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9ub3JtYWxpemVUcmFpbGluZ1NsYXNoIiwiX3JlbW92ZVRyYWlsaW5nU2xhc2giLCJfcm91dGVMb2FkZXIiLCJfc2NyaXB0IiwiX2lzRXJyb3IiLCJfZGVub3JtYWxpemVQYWdlUGF0aCIsIl9ub3JtYWxpemVMb2NhbGVQYXRoIiwiX21pdHQiLCJfdXRpbHMiLCJfaXNEeW5hbWljIiwiX3BhcnNlUmVsYXRpdmVVcmwiLCJfcXVlcnlzdHJpbmciLCJfcmVzb2x2ZVJld3JpdGVzIiwiX3JvdXRlTWF0Y2hlciIsIl9yb3V0ZVJlZ2V4IiwiX2Zvcm1hdFVybCIsIl9kZXRlY3REb21haW5Mb2NhbGUiLCJfcGFyc2VQYXRoIiwiX2FkZExvY2FsZSIsIl9yZW1vdmVMb2NhbGUiLCJfcmVtb3ZlQmFzZVBhdGgiLCJfYWRkQmFzZVBhdGgiLCJfaGFzQmFzZVBhdGgiLCJfZ2V0TmV4dFBhdGhuYW1lSW5mbyIsIl9mb3JtYXROZXh0UGF0aG5hbWVJbmZvIiwiX2NvbXBhcmVTdGF0ZXMiLCJfaXNCb3QiLCJidWlsZENhbmNlbGxhdGlvbkVycm9yIiwiYXNzaWduIiwiRXJyb3IiLCJjYW5jZWxsZWQiLCJvcHRpb25zIiwiX21hdGNoZXNNaWRkbGV3YXJlIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJtYXRjaGVycyIsIlByb21pc2UiLCJyZXNvbHZlIiwicm91dGVyIiwicGFnZUxvYWRlciIsImdldE1pZGRsZXdhcmUiLCJwYXRobmFtZSIsImFzUGF0aG5hbWUiLCJwYXJzZVBhdGgiLCJhc1BhdGgiLCJjbGVhbmVkQXMiLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUiLCJhZGRCYXNlUGF0aCIsImFkZExvY2FsZSIsImxvY2FsZSIsInNvbWUiLCJtIiwiUmVnRXhwIiwicmVnZXhwIiwidGVzdCIsInN0cmlwT3JpZ2luIiwidXJsIiwib3JpZ2luIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwib21pdCIsIm9iamVjdCIsImtleXMiLCJvbWl0dGVkIiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwiaXNBYnNvbHV0ZVVybCIsImxvY2F0aW9uT3JpZ2luIiwicmVzb2x2ZWQiLCJVUkwiLCJfIiwicm91dGUiLCJxdWVyeSIsImludGVycG9sYXRlZFJvdXRlIiwiZHluYW1pY1JlZ2V4IiwiZ2V0Um91dGVSZWdleCIsImR5bmFtaWNHcm91cHMiLCJncm91cHMiLCJkeW5hbWljTWF0Y2hlcyIsImdldFJvdXRlTWF0Y2hlciIsInBhcmFtcyIsImV2ZXJ5IiwicGFyYW0iLCJyZXBlYXQiLCJvcHRpb25hbCIsInJlcGxhY2VkIiwiQXJyYXkiLCJpc0FycmF5IiwicmVwbGFjZSIsIm1hcCIsInNlZ21lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJqb2luIiwicmVzdWx0IiwiaHJlZiIsInJlc29sdmVBcyIsImJhc2UiLCJ1cmxBc1N0cmluZyIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwidXJsUHJvdG9NYXRjaCIsIm1hdGNoIiwidXJsQXNTdHJpbmdOb1Byb3RvIiwic2xpY2UiLCJ1cmxQYXJ0cyIsInNwbGl0IiwiY29uc29sZSIsImVycm9yIiwibm9ybWFsaXplZFVybCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImZpbmFsVXJsIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJpbnRlcnBvbGF0ZWRBcyIsImlzRHluYW1pY1JvdXRlIiwic2VhcmNoUGFyYW1zIiwic2VhcmNoUGFyYW1zVG9VcmxRdWVyeSIsImhhc2giLCJyZXNvbHZlZEhyZWYiLCJfMSIsInByZXBhcmVVcmxBcyIsImFzIiwicmVzb2x2ZWRBcyIsImhyZWZIYWRPcmlnaW4iLCJhc0hhZE9yaWdpbiIsInByZXBhcmVkVXJsIiwicHJlcGFyZWRBcyIsInJlc29sdmVEeW5hbWljUm91dGUiLCJwYWdlcyIsImNsZWFuUGF0aG5hbWUiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwiZGVub3JtYWxpemVQYWdlUGF0aCIsInBhZ2UiLCJyZSIsImdldE1pZGRsZXdhcmVEYXRhIiwic291cmNlIiwicmVzcG9uc2UiLCJuZXh0Q29uZmlnIiwiYmFzZVBhdGgiLCJpMThuIiwibG9jYWxlcyIsInRyYWlsaW5nU2xhc2giLCJCb29sZWFuIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9UUkFJTElOR19TTEFTSCIsInJld3JpdGVIZWFkZXIiLCJoZWFkZXJzIiwiZ2V0IiwicmV3cml0ZVRhcmdldCIsIm1hdGNoZWRQYXRoIiwicGFyc2VkUmV3cml0ZVRhcmdldCIsInBhcnNlUmVsYXRpdmVVcmwiLCJwYXRobmFtZUluZm8iLCJnZXROZXh0UGF0aG5hbWVJbmZvIiwicGFyc2VEYXRhIiwiZnNQYXRobmFtZSIsImFsbCIsImdldFBhZ2VMaXN0IiwiZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCIsInRoZW4iLCJfX3Jld3JpdGVzIiwicmV3cml0ZXMiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwicGFyc2VkU291cmNlIiwiX19ORVhUX0hBU19SRVdSSVRFUyIsInBhdGgiLCJtYXRjaGVkUGFnZSIsInBhcnNlZEFzIiwicmVzb2x2ZWRQYXRobmFtZSIsIm1hdGNoZXMiLCJ0eXBlIiwic3JjIiwiZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyIsImRlZmF1bHRMb2NhbGUiLCJidWlsZElkIiwiZGVzdGluYXRpb24iLCJyZWRpcmVjdFRhcmdldCIsIm5ld0FzIiwibmV3VXJsIiwid2l0aE1pZGRsZXdhcmVFZmZlY3RzIiwiZmV0Y2hEYXRhIiwiZGF0YSIsImRhdGFIcmVmIiwiZWZmZWN0IiwiY2FjaGVLZXkiLCJqc29uIiwidGV4dCIsImNhdGNoIiwiX2VyciIsIm1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uIiwiX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiIsIndpbmRvdyIsImhpc3RvcnkiLCJ2Iiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsIm4iLCJTU0dfREFUQV9OT1RfRk9VTkQiLCJTeW1ib2wiLCJmZXRjaFJldHJ5IiwiYXR0ZW1wdHMiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwibWV0aG9kIiwib2siLCJzdGF0dXMiLCJoYW5kbGVTbW9vdGhTY3JvbGwiLCJmbiIsImh0bWxFbGVtZW50IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJleGlzdGluZyIsInN0eWxlIiwic2Nyb2xsQmVoYXZpb3IiLCJ0cnlUb1BhcnNlQXNKU09OIiwiSlNPTiIsInBhcnNlIiwiZmV0Y2hOZXh0RGF0YSIsImluZmxpZ2h0Q2FjaGUiLCJpc1ByZWZldGNoIiwiaGFzTWlkZGxld2FyZSIsImlzU2VydmVyUmVuZGVyIiwicGFyc2VKU09OIiwicGVyc2lzdENhY2hlIiwiaXNCYWNrZ3JvdW5kIiwidW5zdGFibGVfc2tpcENsaWVudENhY2hlIiwibG9jYXRpb24iLCJyZWYxIiwiZ2V0RGF0YSIsInB1cnBvc2UiLCJyZWYiLCJub3RGb3VuZCIsIm1hcmtBc3NldEVycm9yIiwiZXJyIiwibWVzc2FnZSIsInVuZGVmaW5lZCIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsImhhbmRsZUhhcmROYXZpZ2F0aW9uIiwiZ2V0Q2FuY2VsbGVkSGFuZGxlciIsImNhbmNlbCIsImNsYyIsImhhbmRsZUNhbmNlbGxlZCIsIlJvdXRlciIsInJlbG9hZCIsImJhY2siLCJmb3J3YXJkIiwicHVzaCIsIl9rZXkiLCJzdHJpbmdpZnkiLCJ4Iiwic2VsZiIsInBhZ2VYT2Zmc2V0IiwieSIsInBhZ2VZT2Zmc2V0IiwiZSIsImNoYW5nZSIsImZvcmNlZFNjcm9sbCIsIl90aGlzIiwiaXNRdWVyeVVwZGF0aW5nIiwiX2giLCJzaG91bGRSZXNvbHZlSHJlZiIsIl9zaG91bGRSZXNvbHZlSHJlZiIsIm5leHRTdGF0ZSIsInN0YXRlIiwicmVhZHlTdGF0ZUNoYW5nZSIsImlzUmVhZHkiLCJpc1NzciIsInByZXZMb2NhbGUiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwibG9jYWxlUGF0aFJlc3VsdCIsImRldGVjdGVkTG9jYWxlIiwiZGlkTmF2aWdhdGUiLCJkZXRlY3RlZERvbWFpbiIsImRldGVjdERvbWFpbkxvY2FsZSIsImRvbWFpbkxvY2FsZXMiLCJpc0xvY2FsZURvbWFpbiIsImhvc3RuYW1lIiwiZG9tYWluIiwiYXNOb0Jhc2VQYXRoIiwiaHR0cCIsIlNUIiwicGVyZm9ybWFuY2UiLCJtYXJrIiwic2hhbGxvdyIsInNjcm9sbCIsInJvdXRlUHJvcHMiLCJfaW5GbGlnaHRSb3V0ZSIsImV2ZW50cyIsImVtaXQiLCJyZW1vdmVMb2NhbGUiLCJsb2NhbGVDaGFuZ2UiLCJvbmx5QUhhc2hDaGFuZ2UiLCJjaGFuZ2VTdGF0ZSIsInNjcm9sbFRvSGFzaCIsInNldCIsImNvbXBvbmVudHMiLCJwYXJzZWQiLCJ1cmxJc05ldyIsInBhcnNlZEFzUGF0aG5hbWUiLCJpc01pZGRsZXdhcmVSZXdyaXRlIiwiaXNNaWRkbGV3YXJlTWF0Y2giLCJyZXdyaXRlc1Jlc3VsdCIsInAiLCJleHRlcm5hbERlc3QiLCJyb3V0ZU1hdGNoIiwicm91dGVSZWdleCIsInNob3VsZEludGVycG9sYXRlIiwibWlzc2luZ1BhcmFtcyIsImZpbHRlciIsIndhcm4iLCJyZWYyIiwicmVmMyIsInJvdXRlSW5mbyIsImdldFJvdXRlSW5mbyIsImlzUHJldmlldyIsImlzRmFsbGJhY2siLCJjbGVhbmVkUGFyc2VkUGF0aG5hbWUiLCJwcmVmaXhlZEFzIiwicmV3cml0ZUFzIiwibG9jYWxlUmVzdWx0IiwiY3VyUm91dGVNYXRjaCIsInByb3BzIiwiX19OX1NTRyIsIl9fTl9TU1AiLCJjb21wb25lbnQiLCJDb21wb25lbnQiLCJ1bnN0YWJsZV9zY3JpcHRMb2FkZXIiLCJzY3JpcHRzIiwiY29uY2F0Iiwic2NyaXB0IiwiaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCIsInBhZ2VQcm9wcyIsIl9fTl9SRURJUkVDVCIsIl9fTl9SRURJUkVDVF9CQVNFX1BBVEgiLCJwYXJzZWRIcmVmIiwiX19OX1BSRVZJRVciLCJub3RGb3VuZFJvdXRlIiwiZmV0Y2hDb21wb25lbnQiLCJfX05FWFRfREFUQV9fIiwic3RhdHVzQ29kZSIsIl9yb3V0ZSIsImlzVmFsaWRTaGFsbG93Um91dGUiLCJfc2Nyb2xsIiwic2hvdWxkU2Nyb2xsIiwicmVzZXRTY3JvbGwiLCJ1cGNvbWluZ1JvdXRlclN0YXRlIiwidXBjb21pbmdTY3JvbGxTdGF0ZSIsImNhblNraXBVcGRhdGluZyIsImNvbXBhcmVSb3V0ZXJTdGF0ZXMiLCJsYW5nIiwiaGFzaFJlZ2V4IiwiZXJyMSIsImdldFVSTCIsIl9zaGFsbG93IiwiX19OIiwiaGFuZGxlUm91dGVJbmZvRXJyb3IiLCJsb2FkRXJyb3JGYWlsIiwiaXNBc3NldEVycm9yIiwic3R5bGVTaGVldHMiLCJnZXRJbml0aWFsUHJvcHMiLCJnaXBFcnIiLCJyb3V0ZUluZm9FcnIiLCJyZXF1ZXN0ZWRSb3V0ZSIsInJlZjQiLCJyZWY1IiwicmVmNiIsImV4aXN0aW5nSW5mbyIsImNhY2hlZFJvdXRlSW5mbyIsImZldGNoTmV4dERhdGFQYXJhbXMiLCJnZXREYXRhSHJlZiIsInNraXBJbnRlcnBvbGF0aW9uIiwic2JjIiwic2RjIiwicmVzb2x2ZWRSb3V0ZSIsInJlcyIsIm1vZCIsImlzVmFsaWRFbGVtZW50VHlwZSIsIndhc0JhaWxlZFByZWZldGNoIiwic2hvdWxkRmV0Y2hEYXRhIiwiX2dldERhdGEiLCJfY2FjaGVLZXkiLCJnZXRQcm9wZXJFcnJvciIsInN1YiIsImJlZm9yZVBvcFN0YXRlIiwiY2IiLCJfYnBzIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsIm5ld1VybE5vSGFzaCIsIm5ld0hhc2giLCJzY3JvbGxUbyIsInJhd0hhc2giLCJkZWNvZGVVUklDb21wb25lbnQiLCJpZEVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJzY3JvbGxJbnRvVmlldyIsIm5hbWVFbCIsImdldEVsZW1lbnRzQnlOYW1lIiwicHJlZmV0Y2giLCJpc0JvdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIm9yaWdpbmFsUGF0aG5hbWUiLCJfX05FWFRfTUlERExFV0FSRV9QUkVGRVRDSCIsIl9pc1NzZyIsImlzU3NnIiwicHJpb3JpdHkiLCJfX05FWFRfT1BUSU1JU1RJQ19DTElFTlRfQ0FDSEUiLCJjb21wb25lbnRSZXN1bHQiLCJsb2FkUGFnZSIsIl9nZXRGbGlnaHREYXRhIiwiY3R4IiwiQXBwIiwiQXBwVHJlZSIsIl93cmFwQXBwIiwibG9hZEdldEluaXRpYWxQcm9wcyIsImNvbnN0cnVjdG9yIiwicGF0aG5hbWUxIiwicXVlcnkxIiwiYXMxIiwiaW5pdGlhbFByb3BzIiwid3JhcEFwcCIsInN1YnNjcmlwdGlvbiIsImlzRmlyc3RQb3BTdGF0ZUV2ZW50Iiwib25Qb3BTdGF0ZSIsIl9fTkEiLCJnZXRJdGVtIiwiZTEiLCJpbml0aWFsIiwiYXV0b0V4cG9ydER5bmFtaWMiLCJhdXRvRXhwb3J0IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsImdzc3AiLCJnaXAiLCJhcHBHaXAiLCJnc3AiLCJzZWFyY2giLCJfaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJzY3JvbGxSZXN0b3JhdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.searchParamsToUrlQuery = searchParamsToUrlQuery;\nexports.urlQueryToSearchParams = urlQueryToSearchParams;\nexports.assign = assign;\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    searchParams.forEach((value, key)=>{\n        if (typeof query[key] === \"undefined\") {\n            query[key] = value;\n        } else if (Array.isArray(query[key])) {\n            query[key].push(value);\n        } else {\n            query[key] = [\n                query[key],\n                value\n            ];\n        }\n    });\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === \"string\" || typeof param === \"number\" && !isNaN(param) || typeof param === \"boolean\") {\n        return String(param);\n    } else {\n        return \"\";\n    }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n    const result = new URLSearchParams();\n    Object.entries(urlQuery).forEach((param)=>{\n        let [key, value] = param;\n        if (Array.isArray(value)) {\n            value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));\n        } else {\n            result.set(key, stringifyUrlQueryParam(value));\n        }\n    });\n    return result;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    searchParamsList.forEach((searchParams)=>{\n        Array.from(searchParams.keys()).forEach((key)=>target.delete(key));\n        searchParams.forEach((value, key)=>target.append(key, value));\n    });\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELDhCQUE4QixHQUFHRTtBQUNqQ0YsOEJBQThCLEdBQUdHO0FBQ2pDSCxjQUFjLEdBQUdJO0FBQ2pCLFNBQVNGLHVCQUF1QkcsWUFBWSxFQUFFO0lBQzFDLE1BQU1DLFFBQVEsQ0FBQztJQUNmRCxhQUFhRSxPQUFPLENBQUMsQ0FBQ04sT0FBT08sTUFBTTtRQUMvQixJQUFJLE9BQU9GLEtBQUssQ0FBQ0UsSUFBSSxLQUFLLGFBQWE7WUFDbkNGLEtBQUssQ0FBQ0UsSUFBSSxHQUFHUDtRQUNqQixPQUFPLElBQUlRLE1BQU1DLE9BQU8sQ0FBQ0osS0FBSyxDQUFDRSxJQUFJLEdBQUc7WUFDbENGLEtBQUssQ0FBQ0UsSUFBSSxDQUFDRyxJQUFJLENBQUNWO1FBQ3BCLE9BQU87WUFDSEssS0FBSyxDQUFDRSxJQUFJLEdBQUc7Z0JBQ1RGLEtBQUssQ0FBQ0UsSUFBSTtnQkFDVlA7YUFDSDtRQUNMLENBQUM7SUFDTDtJQUNBLE9BQU9LO0FBQ1g7QUFDQSxTQUFTTSx1QkFBdUJDLEtBQUssRUFBRTtJQUNuQyxJQUFJLE9BQU9BLFVBQVUsWUFBWSxPQUFPQSxVQUFVLFlBQVksQ0FBQ0MsTUFBTUQsVUFBVSxPQUFPQSxVQUFVLFdBQVc7UUFDdkcsT0FBT0UsT0FBT0Y7SUFDbEIsT0FBTztRQUNILE9BQU87SUFDWCxDQUFDO0FBQ0w7QUFDQSxTQUFTVix1QkFBdUJhLFFBQVEsRUFBRTtJQUN0QyxNQUFNQyxTQUFTLElBQUlDO0lBQ25CcEIsT0FBT3FCLE9BQU8sQ0FBQ0gsVUFBVVQsT0FBTyxDQUFDLFNBQWdCO1lBQWYsQ0FBQ0MsS0FBS1AsTUFBTTtRQUMxQyxJQUFJUSxNQUFNQyxPQUFPLENBQUNULFFBQVE7WUFDdEJBLE1BQU1NLE9BQU8sQ0FBQyxDQUFDYSxPQUFPSCxPQUFPSSxNQUFNLENBQUNiLEtBQUtJLHVCQUF1QlE7UUFDcEUsT0FBTztZQUNISCxPQUFPSyxHQUFHLENBQUNkLEtBQUtJLHVCQUF1Qlg7UUFDM0MsQ0FBQztJQUNMO0lBQ0EsT0FBT2dCO0FBQ1g7QUFDQSxTQUFTYixPQUFPbUIsTUFBTSxFQUF1QjtJQUFyQixxRkFBbUIsR0FBbkI7UUFBR0MsaUJBQUgsMkJBQW1CO0lBQUQ7SUFDdENBLGlCQUFpQmpCLE9BQU8sQ0FBQyxDQUFDRixlQUFlO1FBQ3JDSSxNQUFNZ0IsSUFBSSxDQUFDcEIsYUFBYXFCLElBQUksSUFBSW5CLE9BQU8sQ0FBQyxDQUFDQyxNQUFNZSxPQUFPSSxNQUFNLENBQUNuQjtRQUM3REgsYUFBYUUsT0FBTyxDQUFDLENBQUNOLE9BQU9PLE1BQU1lLE9BQU9GLE1BQU0sQ0FBQ2IsS0FBS1A7SUFDMUQ7SUFDQSxPQUFPc0I7QUFDWCxFQUVBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nLmpzPzAxNDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gICAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuc2VhcmNoUGFyYW1zVG9VcmxRdWVyeSA9IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnk7XHJcbmV4cG9ydHMudXJsUXVlcnlUb1NlYXJjaFBhcmFtcyA9IHVybFF1ZXJ5VG9TZWFyY2hQYXJhbXM7XHJcbmV4cG9ydHMuYXNzaWduID0gYXNzaWduO1xyXG5mdW5jdGlvbiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KHNlYXJjaFBhcmFtcykge1xyXG4gICAgY29uc3QgcXVlcnkgPSB7fTtcclxuICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KT0+e1xyXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcnlba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcXVlcnlba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xyXG4gICAgICAgICAgICBxdWVyeVtrZXldLnB1c2godmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5W2tleV0gPSBbXHJcbiAgICAgICAgICAgICAgICBxdWVyeVtrZXldLFxyXG4gICAgICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBxdWVyeTtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHBhcmFtKSB7XHJcbiAgICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInICYmICFpc05hTihwYXJhbSkgfHwgdHlwZW9mIHBhcmFtID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKHBhcmFtKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHVybFF1ZXJ5VG9TZWFyY2hQYXJhbXModXJsUXVlcnkpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcclxuICAgIE9iamVjdC5lbnRyaWVzKHVybFF1ZXJ5KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pPT57XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0pPT5yZXN1bHQuYXBwZW5kKGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbShpdGVtKSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIC4uLnNlYXJjaFBhcmFtc0xpc3QpIHtcclxuICAgIHNlYXJjaFBhcmFtc0xpc3QuZm9yRWFjaCgoc2VhcmNoUGFyYW1zKT0+e1xyXG4gICAgICAgIEFycmF5LmZyb20oc2VhcmNoUGFyYW1zLmtleXMoKSkuZm9yRWFjaCgoa2V5KT0+dGFyZ2V0LmRlbGV0ZShrZXkpKTtcclxuICAgICAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSk9PnRhcmdldC5hcHBlbmQoa2V5LCB2YWx1ZSkpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcblxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeXN0cmluZy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsImFzc2lnbiIsInNlYXJjaFBhcmFtcyIsInF1ZXJ5IiwiZm9yRWFjaCIsImtleSIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJzdHJpbmdpZnlVcmxRdWVyeVBhcmFtIiwicGFyYW0iLCJpc05hTiIsIlN0cmluZyIsInVybFF1ZXJ5IiwicmVzdWx0IiwiVVJMU2VhcmNoUGFyYW1zIiwiZW50cmllcyIsIml0ZW0iLCJhcHBlbmQiLCJzZXQiLCJ0YXJnZXQiLCJzZWFyY2hQYXJhbXNMaXN0IiwiZnJvbSIsImtleXMiLCJkZWxldGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.execOnce = execOnce;\nexports.getLocationOrigin = getLocationOrigin;\nexports.getURL = getURL;\nexports.getDisplayName = getDisplayName;\nexports.isResSent = isResSent;\nexports.normalizeRepeatedSlashes = normalizeRepeatedSlashes;\nexports.loadGetInitialProps = loadGetInitialProps;\nexports.ST = exports.SP = exports.isAbsoluteUrl = exports.WEB_VITALS = void 0;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nconst WEB_VITALS = [\n    \"CLS\",\n    \"FCP\",\n    \"FID\",\n    \"INP\",\n    \"LCP\",\n    \"TTFB\"\n];\nexports.WEB_VITALS = WEB_VITALS;\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nexports.isAbsoluteUrl = isAbsoluteUrl;\nfunction getLocationOrigin() {\n    const { protocol , hostname , port  } = window.location;\n    return \"\".concat(protocol, \"//\").concat(hostname).concat(port ? \":\" + port : \"\");\n}\nfunction getURL() {\n    const { href  } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === \"string\" ? Component : Component.displayName || Component.name || \"Unknown\";\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split(\"?\");\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, \"/\").replace(/\\/\\/+/g, \"/\") + (urlParts[1] ? \"?\".concat(urlParts.slice(1).join(\"?\")) : \"\");\n}\nfunction loadGetInitialProps(App, ctx) {\n    return _loadGetInitialProps.apply(this, arguments);\n}\nfunction _loadGetInitialProps() {\n    _loadGetInitialProps = _async_to_generator(function*(App, ctx) {\n        if (true) {\n            var ref;\n            if ((ref = App.prototype) == null ? void 0 : ref.getInitialProps) {\n                const message = '\"'.concat(getDisplayName(App), '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.');\n                throw new Error(message);\n            }\n        }\n        // when called from _app `ctx` is nested in `ctx`\n        const res = ctx.res || ctx.ctx && ctx.ctx.res;\n        if (!App.getInitialProps) {\n            if (ctx.ctx && ctx.Component) {\n                // @ts-ignore pageProps default\n                return {\n                    pageProps: yield loadGetInitialProps(ctx.Component, ctx.ctx)\n                };\n            }\n            return {};\n        }\n        const props = yield App.getInitialProps(ctx);\n        if (res && isResSent(res)) {\n            return props;\n        }\n        if (!props) {\n            const message1 = '\"'.concat(getDisplayName(App), '.getInitialProps()\" should resolve to an object. But found \"').concat(props, '\" instead.');\n            throw new Error(message1);\n        }\n        if (true) {\n            if (Object.keys(props).length === 0 && !ctx.ctx) {\n                console.warn(\"\".concat(getDisplayName(App), \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\"));\n            }\n        }\n        return props;\n    });\n    return _loadGetInitialProps.apply(this, arguments);\n}\nconst SP = typeof performance !== \"undefined\";\nexports.SP = SP;\nconst ST = SP && [\n    \"mark\",\n    \"measure\",\n    \"getEntriesByName\"\n].every((method)=>typeof performance[method] === \"function\");\nexports.ST = ST;\nclass DecodeError extends Error {\n}\nexports.DecodeError = DecodeError;\nclass NormalizeError extends Error {\n}\nexports.NormalizeError = NormalizeError;\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = \"ENOENT\";\n        this.message = \"Cannot find module for page: \".concat(page);\n    }\n}\nexports.PageNotFoundError = PageNotFoundError;\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = \"Failed to load static file for page: \".concat(page, \" \").concat(message);\n    }\n}\nexports.MissingStaticPage = MissingStaticPage;\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = \"ENOENT\";\n        this.message = \"Cannot find the middleware module\";\n    }\n}\nexports.MiddlewareNotFoundError = MiddlewareNotFoundError; //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsZ0JBQWdCLEdBQUdFO0FBQ25CRix5QkFBeUIsR0FBR0c7QUFDNUJILGNBQWMsR0FBR0k7QUFDakJKLHNCQUFzQixHQUFHSztBQUN6QkwsaUJBQWlCLEdBQUdNO0FBQ3BCTixnQ0FBZ0MsR0FBR087QUFDbkNQLDJCQUEyQixHQUFHUTtBQUM5QlIsVUFBVSxHQUFHQSxVQUFVLEdBQUdBLHFCQUFxQixHQUFHQSxrQkFBa0IsR0FBRyxLQUFLO0FBQzVFLElBQUlhLHNCQUFzQkMseUlBQTBEO0FBQ3BGLE1BQU1GLGFBQWE7SUFDZjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNEWixrQkFBa0IsR0FBR1k7QUFDckIsU0FBU1YsU0FBU2MsRUFBRSxFQUFFO0lBQ2xCLElBQUlDLE9BQU8sS0FBSztJQUNoQixJQUFJQztJQUNKLE9BQU8sV0FBVzt5Q0FBUEM7WUFBQUE7O1FBQ1AsSUFBSSxDQUFDRixNQUFNO1lBQ1BBLE9BQU8sSUFBSTtZQUNYQyxTQUFTRixNQUFNRztRQUNuQixDQUFDO1FBQ0QsT0FBT0Q7SUFDWDtBQUNKO0FBQ0EsMERBQTBEO0FBQzFELGdFQUFnRTtBQUNoRSxNQUFNRSxxQkFBcUI7QUFDM0IsTUFBTVQsZ0JBQWdCLENBQUNVLE1BQU1ELG1CQUFtQkUsSUFBSSxDQUFDRDtBQUNyRHJCLHFCQUFxQixHQUFHVztBQUN4QixTQUFTUixvQkFBb0I7SUFDekIsTUFBTSxFQUFFb0IsU0FBUSxFQUFHQyxTQUFRLEVBQUdDLEtBQUksRUFBRyxHQUFHQyxPQUFPQyxRQUFRO0lBQ3ZELE9BQU8sR0FBZ0JILE9BQWJELFVBQVMsTUFBZUUsT0FBWEQsVUFBa0MsT0FBdkJDLE9BQU8sTUFBTUEsT0FBTyxFQUFFO0FBQzVEO0FBQ0EsU0FBU3JCLFNB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T0FBTyxLQUFLO0FBQ2pEOUQsVUFBVSxHQUFHUztBQUNiLE1BQU1zRCxvQkFBb0JUO0FBQzFCO0FBQ0F0RCxtQkFBbUIsR0FBRytEO0FBQ3RCLE1BQU1DLHVCQUF1QlY7QUFDN0I7QUFDQXRELHNCQUFzQixHQUFHZ0U7QUFDekIsTUFBTUMsMEJBQTBCWDtJQUM1QlksWUFBWUMsSUFBSSxDQUFDO1FBQ2IsS0FBSztRQUNMLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDZixPQUFPLEdBQUcsZ0NBQXFDLE9BQUxjO0lBQ25EO0FBQ0o7QUFDQW5FLHlCQUF5QixHQUFHaUU7QUFDNUIsTUFBTUksMEJBQTBCZjtJQUM1QlksWUFBWUMsSUFBSSxFQUFFZCxPQUFPLENBQUM7UUFDdEIsS0FBSztRQUNMLElBQUksQ0FBQ0EsT0FBTyxHQUFHLHdDQUFnREEsT0FBUmMsTUFBSyxLQUFXLE9BQVJkO0lBQ25FO0FBQ0o7QUFDQXJELHlCQUF5QixHQUFHcUU7QUFDNUIsTUFBTUMsZ0NBQWdDaEI7SUFDbENZLGFBQWE7UUFDVCxLQUFLO1FBQ0wsSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNmLE9BQU8sR0FBSTtJQUNwQjtBQUNKO0FBQ0FyRCwrQkFBK0IsR0FBR3NFLHlCQUVsQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3V0aWxzLmpzP2U3ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gICAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZXhlY09uY2UgPSBleGVjT25jZTtcclxuZXhwb3J0cy5nZXRMb2NhdGlvbk9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luO1xyXG5leHBvcnRzLmdldFVSTCA9IGdldFVSTDtcclxuZXhwb3J0cy5nZXREaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lO1xyXG5leHBvcnRzLmlzUmVzU2VudCA9IGlzUmVzU2VudDtcclxuZXhwb3J0cy5ub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMgPSBub3JtYWxpemVSZXBlYXRlZFNsYXNoZXM7XHJcbmV4cG9ydHMubG9hZEdldEluaXRpYWxQcm9wcyA9IGxvYWRHZXRJbml0aWFsUHJvcHM7XHJcbmV4cG9ydHMuU1QgPSBleHBvcnRzLlNQID0gZXhwb3J0cy5pc0Fic29sdXRlVXJsID0gZXhwb3J0cy5XRUJfVklUQUxTID0gdm9pZCAwO1xyXG52YXIgX2FzeW5jX3RvX2dlbmVyYXRvciA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19hc3luY190b19nZW5lcmF0b3IuanNcIikuZGVmYXVsdDtcclxuY29uc3QgV0VCX1ZJVEFMUyA9IFtcclxuICAgICdDTFMnLFxyXG4gICAgJ0ZDUCcsXHJcbiAgICAnRklEJyxcclxuICAgICdJTlAnLFxyXG4gICAgJ0xDUCcsXHJcbiAgICAnVFRGQidcclxuXTtcclxuZXhwb3J0cy5XRUJfVklUQUxTID0gV0VCX1ZJVEFMUztcclxuZnVuY3Rpb24gZXhlY09uY2UoZm4pIHtcclxuICAgIGxldCB1c2VkID0gZmFsc2U7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgcmV0dXJuICguLi5hcmdzKT0+e1xyXG4gICAgICAgIGlmICghdXNlZCkge1xyXG4gICAgICAgICAgICB1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gZm4oLi4uYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG59XHJcbi8vIFNjaGVtZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjFcclxuLy8gQWJzb2x1dGUgVVJMOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTQuM1xyXG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo/Oi87XHJcbmNvbnN0IGlzQWJzb2x1dGVVcmwgPSAodXJsKT0+QUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QodXJsKTtcclxuZXhwb3J0cy5pc0Fic29sdXRlVXJsID0gaXNBYnNvbHV0ZVVybDtcclxuZnVuY3Rpb24gZ2V0TG9jYXRpb25PcmlnaW4oKSB7XHJcbiAgICBjb25zdCB7IHByb3RvY29sICwgaG9zdG5hbWUgLCBwb3J0ICB9ID0gd2luZG93LmxvY2F0aW9uO1xyXG4gICAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0bmFtZX0ke3BvcnQgPyAnOicgKyBwb3J0IDogJyd9YDtcclxufVxyXG5mdW5jdGlvbiBnZXRVUkwoKSB7XHJcbiAgICBjb25zdCB7IGhyZWYgIH0gPSB3aW5kb3cubG9jYXRpb247XHJcbiAgICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpO1xyXG4gICAgcmV0dXJuIGhyZWYuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpO1xyXG59XHJcbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKENvbXBvbmVudCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBDb21wb25lbnQgPT09ICdzdHJpbmcnID8gQ29tcG9uZW50IDogQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJztcclxufVxyXG5mdW5jdGlvbiBpc1Jlc1NlbnQocmVzKSB7XHJcbiAgICByZXR1cm4gcmVzLmZpbmlzaGVkIHx8IHJlcy5oZWFkZXJzU2VudDtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVSZXBlYXRlZFNsYXNoZXModXJsKSB7XHJcbiAgICBjb25zdCB1cmxQYXJ0cyA9IHVybC5zcGxpdCgnPycpO1xyXG4gICAgY29uc3QgdXJsTm9RdWVyeSA9IHVybFBhcnRzWzBdO1xyXG4gICAgcmV0dXJuIHVybE5vUXVlcnkvLyBmaXJzdCB3ZSByZXBsYWNlIGFueSBub24tZW5jb2RlZCBiYWNrc2xhc2hlcyB3aXRoIGZvcndhcmRcclxuICAgIC8vIHRoZW4gbm9ybWFsaXplIHJlcGVhdGVkIGZvcndhcmQgc2xhc2hlc1xyXG4gICAgLnJlcGxhY2UoL1xcXFwvZywgJy8nKS5yZXBsYWNlKC9cXC9cXC8rL2csICcvJykgKyAodXJsUGFydHNbMV0gPyBgPyR7dXJsUGFydHMuc2xpY2UoMSkuam9pbignPycpfWAgOiAnJyk7XHJcbn1cclxuZnVuY3Rpb24gbG9hZEdldEluaXRpYWxQcm9wcyhBcHAsIGN0eCkge1xyXG4gICAgcmV0dXJuIF9sb2FkR2V0SW5pdGlhbFByb3BzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gX2xvYWRHZXRJbml0aWFsUHJvcHMoKSB7XHJcbiAgICBfbG9hZEdldEluaXRpYWxQcm9wcyA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKEFwcCwgY3R4KSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgdmFyIHJlZjtcclxuICAgICAgICAgICAgaWYgKChyZWYgPSBBcHAucHJvdG90eXBlKSA9PSBudWxsID8gdm9pZCAwIDogcmVmLmdldEluaXRpYWxQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoQXBwKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAtIHZpc2l0IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2dldC1pbml0aWFsLXByb3BzLWFzLWFuLWluc3RhbmNlLW1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdoZW4gY2FsbGVkIGZyb20gX2FwcCBgY3R4YCBpcyBuZXN0ZWQgaW4gYGN0eGBcclxuICAgICAgICBjb25zdCByZXMgPSBjdHgucmVzIHx8IGN0eC5jdHggJiYgY3R4LmN0eC5yZXM7XHJcbiAgICAgICAgaWYgKCFBcHAuZ2V0SW5pdGlhbFByb3BzKSB7XHJcbiAgICAgICAgICAgIGlmIChjdHguY3R4ICYmIGN0eC5Db21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgcGFnZVByb3BzIGRlZmF1bHRcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZVByb3BzOiB5aWVsZCBsb2FkR2V0SW5pdGlhbFByb3BzKGN0eC5Db21wb25lbnQsIGN0eC5jdHgpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHJvcHMgPSB5aWVsZCBBcHAuZ2V0SW5pdGlhbFByb3BzKGN0eCk7XHJcbiAgICAgICAgaWYgKHJlcyAmJiBpc1Jlc1NlbnQocmVzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvcHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcHJvcHMpIHtcclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoQXBwKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3QuIEJ1dCBmb3VuZCBcIiR7cHJvcHN9XCIgaW5zdGVhZC5gO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID09PSAwICYmICFjdHguY3R4KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7Z2V0RGlzcGxheU5hbWUoQXBwKX0gcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gXFxgZ2V0SW5pdGlhbFByb3BzXFxgLiBUaGlzIGRlLW9wdGltaXplcyBhbmQgcHJldmVudHMgYXV0b21hdGljIHN0YXRpYyBvcHRpbWl6YXRpb24uIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2VtcHR5LW9iamVjdC1nZXRJbml0aWFsUHJvcHNgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvcHM7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBfbG9hZEdldEluaXRpYWxQcm9wcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcbmNvbnN0IFNQID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJztcclxuZXhwb3J0cy5TUCA9IFNQO1xyXG5jb25zdCBTVCA9IFNQICYmIFtcclxuICAgICdtYXJrJyxcclxuICAgICdtZWFzdXJlJyxcclxuICAgICdnZXRFbnRyaWVzQnlOYW1lJ1xyXG5dLmV2ZXJ5KChtZXRob2QpPT50eXBlb2YgcGVyZm9ybWFuY2VbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJyk7XHJcbmV4cG9ydHMuU1QgPSBTVDtcclxuY2xhc3MgRGVjb2RlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbn1cclxuZXhwb3J0cy5EZWNvZGVFcnJvciA9IERlY29kZUVycm9yO1xyXG5jbGFzcyBOb3JtYWxpemVFcnJvciBleHRlbmRzIEVycm9yIHtcclxufVxyXG5leHBvcnRzLk5vcm1hbGl6ZUVycm9yID0gTm9ybWFsaXplRXJyb3I7XHJcbmNsYXNzIFBhZ2VOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IocGFnZSl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmNvZGUgPSAnRU5PRU5UJztcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgQ2Fubm90IGZpbmQgbW9kdWxlIGZvciBwYWdlOiAke3BhZ2V9YDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlBhZ2VOb3RGb3VuZEVycm9yID0gUGFnZU5vdEZvdW5kRXJyb3I7XHJcbmNsYXNzIE1pc3NpbmdTdGF0aWNQYWdlIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IocGFnZSwgbWVzc2FnZSl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgRmFpbGVkIHRvIGxvYWQgc3RhdGljIGZpbGUgZm9yIHBhZ2U6ICR7cGFnZX0gJHttZXNzYWdlfWA7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5NaXNzaW5nU3RhdGljUGFnZSA9IE1pc3NpbmdTdGF0aWNQYWdlO1xyXG5jbGFzcyBNaWRkbGV3YXJlTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmNvZGUgPSAnRU5PRU5UJztcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgQ2Fubm90IGZpbmQgdGhlIG1pZGRsZXdhcmUgbW9kdWxlYDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk1pZGRsZXdhcmVOb3RGb3VuZEVycm9yID0gTWlkZGxld2FyZU5vdEZvdW5kRXJyb3I7XHJcblxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJleGVjT25jZSIsImdldExvY2F0aW9uT3JpZ2luIiwiZ2V0VVJMIiwiZ2V0RGlzcGxheU5hbWUiLCJpc1Jlc1NlbnQiLCJub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiU1QiLCJTUCIsImlzQWJzb2x1dGVVcmwiLCJXRUJfVklUQUxTIiwiX2FzeW5jX3RvX2dlbmVyYXRvciIsInJlcXVpcmUiLCJkZWZhdWx0IiwiZm4iLCJ1c2VkIiwicmVzdWx0IiwiYXJncyIsIkFCU09MVVRFX1VSTF9SRUdFWCIsInVybCIsInRlc3QiLCJwcm90b2NvbCIsImhvc3RuYW1lIiwicG9ydCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsIm9yaWdpbiIsInN1YnN0cmluZyIsImxlbmd0aCIsIkNvbXBvbmVudCIsImRpc3BsYXlOYW1lIiwibmFtZSIsInJlcyIsImZpbmlzaGVkIiwiaGVhZGVyc1NlbnQiLCJ1cmxQYXJ0cyIsInNwbGl0IiwidXJsTm9RdWVyeSIsInJlcGxhY2UiLCJzbGljZSIsImpvaW4iLCJBcHAiLCJjdHgiLCJfbG9hZEdldEluaXRpYWxQcm9wcyIsImFwcGx5IiwiYXJndW1lbnRzIiwicHJvY2VzcyIsInJlZiIsInByb3RvdHlwZSIsImdldEluaXRpYWxQcm9wcyIsIm1lc3NhZ2UiLCJFcnJvciIsInBhZ2VQcm9wcyIsInByb3BzIiwia2V5cyIsImNvbnNvbGUiLCJ3YXJuIiwicGVyZm9ybWFuY2UiLCJldmVyeSIsIm1ldGhvZCIsIkRlY29kZUVycm9yIiwiTm9ybWFsaXplRXJyb3IiLCJQYWdlTm90Rm91bmRFcnJvciIsImNvbnN0cnVjdG9yIiwicGFnZSIsImNvZGUiLCJNaXNzaW5nU3RhdGljUGFnZSIsIk1pZGRsZXdhcmVOb3RGb3VuZEVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/react-is/cjs/react-is.development.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-is/cjs/react-is.development.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\r\n * @license React\r\n * react-is.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n\r\n\r\nif (true) {\r\n  (function() {\r\n'use strict';\r\n\r\n// ATTENTION\r\n// When adding new symbols to this file,\r\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\r\n// The Symbol used to tag the ReactElement-like types.\r\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\r\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\r\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\r\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\r\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\r\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\r\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\r\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\r\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\r\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\r\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\r\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\r\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\r\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\r\nvar enableCacheElement = false;\r\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\r\n\r\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\r\n// stuff. Intended to enable React core members to more easily debug scheduling\r\n// issues in DEV builds.\r\n\r\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\r\n\r\nvar REACT_MODULE_REFERENCE;\r\n\r\n{\r\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\r\n}\r\n\r\nfunction isValidElementType(type) {\r\n  if (typeof type === 'string' || typeof type === 'function') {\r\n    return true;\r\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\r\n\r\n\r\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\r\n    return true;\r\n  }\r\n\r\n  if (typeof type === 'object' && type !== null) {\r\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\r\n    // types supported by any Flight configuration anywhere since\r\n    // we don't know which Flight build this will end up being used\r\n    // with.\r\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction typeOf(object) {\r\n  if (typeof object === 'object' && object !== null) {\r\n    var $$typeof = object.$$typeof;\r\n\r\n    switch ($$typeof) {\r\n      case REACT_ELEMENT_TYPE:\r\n        var type = object.type;\r\n\r\n        switch (type) {\r\n          case REACT_FRAGMENT_TYPE:\r\n          case REACT_PROFILER_TYPE:\r\n          case REACT_STRICT_MODE_TYPE:\r\n          case REACT_SUSPENSE_TYPE:\r\n          case REACT_SUSPENSE_LIST_TYPE:\r\n            return type;\r\n\r\n          default:\r\n            var $$typeofType = type && type.$$typeof;\r\n\r\n            switch ($$typeofType) {\r\n              case REACT_SERVER_CONTEXT_TYPE:\r\n              case REACT_CONTEXT_TYPE:\r\n              case REACT_FORWARD_REF_TYPE:\r\n              case REACT_LAZY_TYPE:\r\n              case REACT_MEMO_TYPE:\r\n              case REACT_PROVIDER_TYPE:\r\n                return $$typeofType;\r\n\r\n              default:\r\n                return $$typeof;\r\n            }\r\n\r\n        }\r\n\r\n      case REACT_PORTAL_TYPE:\r\n        return $$typeof;\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n}\r\nvar ContextConsumer = REACT_CONTEXT_TYPE;\r\nvar ContextProvider = REACT_PROVIDER_TYPE;\r\nvar Element = REACT_ELEMENT_TYPE;\r\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\r\nvar Fragment = REACT_FRAGMENT_TYPE;\r\nvar Lazy = REACT_LAZY_TYPE;\r\nvar Memo = REACT_MEMO_TYPE;\r\nvar Portal = REACT_PORTAL_TYPE;\r\nvar Profiler = REACT_PROFILER_TYPE;\r\nvar StrictMode = REACT_STRICT_MODE_TYPE;\r\nvar Suspense = REACT_SUSPENSE_TYPE;\r\nvar SuspenseList = REACT_SUSPENSE_LIST_TYPE;\r\nvar hasWarnedAboutDeprecatedIsAsyncMode = false;\r\nvar hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated\r\n\r\nfunction isAsyncMode(object) {\r\n  {\r\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\r\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\r\n\r\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\nfunction isConcurrentMode(object) {\r\n  {\r\n    if (!hasWarnedAboutDeprecatedIsConcurrentMode) {\r\n      hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint\r\n\r\n      console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\nfunction isContextConsumer(object) {\r\n  return typeOf(object) === REACT_CONTEXT_TYPE;\r\n}\r\nfunction isContextProvider(object) {\r\n  return typeOf(object) === REACT_PROVIDER_TYPE;\r\n}\r\nfunction isElement(object) {\r\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\r\n}\r\nfunction isForwardRef(object) {\r\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\r\n}\r\nfunction isFragment(object) {\r\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\r\n}\r\nfunction isLazy(object) {\r\n  return typeOf(object) === REACT_LAZY_TYPE;\r\n}\r\nfunction isMemo(object) {\r\n  return typeOf(object) === REACT_MEMO_TYPE;\r\n}\r\nfunction isPortal(object) {\r\n  return typeOf(object) === REACT_PORTAL_TYPE;\r\n}\r\nfunction isProfiler(object) {\r\n  return typeOf(object) === REACT_PROFILER_TYPE;\r\n}\r\nfunction isStrictMode(object) {\r\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\r\n}\r\nfunction isSuspense(object) {\r\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\r\n}\r\nfunction isSuspenseList(object) {\r\n  return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\r\n}\r\n\r\nexports.ContextConsumer = ContextConsumer;\r\nexports.ContextProvider = ContextProvider;\r\nexports.Element = Element;\r\nexports.ForwardRef = ForwardRef;\r\nexports.Fragment = Fragment;\r\nexports.Lazy = Lazy;\r\nexports.Memo = Memo;\r\nexports.Portal = Portal;\r\nexports.Profiler = Profiler;\r\nexports.StrictMode = StrictMode;\r\nexports.Suspense = Suspense;\r\nexports.SuspenseList = SuspenseList;\r\nexports.isAsyncMode = isAsyncMode;\r\nexports.isConcurrentMode = isConcurrentMode;\r\nexports.isContextConsumer = isContextConsumer;\r\nexports.isContextProvider = isContextProvider;\r\nexports.isElement = isElement;\r\nexports.isForwardRef = isForwardRef;\r\nexports.isFragment = isFragment;\r\nexports.isLazy = isLazy;\r\nexports.isMemo = isMemo;\r\nexports.isPortal = isPortal;\r\nexports.isProfiler = isProfiler;\r\nexports.isStrictMode = isStrictMode;\r\nexports.isSuspense = isSuspense;\r\nexports.isSuspenseList = isSuspenseList;\r\nexports.isValidElementType = isValidElementType;\r\nexports.typeOf = typeOf;\r\n  })();\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2I7QUFDQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQztBQUNyQztBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLFlBQVk7QUFDWixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QixpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2QsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQixzQkFBc0I7QUFDdEIsMEJBQTBCO0FBQzFCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanM/ZWM4NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGxpY2Vuc2UgUmVhY3RcclxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcclxuICpcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gIChmdW5jdGlvbigpIHtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gQVRURU5USU9OXHJcbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcclxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xyXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cclxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcclxudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XHJcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcclxudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xyXG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XHJcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcclxudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcclxudmFyIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zZXJ2ZXJfY29udGV4dCcpO1xyXG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XHJcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcclxudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcclxudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcclxudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcclxudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cclxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xyXG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcclxuXHJcbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXHJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcclxuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXHJcblxyXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxyXG5cclxudmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XHJcblxyXG57XHJcbiAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1vZHVsZS5yZWZlcmVuY2UnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXHJcblxyXG5cclxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcclxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxyXG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxyXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXHJcbiAgICAvLyB3aXRoLlxyXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcclxuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XHJcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XHJcblxyXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xyXG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcclxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcclxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcclxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcclxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcclxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxyXG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcclxuXHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcclxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEU6XHJcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XHJcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxyXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxyXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxyXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcclxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XHJcblxyXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcclxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XHJcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xyXG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcclxudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xyXG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xyXG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcclxudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XHJcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcclxudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcclxudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xyXG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xyXG52YXIgU3VzcGVuc2VMaXN0ID0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO1xyXG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTtcclxudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQ29uY3VycmVudE1vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXHJcblxyXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcclxuICB7XHJcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XHJcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcclxuXHJcbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTgrLicpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XHJcbiAge1xyXG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0NvbmN1cnJlbnRNb2RlKSB7XHJcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQ29uY3VycmVudE1vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxyXG5cclxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE4Ky4nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcclxuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcclxuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XHJcbn1cclxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XHJcbn1cclxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XHJcbn1cclxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xyXG59XHJcbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XHJcbn1cclxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcclxuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XHJcbn1cclxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc1N1c3BlbnNlTGlzdChvYmplY3QpIHtcclxuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTtcclxufVxyXG5cclxuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XHJcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xyXG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xyXG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xyXG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XHJcbmV4cG9ydHMuTGF6eSA9IExhenk7XHJcbmV4cG9ydHMuTWVtbyA9IE1lbW87XHJcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xyXG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XHJcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XHJcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcclxuZXhwb3J0cy5TdXNwZW5zZUxpc3QgPSBTdXNwZW5zZUxpc3Q7XHJcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcclxuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcclxuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xyXG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XHJcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xyXG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcclxuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcclxuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XHJcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xyXG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XHJcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XHJcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xyXG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xyXG5leHBvcnRzLmlzU3VzcGVuc2VMaXN0ID0gaXNTdXNwZW5zZUxpc3Q7XHJcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xyXG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcclxuICB9KSgpO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/react-is/cjs/react-is.development.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/react-is/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-is/index.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\n\r\nif (false) {} else {\r\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"./node_modules/next/dist/compiled/react-is/cjs/react-is.development.js\");\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsbUpBQXlEO0FBQzNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXMvaW5kZXguanM/NDIzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcclxufSBlbHNlIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/react-is/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/lib/is-error.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/lib/is-error.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n    value: true\r\n}));\r\nexports[\"default\"] = isError;\r\nexports.getProperError = getProperError;\r\nvar _isPlainObject = __webpack_require__(/*! ../shared/lib/is-plain-object */ \"./node_modules/next/dist/shared/lib/is-plain-object.js\");\r\nfunction isError(err) {\r\n    return typeof err === \"object\" && err !== null && \"name\" in err && \"message\" in err;\r\n}\r\nfunction getProperError(err) {\r\n    if (isError(err)) {\r\n        return err;\r\n    }\r\n    if (true) {\r\n        // provide better error for case where `throw undefined`\r\n        // is called in development\r\n        if (typeof err === \"undefined\") {\r\n            return new Error(\"An undefined error was thrown, \" + \"see here for more info: https://nextjs.org/docs/messages/threw-undefined\");\r\n        }\r\n        if (err === null) {\r\n            return new Error(\"A null error was thrown, \" + \"see here for more info: https://nextjs.org/docs/messages/threw-undefined\");\r\n        }\r\n    }\r\n    return new Error((0, _isPlainObject).isPlainObject(err) ? JSON.stringify(err) : err + \"\");\r\n}\r\n\r\n//# sourceMappingURL=is-error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2xpYi9pcy1lcnJvci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Ysc0JBQXNCO0FBQ3RCLHFCQUFxQixtQkFBTyxDQUFDLDZGQUErQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9saWIvaXMtZXJyb3IuanM/MTc4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gaXNFcnJvcjtcclxuZXhwb3J0cy5nZXRQcm9wZXJFcnJvciA9IGdldFByb3BlckVycm9yO1xyXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pcy1wbGFpbi1vYmplY3RcIik7XHJcbmZ1bmN0aW9uIGlzRXJyb3IoZXJyKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGVyciA9PT0gXCJvYmplY3RcIiAmJiBlcnIgIT09IG51bGwgJiYgXCJuYW1lXCIgaW4gZXJyICYmIFwibWVzc2FnZVwiIGluIGVycjtcclxufVxyXG5mdW5jdGlvbiBnZXRQcm9wZXJFcnJvcihlcnIpIHtcclxuICAgIGlmIChpc0Vycm9yKGVycikpIHtcclxuICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcclxuICAgICAgICAvLyBwcm92aWRlIGJldHRlciBlcnJvciBmb3IgY2FzZSB3aGVyZSBgdGhyb3cgdW5kZWZpbmVkYFxyXG4gICAgICAgIC8vIGlzIGNhbGxlZCBpbiBkZXZlbG9wbWVudFxyXG4gICAgICAgIGlmICh0eXBlb2YgZXJyID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJBbiB1bmRlZmluZWQgZXJyb3Igd2FzIHRocm93biwgXCIgKyBcInNlZSBoZXJlIGZvciBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3RocmV3LXVuZGVmaW5lZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVyciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiQSBudWxsIGVycm9yIHdhcyB0aHJvd24sIFwiICsgXCJzZWUgaGVyZSBmb3IgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy90aHJldy11bmRlZmluZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBFcnJvcigoMCwgX2lzUGxhaW5PYmplY3QpLmlzUGxhaW5PYmplY3QoZXJyKSA/IEpTT04uc3RyaW5naWZ5KGVycikgOiBlcnIgKyBcIlwiKTtcclxufVxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/lib/is-error.js\n"));

/***/ }),

/***/ "./node_modules/next/router.js":
/*!*************************************!*\
  !*** ./node_modules/next/router.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/router */ \"./node_modules/next/dist/client/router.js\")\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9yb3V0ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsNkdBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L3JvdXRlci5qcz8xYmI2Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsaWVudC9yb3V0ZXInKVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/router.js\n"));

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\n\r\nfunction checkDCE() {\r\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\r\n  if (\r\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\r\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\r\n  ) {\r\n    return;\r\n  }\r\n  if (true) {\r\n    // This branch is unreachable because this function is only called\r\n    // in production, but the condition is true only in development.\r\n    // Therefore if the branch is still here, dead code elimination wasn't\r\n    // properly applied.\r\n    // Don't change the message. React DevTools relies on it. Also make sure\r\n    // this message doesn't occur elsewhere in this function, or it will cause\r\n    // a false positive.\r\n    throw new Error('^_^');\r\n  }\r\n  try {\r\n    // Verify that the code above has been dead code eliminated (DCE'd).\r\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\r\n  } catch (err) {\r\n    // DevTools shouldn't crash React, no matter what.\r\n    // We should still report in case we break this code.\r\n    console.error(err);\r\n  }\r\n}\r\n\r\nif (false) {} else {\r\n  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"./node_modules/react-dom/cjs/react-dom.development.js\");\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFxQyxFQUFFLEVBSzFDLENBQUM7QUFDRixFQUFFLG1JQUEwRDtBQUM1RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzPzc3MjIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZnVuY3Rpb24gY2hlY2tEQ0UoKSB7XHJcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xyXG4gIGlmIChcclxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnIHx8XHJcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXHJcbiAgKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAvLyBUaGlzIGJyYW5jaCBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWRcclxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cclxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcclxuICAgIC8vIHByb3Blcmx5IGFwcGxpZWQuXHJcbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcclxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXHJcbiAgICAvLyBhIGZhbHNlIHBvc2l0aXZlLlxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcclxuICB9XHJcbiAgdHJ5IHtcclxuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXHJcbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cclxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXHJcbiAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgfVxyXG59XHJcblxyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xyXG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxyXG4gIC8vIERldlRvb2xzIGNhbiByZXBvcnQgYmFkIG1pbmlmaWNhdGlvbiBkdXJpbmcgaW5qZWN0aW9uLlxyXG4gIGNoZWNrRENFKCk7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMnKTtcclxufSBlbHNlIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcycpO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-dom/index.js\n"));

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\n\r\nif (false) {} else {\r\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SEFBc0Q7QUFDeEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzPzFmYjIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XHJcbn0gZWxzZSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/index.js\n"));

/***/ })

});